{
  "version": 3,
  "sources": [
    "node_modules/grunt-browserify/node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "node_modules/handlebars/dist/cjs/handlebars.runtime.js",
    "node_modules/handlebars/dist/cjs/handlebars/base.js",
    "node_modules/handlebars/dist/cjs/handlebars/exception.js",
    "node_modules/handlebars/dist/cjs/handlebars/no-conflict.js",
    "node_modules/handlebars/dist/cjs/handlebars/runtime.js",
    "node_modules/handlebars/dist/cjs/handlebars/safe-string.js",
    "node_modules/handlebars/dist/cjs/handlebars/utils.js",
    "node_modules/handlebars/runtime.js",
    "node_modules/hbsfy/runtime.js",
    "node_modules/qunitjs/qunit/qunit.js",
    "node_modules/webcomponents.js/webcomponents.js",
    "test/fwc/integration/hello.tpl",
    "test/fwc/integration/test.js",
    "test/sauce.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjHA;AACA;AACA;AACA;;ACHA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC33HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACj8NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;QCTO,mCAAmC;;QACnC,gBAAgB;;uBACL,SAAS;;;;mBACX,KAAK;;;;AAErB,qBAAM,MAAM,CAAC,UAAU,CAAC,CAAC;;AAEzB,qBAAM,SAAS,CAAC,iCAAiC,EAAE,CAAC,EAAE,UAAS,MAAM,EAAC;AAClE,QAAI,SAAS,GAAG,QAAQ,CAAC,cAAc,CAAC,mBAAmB,CAAC,CAAC;AAC7D,UAAM,CAAC,EAAE,CAAC,SAAS,YAAY,WAAW,EAAE,sBAAsB,CAAC,CAAC;;AAEpE,0BAAI,MAAM,CAAC,CACN,EAAE,CAAC,OAAO,EAAE,UAAS,CAAC,EAAC;AACpB,eAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;KACpB,CAAC,CACD,EAAE,CAAC,QAAQ,EAAE,UAAS,GAAG,EAAC;;AAEvB,YAAI,KAAK,GAAG,SAAS,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;AAC9C,cAAM,CAAC,KAAK,CAAC,KAAK,CAAC,QAAQ,EAAE,QAAQ,EAAE,+BAA+B,CAAC,CAAC;AACxE,cAAM,CAAC,KAAK,CAAC,KAAK,CAAC,QAAQ,EAAE,GAAG,CAAC,QAAQ,EAAE,4CAA4C,CAAC,CAAC;AACzF,cAAM,CAAC,SAAS,CAAC,KAAK,EAAE,GAAG,EAAE,oCAAoC,CAAC,CAAC;;AAEnE,6BAAM,KAAK,EAAE,CAAC;KACjB,CAAC,CACD,QAAQ,EAAE,CAAC;CACnB,CAAC,CAAC;;AAGH,qBAAM,SAAS,CAAC,iCAAiC,EAAE,CAAC,EAAE,UAAS,MAAM,EAAC;AAClE,QAAI,SAAS,GAAG,QAAQ,CAAC,cAAc,CAAC,mBAAmB,CAAC,CAAC;AAC7D,UAAM,CAAC,EAAE,CAAC,SAAS,YAAY,WAAW,EAAE,sBAAsB,CAAC,CAAC;;AAEpE,0BAAI,KAAK,EAAE,EAAC,SAAS,EAAG,KAAK,EAAC,CAAC,CAC1B,EAAE,CAAC,OAAO,EAAE,UAAS,CAAC,EAAC;AACpB,eAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;KACpB,CAAC,CACD,EAAE,CAAC,QAAQ,EAAE,UAAS,GAAG,EAAC;;AAEvB,YAAI,MAAM,GAAG,SAAS,CAAC,aAAa,CAAC,SAAS,CAAC,CAAC;AAChD,cAAM,CAAC,KAAK,CAAC,MAAM,CAAC,QAAQ,EAAE,SAAS,EAAE,gCAAgC,CAAC,CAAC;AAC3E,cAAM,CAAC,KAAK,CAAC,MAAM,CAAC,QAAQ,EAAE,GAAG,CAAC,QAAQ,EAAE,6CAA6C,CAAC,CAAC;AAC3F,cAAM,CAAC,SAAS,CAAC,MAAM,EAAE,GAAG,EAAE,oCAAoC,CAAC,CAAC;;AAEpE,6BAAM,KAAK,EAAE,CAAC;KACjB,CAAC,CACD,QAAQ,EAAE,CAAC;CACnB,CAAC,CAAC;;AAEH,qBAAM,SAAS,CAAC,iCAAiC,EAAE,CAAC,EAAE,UAAS,MAAM,EAAC;AAClE,QAAI,SAAS,GAAG,QAAQ,CAAC,cAAc,CAAC,mBAAmB,CAAC,CAAC;AAC7D,UAAM,CAAC,EAAE,CAAC,SAAS,YAAY,WAAW,EAAE,sBAAsB,CAAC,CAAC;;AAEpE,QAAI,GAAG,GAAG,CAAC,CAAC;;AAEZ,0BAAI,OAAO,CAAC,CACP,EAAE,CAAC,OAAO,EAAE,UAAS,CAAC,EAAC;AACpB,eAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;KACpB,CAAC,CACD,EAAE,CAAC,QAAQ,EAAE,UAAS,GAAG,EAAC;;AAEvB,cAAM,CAAC,KAAK,CAAC,GAAG,CAAC,QAAQ,EAAE,SAAS,EAAE,wBAAwB,CAAC,CAAC;AAChE,YAAI,KAAK,GAAG,QAAQ,CAAC,GAAG,CAAC,YAAY,CAAC,OAAO,CAAC,EAAE,EAAE,CAAC,CAAC;AACpD,cAAM,CAAC,EAAE,CAAC,KAAK,GAAG,CAAC,EAAE,uBAAuB,CAAC,CAAC;AAC9C,WAAG,IAAI,KAAK,CAAC;;AAEb,YAAG,GAAG,KAAK,CAAC,EAAC;;AAET,iCAAM,KAAK,EAAE,CAAC;SACjB;KACJ,CAAC,CACD,QAAQ,EAAE,CAAC;CACnB,CAAC,CAAC;;AAEH,qBAAM,MAAM,CAAC,YAAY,CAAC,CAAC;;AAE3B,qBAAM,SAAS,CAAC,yBAAyB,EAAE,CAAC,EAAE,UAAS,MAAM,EAAC;AAC1D,QAAI,SAAS,GAAG,QAAQ,CAAC,cAAc,CAAC,mBAAmB,CAAC,CAAC;AAC7D,UAAM,CAAC,EAAE,CAAC,SAAS,YAAY,WAAW,EAAE,sBAAsB,CAAC,CAAC;;AAEpE,0BAAI,MAAM,CAAC,CACN,EAAE,CAAC,OAAO,EAAE,UAAS,CAAC,EAAC;AACpB,eAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;KACpB,CAAC,CACD,EAAE,CAAC,QAAQ,EAAE,UAAS,GAAG,EAAC;;AAEvB,YAAI,KAAK,GAAG,SAAS,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;AAC9C,cAAM,CAAC,SAAS,CAAC,KAAK,EAAE,GAAG,EAAE,oCAAoC,CAAC,CAAC;AACnE,cAAM,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC;AAC5B,cAAM,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;AAC/B,cAAM,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,EAAE,KAAK,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,CAAC;AACnD,cAAM,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,EAAE,KAAK,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,CAAC;;AAEnD,aAAK,CAAC,GAAG,GAAG,KAAK,CAAC;AAClB,cAAM,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;AAC/B,cAAM,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,EAAE,KAAK,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,CAAC;;AAEnD,6BAAM,KAAK,EAAE,CAAC;KACjB,CAAC,CACD,KAAK,CAAC,KAAK,EAAE,KAAK,CAAC,CACnB,QAAQ,EAAE,CAAC;CACnB,CAAC,CAAC;;AAEH,qBAAM,SAAS,CAAC,qCAAqC,EAAE,EAAE,EAAE,UAAS,MAAM,EAAC;AACvE,QAAI,SAAS,GAAG,QAAQ,CAAC,cAAc,CAAC,mBAAmB,CAAC,CAAC;AAC7D,UAAM,CAAC,EAAE,CAAC,SAAS,YAAY,WAAW,EAAE,sBAAsB,CAAC,CAAC;;AAEpE,0BAAI,MAAM,CAAC,CACN,EAAE,CAAC,OAAO,EAAE,UAAS,CAAC,EAAC;AACpB,eAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;KACpB,CAAC,CACD,EAAE,CAAC,QAAQ,EAAE,UAAS,GAAG,EAAC;;AAEvB,YAAI,KAAK,GAAG,SAAS,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;AAC9C,cAAM,CAAC,SAAS,CAAC,KAAK,EAAE,GAAG,EAAE,oCAAoC,CAAC,CAAC;;AAEnE,cAAM,CAAC,KAAK,CAAC,KAAK,CAAC,YAAY,CAAC,KAAK,CAAC,EAAE,QAAQ,EAAE,sBAAsB,CAAC,CAAC;AAC1E,cAAM,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,EAAE,GAAG,EAAE,uCAAuC,CAAC,CAAC;AACtE,aAAK,CAAC,GAAG,GAAG,MAAM,CAAC;AACnB,cAAM,CAAC,KAAK,CAAC,KAAK,CAAC,YAAY,CAAC,KAAK,CAAC,EAAE,GAAG,EAAE,kCAAkC,CAAC,CAAC;AACjF,cAAM,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC,EAAE,uCAAuC,CAAC,CAAC;;AAEpE,cAAM,CAAC,KAAK,CAAC,KAAK,CAAC,YAAY,CAAC,OAAO,CAAC,EAAE,IAAI,EAAE,sBAAsB,CAAC,CAAC;AACxE,cAAM,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,EAAE,IAAI,EAAE,uCAAuC,CAAC,CAAC;AACzE,aAAK,CAAC,KAAK,GAAG,OAAO,CAAC;AACtB,cAAM,CAAC,KAAK,CAAC,KAAK,CAAC,YAAY,CAAC,OAAO,CAAC,EAAE,MAAM,EAAE,kCAAkC,CAAC,CAAC;AACtF,cAAM,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,EAAE,IAAI,EAAE,uCAAuC,CAAC,CAAC;;AAEzE,cAAM,CAAC,EAAE,CAAC,KAAK,CAAC,YAAY,CAAC,MAAM,CAAC,EAAE,sBAAsB,CAAC,CAAC;AAC9D,cAAM,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,EAAE,oCAAoC,CAAC,CAAC;AACrE,aAAK,CAAC,IAAI,GAAG,KAAK,CAAC;AACnB,cAAM,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,YAAY,CAAC,MAAM,CAAC,EAAE,sCAAsC,CAAC,CAAC;AAC/E,cAAM,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,EAAE,KAAK,EAAE,mCAAmC,CAAC,CAAC;AACrE,aAAK,CAAC,IAAI,GAAG,IAAI,CAAC;AAClB,cAAM,CAAC,EAAE,CAAC,KAAK,CAAC,YAAY,CAAC,MAAM,CAAC,EAAE,8BAA8B,CAAC,CAAC;AACtE,cAAM,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,EAAE,kCAAkC,CAAC,CAAC;;AAEnE,6BAAM,KAAK,EAAE,CAAC;KACjB,CAAC,CACD,IAAI,CAAC,KAAK,EAAI,EAAE,IAAI,EAAG,SAAS,EAAE,CAAC,CACnC,IAAI,CAAC,OAAO,EAAE,EAAE,IAAI,EAAG,OAAO,EAAE,CAAC,CACjC,IAAI,CAAC,MAAM,EAAG,EAAE,IAAI,EAAG,SAAS,EAAE,CAAC,CACnC,QAAQ,EAAE,CAAC;CACnB,CAAC,CAAC;;AAEH,qBAAM,SAAS,CAAC,kCAAkC,EAAE,EAAE,EAAE,UAAS,MAAM,EAAC;AACpE,QAAI,SAAS,GAAG,QAAQ,CAAC,cAAc,CAAC,mBAAmB,CAAC,CAAC;AAC7D,UAAM,CAAC,EAAE,CAAC,SAAS,YAAY,WAAW,EAAE,sBAAsB,CAAC,CAAC;;AAEpE,0BAAI,QAAQ,CAAC,CACR,EAAE,CAAC,OAAO,EAAE,UAAS,CAAC,EAAC;AACpB,eAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;KACpB,CAAC,CACD,EAAE,CAAC,QAAQ,EAAE,UAAS,GAAG,EAAC;;AAEvB,YAAI,OAAO,GAAG,SAAS,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;AAClD,cAAM,CAAC,SAAS,CAAC,OAAO,EAAE,GAAG,EAAE,oCAAoC,CAAC,CAAC;AACrE,cAAM,CAAC,KAAK,CAAC,OAAO,CAAC,YAAY,CAAC,KAAK,CAAC,EAAE,GAAG,EAAE,iCAAiC,CAAC,CAAC;AAClF,cAAM,CAAC,EAAE,CAAC,OAAO,CAAC,YAAY,CAAC,MAAM,CAAC,EAAE,2BAA2B,CAAC,CAAC;AACrE,cAAM,CAAC,KAAK,CAAC,OAAO,CAAC,YAAY,CAAC,KAAK,CAAC,EAAE,GAAG,EAAE,iCAAiC,CAAC,CAAC;AAClF,cAAM,CAAC,KAAK,CAAC,OAAO,CAAC,YAAY,CAAC,QAAQ,CAAC,EAAE,GAAG,EAAE,oCAAoC,CAAC,CAAC;;AAExF,cAAM,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC,EAAE,0BAA0B,CAAC,CAAC;AACzD,cAAM,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,EAAE,KAAK,EAAE,2BAA2B,CAAC,CAAC;AAC/D,cAAM,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC,EAAE,0BAA0B,CAAC,CAAC;AACzD,cAAM,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC,EAAE,0BAA0B,CAAC,CAAC;;AAEzD,eAAO,CAAC,MAAM,GAAG,CAAC,CAAC;AACnB,cAAM,CAAC,KAAK,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,8BAA8B,CAAC,CAAC;;AAEhE,6BAAM,KAAK,EAAE,CAAC;KACjB,CAAC,CACD,KAAK,CAAC,KAAK,EAAE,MAAM,EAAE,KAAK,CAAC,CAC3B,MAAM,CAAC,KAAK,EAAE;AACX,WAAG,EAAA,aAAC,GAAG,EAAC;AACL,mBAAO,QAAQ,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC;SAC3B;KACJ,CAAC,CACD,MAAM,CAAC,QAAQ,EAAE;AACd,WAAG,EAAA,aAAC,GAAG,EAAC;AACL,mBAAO,QAAQ,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC;SAC3B;AACD,WAAG,EAAA,aAAC,GAAG,EAAE,GAAG,EAAC;AACT,eAAG,GAAG,QAAQ,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC;AACxB,eAAG,GAAG,GAAG,GAAG,CAAC,CAAC;AACd,mBAAO,GAAG,CAAC;SACd;KACJ,CAAC,CACD,MAAM,CAAC,MAAM,EAAE;AACZ,WAAG,EAAA,aAAC,GAAG,EAAC;AACL,mBAAO,CAAC,CAAC,GAAG,CAAC;SACf;KACJ,CAAC,CACD,MAAM,CAAC,KAAK,EAAE;AACX,WAAG,EAAA,aAAC,GAAG,EAAC;AACJ,eAAG,GAAG,QAAQ,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC;AACxB,gBAAI,CAAC,YAAY,CAAC,KAAK,EAAE,EAAE,GAAG,CAAC,CAAC;AACjC,mBAAO,GAAG,CAAC;SACb;KACJ,CAAC,CACD,QAAQ,EAAE,CAAC;CACnB,CAAC,CAAC;;AAEH,qBAAM,MAAM,CAAC,SAAS,CAAC,CAAC;;AAExB,qBAAM,SAAS,CAAC,yBAAyB,EAAE,CAAC,EAAE,UAAS,MAAM,EAAC;AAC1D,QAAI,SAAS,GAAG,QAAQ,CAAC,cAAc,CAAC,mBAAmB,CAAC,CAAC;AAC7D,UAAM,CAAC,EAAE,CAAC,SAAS,YAAY,WAAW,EAAE,sBAAsB,CAAC,CAAC;;AAEpE,QAAI,OAAO,GAAG,SAAS,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;AAClD,UAAM,CAAC,EAAE,CAAC,OAAO,CAAC,KAAK,CAAC,OAAO,KAAK,MAAM,EAAE,kCAAkC,CAAC,CAAC;;AAEhF,0BAAI,QAAQ,CAAC,CACR,EAAE,CAAC,OAAO,EAAE,UAAS,CAAC,EAAC;AACpB,eAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;KACpB,CAAC,CACD,EAAE,CAAC,QAAQ,EAAE,UAAS,GAAG,EAAC;;AAEvB,YAAI,OAAO,GAAG,SAAS,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;AAClD,cAAM,CAAC,SAAS,CAAC,OAAO,EAAE,GAAG,EAAE,oCAAoC,CAAC,CAAC;;AAErE,cAAM,CAAC,EAAE,CAAC,OAAO,OAAO,CAAC,IAAI,KAAK,UAAU,EAAE,oCAAoC,CAAC,CAAC;;AAEpF,eAAO,CAAC,IAAI,EAAE,CAAC;;AAEf,cAAM,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,OAAO,EAAE,MAAM,EAAE,6CAA6C,CAAC,CAAC;;AAE3F,6BAAM,KAAK,EAAE,CAAC;KACjB,CAAC,CACD,MAAM,CAAC,MAAM,EAAE,YAAU;;AAEtB,YAAI,OAAO,GAAG,SAAS,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;AAClD,cAAM,CAAC,SAAS,CAAC,OAAO,EAAE,IAAI,EAAE,wBAAwB,CAAC,CAAC;;AAE1D,cAAM,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,UAAU,EAAE,gCAAgC,CAAC,CAAC;;AAExE,gBAAQ,CAAC,aAAa,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,KAAK,CAAC,OAAO,GAAG,MAAM,CAAC;KAC9D,CAAC,CACD,KAAK,CAAC,QAAQ,CAAC,CACf,QAAQ,EAAE,CAAC;CACnB,CAAC,CAAC;;AAEH,qBAAM,MAAM,CAAC,SAAS,CAAC,CAAC;;AAExB,qBAAM,SAAS,CAAC,wCAAwC,EAAE,EAAE,EAAE,UAAS,MAAM,EAAC;AAC1E,QAAI,SAAS,GAAG,QAAQ,CAAC,cAAc,CAAC,mBAAmB,CAAC,CAAC;AAC7D,UAAM,CAAC,EAAE,CAAC,SAAS,YAAY,WAAW,EAAE,sBAAsB,CAAC,CAAC;;AAEpE,QAAI,gBAAgB,GAAG,SAAS,gBAAgB,CAAC,IAAI,EAAC;;AAElD,cAAM,CAAC,EAAE,CAAC,OAAO,IAAI,KAAK,QAAQ,EAAE,8DAA8D,CAAC,CAAC;AACpG,cAAM,CAAC,EAAE,CAAC,OAAO,IAAI,CAAC,GAAG,KAAK,QAAQ,EAAE,2DAA2D,CAAC,CAAC;AACrG,cAAM,CAAC,EAAE,CAAC,OAAO,IAAI,CAAC,MAAM,KAAK,QAAQ,EAAE,8DAA8D,CAAC,CAAC;;AAE3G,YAAI,OAAO,GAAG,EAAE,CAAC;AACjB,YAAI,KAAK,GAAK,QAAQ,CAAC,IAAI,CAAC,MAAM,IAAI,CAAC,CAAC,CAAC;AACzC,eAAM,KAAK,EAAE,EAAC;AACV,mBAAO,aAAW,IAAI,CAAC,GAAG,UAAO,CAAC;SACrC;AACD,wBAAc,OAAO,WAAQ;KAChC,CAAC;;AAEF,UAAM,CAAC,KAAK,CAAC,SAAS,CAAC,gBAAgB,CAAC,cAAc,CAAC,CAAC,MAAM,EAAE,CAAC,EAAE,uCAAuC,CAAC,CAAC;;AAE5G,0BAAI,SAAS,CAAC,CACT,EAAE,CAAC,OAAO,EAAE,UAAS,CAAC,EAAC;AACpB,eAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;KACpB,CAAC,CACD,EAAE,CAAC,QAAQ,EAAE,UAAS,GAAG,EAAC;;AAEvB,YAAI,QAAQ,GAAG,SAAS,CAAC,aAAa,CAAC,WAAW,CAAC,CAAC;AACpD,cAAM,CAAC,SAAS,CAAC,QAAQ,EAAE,GAAG,EAAE,oCAAoC,CAAC,CAAC;AACtE,cAAM,CAAC,KAAK,CAAC,QAAQ,CAAC,MAAM,EAAE,GAAG,EAAE,uBAAuB,CAAC,CAAC;AAC5D,cAAM,CAAC,KAAK,CAAC,QAAQ,CAAC,GAAG,EAAE,KAAK,EAAE,sBAAsB,CAAC,CAAC;AAC1D,cAAM,CAAC,KAAK,CAAC,GAAG,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC,MAAM,EAAE,CAAC,EAAE,mCAAmC,CAAC,CAAC;AACxF,cAAM,CAAC,KAAK,CAAC,GAAG,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC,MAAM,EAAE,CAAC,EAAE,yCAAyC,CAAC,CAAC;AAC9F,cAAM,CAAC,KAAK,CAAC,GAAG,CAAC,aAAa,CAAC,gBAAgB,CAAC,CAAC,WAAW,EAAE,KAAK,EAAE,mCAAmC,CAAC,CAAC;;AAE1G,6BAAM,KAAK,EAAE,CAAC;KACjB,CAAC,CACD,KAAK,CAAC,KAAK,EAAE,QAAQ,CAAC,CACtB,OAAO,CAAC,gBAAgB,CAAC,CACzB,QAAQ,EAAE,CAAC;CACnB,CAAC,CAAC;;AAEH,qBAAM,SAAS,CAAC,gDAAgD,EAAE,CAAC,EAAE,UAAS,MAAM,EAAC;AACjF,QAAI,SAAS,GAAG,QAAQ,CAAC,cAAc,CAAC,mBAAmB,CAAC,CAAC;AAC7D,UAAM,CAAC,EAAE,CAAC,SAAS,YAAY,WAAW,EAAE,sBAAsB,CAAC,CAAC;;AAEpE,QAAI,QAAQ,GAAG,OAAO,CAAC,aAAa,CAAC,CAAC;AACtC,UAAM,CAAC,EAAE,CAAC,OAAO,QAAQ,KAAK,UAAU,EAAE,8BAA8B,CAAC,CAAC;;AAE1E,UAAM,CAAC,KAAK,CAAC,SAAS,CAAC,gBAAgB,CAAC,iBAAiB,CAAC,CAAC,MAAM,EAAE,CAAC,EAAE,sCAAsC,CAAC,CAAC;;AAE9G,0BAAI,YAAY,CAAC,CACZ,EAAE,CAAC,OAAO,EAAE,UAAS,CAAC,EAAC;AACpB,eAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;KACpB,CAAC,CACD,EAAE,CAAC,QAAQ,EAAE,UAAS,GAAG,EAAC;;AAEvB,YAAI,WAAW,GAAG,SAAS,CAAC,aAAa,CAAC,cAAc,CAAC,CAAC;AAC1D,cAAM,CAAC,SAAS,CAAC,WAAW,EAAE,GAAG,EAAE,oCAAoC,CAAC,CAAC;;AAEzE,cAAM,CAAC,KAAK,CAAC,WAAW,CAAC,GAAG,EAAE,OAAO,EAAE,uCAAuC,CAAC,CAAC;AAChF,cAAM,CAAC,KAAK,CAAC,SAAS,CAAC,gBAAgB,CAAC,iBAAiB,CAAC,CAAC,MAAM,EAAE,CAAC,EAAE,8BAA8B,CAAC,CAAC;;AAEtG,cAAM,CAAC,KAAK,CAAC,WAAW,CAAC,WAAW,CAAC,IAAI,EAAE,EAAE,aAAa,EAAE,oDAAoD,CAAC,CAAC;;AAElH,mBAAW,CAAC,GAAG,GAAG,UAAU,CAAC;AAC7B,kBAAU,CAAE,YAAM;AACd,kBAAM,CAAC,KAAK,CAAC,WAAW,CAAC,WAAW,CAAC,IAAI,EAAE,EAAE,gBAAgB,EAAE,qCAAqC,CAAC,CAAC;AACtG,iCAAM,KAAK,EAAE,CAAC;SACjB,EAAE,CAAC,CAAC,CAAC;KACT,CAAC,CACD,IAAI,CAAC,KAAK,EAAE,EAAE,MAAM,EAAE,IAAI,EAAE,CAAC,CAC7B,OAAO,CAAC,QAAQ,CAAC,CACjB,QAAQ,EAAE,CAAC;CACnB,CAAC,CAAC;;AAGH,qBAAM,SAAS,CAAC,sDAAsD,EAAE,CAAC,EAAE,UAAS,MAAM,EAAC;AACvF,QAAI,SAAS,GAAG,QAAQ,CAAC,cAAc,CAAC,mBAAmB,CAAC,CAAC;AAC7D,UAAM,CAAC,EAAE,CAAC,SAAS,YAAY,WAAW,EAAE,sBAAsB,CAAC,CAAC;;AAEpE,QAAI,IAAI,GAAG,QAAQ,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC;;AAE3C,0BAAI,UAAU,CAAC,CACV,EAAE,CAAC,QAAQ,EAAE,UAAS,GAAG,EAAC;;AAEvB,YAAI,QAAQ,GAAG,SAAS,CAAC,aAAa,CAAC,YAAY,CAAC,CAAC;AACrD,cAAM,CAAC,SAAS,CAAC,QAAQ,EAAE,GAAG,EAAE,oCAAoC,CAAC,CAAC;;AAEtE,cAAM,CAAC,KAAK,CAAC,GAAG,CAAC,gBAAgB,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,CAAC,EAAE,wCAAwC,CAAC,CAAC;AAC5F,cAAM,CAAC,KAAK,CAAC,GAAG,CAAC,SAAS,EAAE,IAAI,CAAC,SAAS,EAAE,mDAAmD,CAAC,CAAC;;AAEjG,6BAAM,KAAK,EAAE,CAAC;KACjB,CAAC,CACD,OAAO,CAAC,IAAI,CAAC,CACb,QAAQ,EAAE,CAAC;CACnB,CAAC,CAAC;;AAGH,qBAAM,MAAM,CAAC,QAAQ,CAAC,CAAC;;AAEvB,qBAAM,SAAS,CAAC,kBAAkB,EAAE,CAAC,EAAE,UAAS,MAAM,EAAC;AACnD,QAAI,SAAS,GAAG,QAAQ,CAAC,cAAc,CAAC,mBAAmB,CAAC,CAAC;AAC7D,UAAM,CAAC,EAAE,CAAC,SAAS,YAAY,WAAW,EAAE,sBAAsB,CAAC,CAAC;;AAEpE,QAAI,IAAI,GAAG,QAAQ,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;;AAE5C,0BAAI,MAAM,CAAC,CACN,EAAE,CAAC,OAAO,EAAE,UAAS,CAAC,EAAC;AACpB,eAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;KACpB,CAAC,CACD,EAAE,CAAC,QAAQ,EAAE,UAAS,GAAG,EAAC;;AAEvB,YAAI,KAAK,GAAG,QAAQ,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;;AAE7C,cAAM,CAAC,EAAE,CAAC,KAAK,YAAY,WAAW,EAAE,iCAAiC,CAAC,CAAC;AAC3E,cAAM,CAAC,EAAE,CAAC,KAAK,YAAY,iBAAiB,EAAE,uCAAuC,CAAC,CAAC;;AAEvF,cAAM,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,KAAK,GAAG,EAAE,qDAAqD,CAAC,CAAC;AACpF,cAAM,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE,0DAA0D,CAAC,CAAC;;AAEhG,6BAAM,KAAK,EAAE,CAAC;KACjB,CAAC,CACD,MAAM,CAAC,GAAG,CAAC,CACX,QAAQ,EAAE,CAAC;CACnB,CAAC,CAAC;;AAGH,qBAAM,SAAS,CAAC,0BAA0B,EAAE,CAAC,EAAE,UAAS,MAAM,EAAC;AAC3D,QAAI,SAAS,GAAG,QAAQ,CAAC,cAAc,CAAC,mBAAmB,CAAC,CAAC;AAC7D,UAAM,CAAC,EAAE,CAAC,SAAS,YAAY,WAAW,EAAE,sBAAsB,CAAC,CAAC;;AAEpE,0BAAI,OAAO,CAAC,CACP,EAAE,CAAC,OAAO,EAAE,UAAS,CAAC,EAAC;AACpB,eAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;KACpB,CAAC,CACD,EAAE,CAAC,QAAQ,EAAE,UAAS,GAAG,EAAC;AACvB,cAAM,CAAC,EAAE,CAAC,KAAK,EAAE,0CAA0C,CAAC,CAAC;KAChE,CAAC,CACD,MAAM,CAAC,KAAK,EAAE;AACX,WAAG,EAAA,aAAC,GAAG,EAAC;AACJ,eAAG,GAAG,GAAG,IAAI,EAAE,CAAC;AACjB,mBAAO,GAAG,CAAC,WAAW,EAAE,CAAC;SAC3B;KACJ,CAAC,CACD,QAAQ,EAAE,CAAC;;AAEhB,0BAAI,SAAS,CAAC,CACT,EAAE,CAAC,QAAQ,EAAE,UAAS,GAAG,EAAC;;AAEvB,YAAI,QAAQ,GAAG,QAAQ,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;;AAElD,cAAM,CAAC,SAAS,CAAC,QAAQ,EAAE,GAAG,EAAE,oCAAoC,CAAC,CAAC;AACtE,cAAM,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,EAAE,2CAA2C,CAAC,CAAC;;AAE1E,6BAAM,KAAK,EAAE,CAAC;KACjB,CAAC,CACD,MAAM,CAAC,OAAO,CAAC,CACf,QAAQ,EAAE,CAAC;CACnB,CAAC,CAAC;;AAEH,qBAAM,MAAM,CAAC,eAAe,CAAC,CAAC;;AAE9B,qBAAM,IAAI,CAAC,UAAU,EAAE,CAAC,EAAE,UAAS,MAAM,EAAC;AACtC,QAAI,IAAI,GAAG,MAAM,CAAC,KAAK,EAAE,CAAC;AAC1B,QAAI,SAAS,GAAG,QAAQ,CAAC,cAAc,CAAC,mBAAmB,CAAC,CAAC;AAC7D,UAAM,CAAC,EAAE,CAAC,SAAS,YAAY,WAAW,EAAE,sBAAsB,CAAC,CAAC;;AAEpE,0BAAI,QAAQ,CAAC,CACR,EAAE,CAAC,OAAO,EAAE,UAAS,CAAC,EAAC;AACpB,eAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;KACpB,CAAC,CACD,EAAE,CAAC,QAAQ,EAAE,UAAS,GAAG,EAAC;;AAEvB,YAAI,OAAO,GAAG,QAAQ,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;AACjD,cAAM,CAAC,SAAS,CAAC,OAAO,EAAE,GAAG,EAAE,oCAAoC,CAAC,CAAC;;AAErE,eAAO,CAAC,KAAK,EAAE,CAAC;KACnB,CAAC,CACD,EAAE,CAAC,OAAO,EAAE,UAAS,GAAG,EAAC;;AAEtB,YAAI,OAAO,GAAG,QAAQ,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;AACjD,cAAM,CAAC,SAAS,CAAC,OAAO,EAAE,GAAG,EAAE,oCAAoC,CAAC,CAAC;;AAErE,YAAI,EAAE,CAAC;KACV,CAAC,CACD,QAAQ,EAAE,CAAC;CACnB,CAAC,CAAC;;;;;;;;uBC5agB,SAAS;;;;AAE5B,IAAI,SAAS,GAAG,EAAE,CAAC;;AAEnB,qBAAM,IAAI,CAAC,UAAS,OAAO,EAAE;;AAEzB,QAAI,OAAO,GAAG,SAAS,CAClB,MAAM,CAAC,UAAS,QAAQ,EAAE;AACvB,eAAO,QAAQ,CAAC,MAAM,KAAK,KAAK,CAAC;KACpC,CAAC,CACD,GAAG,CAAC,UAAS,QAAQ,EAAE;AACpB,eAAO;AACH,gBAAI,EAAM,QAAQ,CAAC,MAAM,GAAG,KAAK,GAAG,QAAQ,CAAC,IAAI;AACjD,kBAAM,EAAI,QAAQ,CAAC,MAAM;AACzB,oBAAQ,EAAE,QAAQ,CAAC,QAAQ;AAC3B,kBAAM,EAAI,QAAQ,CAAC,MAAM;AACzB,kBAAM,EAAI,QAAQ,CAAC,MAAM;SAC5B,CAAC;KACL,CAAC,CAAC;;AAEP,UAAM,CAAC,mBAAmB,GAAG;AACzB,cAAM,EAAI,OAAO,CAAC,MAAM;AACxB,cAAM,EAAI,OAAO,CAAC,MAAM;AACxB,aAAK,EAAK,OAAO,CAAC,KAAK;AACvB,gBAAQ,EAAE,OAAO,CAAC,OAAO;AACzB,aAAK,EAAK,OAAO;KACpB,CAAC;CACL,CAAC,CAAC;;AAEH,qBAAM,SAAS,CAAC,YAAW;AACvB,yBAAM,GAAG,CAAC,UAAS,OAAO,EAAE;AACxB,iBAAS,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;KAC3B,CAAC,CAAC;CACN,CAAC,CAAC",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "'use strict';\n\nvar _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };\n\nexports.__esModule = true;\n\nvar _import = require('./handlebars/base');\n\nvar base = _interopRequireWildcard(_import);\n\n// Each of these augment the Handlebars object. No need to setup here.\n// (This is done to easily share code between commonjs and browse envs)\n\nvar _SafeString = require('./handlebars/safe-string');\n\nvar _SafeString2 = _interopRequireWildcard(_SafeString);\n\nvar _Exception = require('./handlebars/exception');\n\nvar _Exception2 = _interopRequireWildcard(_Exception);\n\nvar _import2 = require('./handlebars/utils');\n\nvar Utils = _interopRequireWildcard(_import2);\n\nvar _import3 = require('./handlebars/runtime');\n\nvar runtime = _interopRequireWildcard(_import3);\n\nvar _noConflict = require('./handlebars/no-conflict');\n\nvar _noConflict2 = _interopRequireWildcard(_noConflict);\n\n// For compatibility and usage outside of module systems, make the Handlebars object a namespace\nfunction create() {\n  var hb = new base.HandlebarsEnvironment();\n\n  Utils.extend(hb, base);\n  hb.SafeString = _SafeString2['default'];\n  hb.Exception = _Exception2['default'];\n  hb.Utils = Utils;\n  hb.escapeExpression = Utils.escapeExpression;\n\n  hb.VM = runtime;\n  hb.template = function (spec) {\n    return runtime.template(spec, hb);\n  };\n\n  return hb;\n}\n\nvar inst = create();\ninst.create = create;\n\n_noConflict2['default'](inst);\n\ninst['default'] = inst;\n\nexports['default'] = inst;\nmodule.exports = exports['default'];",
    "'use strict';\n\nvar _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };\n\nexports.__esModule = true;\nexports.HandlebarsEnvironment = HandlebarsEnvironment;\nexports.createFrame = createFrame;\n\nvar _import = require('./utils');\n\nvar Utils = _interopRequireWildcard(_import);\n\nvar _Exception = require('./exception');\n\nvar _Exception2 = _interopRequireWildcard(_Exception);\n\nvar VERSION = '3.0.1';\nexports.VERSION = VERSION;\nvar COMPILER_REVISION = 6;\n\nexports.COMPILER_REVISION = COMPILER_REVISION;\nvar REVISION_CHANGES = {\n  1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it\n  2: '== 1.0.0-rc.3',\n  3: '== 1.0.0-rc.4',\n  4: '== 1.x.x',\n  5: '== 2.0.0-alpha.x',\n  6: '>= 2.0.0-beta.1'\n};\n\nexports.REVISION_CHANGES = REVISION_CHANGES;\nvar isArray = Utils.isArray,\n    isFunction = Utils.isFunction,\n    toString = Utils.toString,\n    objectType = '[object Object]';\n\nfunction HandlebarsEnvironment(helpers, partials) {\n  this.helpers = helpers || {};\n  this.partials = partials || {};\n\n  registerDefaultHelpers(this);\n}\n\nHandlebarsEnvironment.prototype = {\n  constructor: HandlebarsEnvironment,\n\n  logger: logger,\n  log: log,\n\n  registerHelper: function registerHelper(name, fn) {\n    if (toString.call(name) === objectType) {\n      if (fn) {\n        throw new _Exception2['default']('Arg not supported with multiple helpers');\n      }\n      Utils.extend(this.helpers, name);\n    } else {\n      this.helpers[name] = fn;\n    }\n  },\n  unregisterHelper: function unregisterHelper(name) {\n    delete this.helpers[name];\n  },\n\n  registerPartial: function registerPartial(name, partial) {\n    if (toString.call(name) === objectType) {\n      Utils.extend(this.partials, name);\n    } else {\n      if (typeof partial === 'undefined') {\n        throw new _Exception2['default']('Attempting to register a partial as undefined');\n      }\n      this.partials[name] = partial;\n    }\n  },\n  unregisterPartial: function unregisterPartial(name) {\n    delete this.partials[name];\n  }\n};\n\nfunction registerDefaultHelpers(instance) {\n  instance.registerHelper('helperMissing', function () {\n    if (arguments.length === 1) {\n      // A missing field in a {{foo}} constuct.\n      return undefined;\n    } else {\n      // Someone is actually trying to call something, blow up.\n      throw new _Exception2['default']('Missing helper: \"' + arguments[arguments.length - 1].name + '\"');\n    }\n  });\n\n  instance.registerHelper('blockHelperMissing', function (context, options) {\n    var inverse = options.inverse,\n        fn = options.fn;\n\n    if (context === true) {\n      return fn(this);\n    } else if (context === false || context == null) {\n      return inverse(this);\n    } else if (isArray(context)) {\n      if (context.length > 0) {\n        if (options.ids) {\n          options.ids = [options.name];\n        }\n\n        return instance.helpers.each(context, options);\n      } else {\n        return inverse(this);\n      }\n    } else {\n      if (options.data && options.ids) {\n        var data = createFrame(options.data);\n        data.contextPath = Utils.appendContextPath(options.data.contextPath, options.name);\n        options = { data: data };\n      }\n\n      return fn(context, options);\n    }\n  });\n\n  instance.registerHelper('each', function (context, options) {\n    if (!options) {\n      throw new _Exception2['default']('Must pass iterator to #each');\n    }\n\n    var fn = options.fn,\n        inverse = options.inverse,\n        i = 0,\n        ret = '',\n        data = undefined,\n        contextPath = undefined;\n\n    if (options.data && options.ids) {\n      contextPath = Utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';\n    }\n\n    if (isFunction(context)) {\n      context = context.call(this);\n    }\n\n    if (options.data) {\n      data = createFrame(options.data);\n    }\n\n    function execIteration(field, index, last) {\n      if (data) {\n        data.key = field;\n        data.index = index;\n        data.first = index === 0;\n        data.last = !!last;\n\n        if (contextPath) {\n          data.contextPath = contextPath + field;\n        }\n      }\n\n      ret = ret + fn(context[field], {\n        data: data,\n        blockParams: Utils.blockParams([context[field], field], [contextPath + field, null])\n      });\n    }\n\n    if (context && typeof context === 'object') {\n      if (isArray(context)) {\n        for (var j = context.length; i < j; i++) {\n          execIteration(i, i, i === context.length - 1);\n        }\n      } else {\n        var priorKey = undefined;\n\n        for (var key in context) {\n          if (context.hasOwnProperty(key)) {\n            // We're running the iterations one step out of sync so we can detect\n            // the last iteration without have to scan the object twice and create\n            // an itermediate keys array.\n            if (priorKey) {\n              execIteration(priorKey, i - 1);\n            }\n            priorKey = key;\n            i++;\n          }\n        }\n        if (priorKey) {\n          execIteration(priorKey, i - 1, true);\n        }\n      }\n    }\n\n    if (i === 0) {\n      ret = inverse(this);\n    }\n\n    return ret;\n  });\n\n  instance.registerHelper('if', function (conditional, options) {\n    if (isFunction(conditional)) {\n      conditional = conditional.call(this);\n    }\n\n    // Default behavior is to render the positive path if the value is truthy and not empty.\n    // The `includeZero` option may be set to treat the condtional as purely not empty based on the\n    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.\n    if (!options.hash.includeZero && !conditional || Utils.isEmpty(conditional)) {\n      return options.inverse(this);\n    } else {\n      return options.fn(this);\n    }\n  });\n\n  instance.registerHelper('unless', function (conditional, options) {\n    return instance.helpers['if'].call(this, conditional, { fn: options.inverse, inverse: options.fn, hash: options.hash });\n  });\n\n  instance.registerHelper('with', function (context, options) {\n    if (isFunction(context)) {\n      context = context.call(this);\n    }\n\n    var fn = options.fn;\n\n    if (!Utils.isEmpty(context)) {\n      if (options.data && options.ids) {\n        var data = createFrame(options.data);\n        data.contextPath = Utils.appendContextPath(options.data.contextPath, options.ids[0]);\n        options = { data: data };\n      }\n\n      return fn(context, options);\n    } else {\n      return options.inverse(this);\n    }\n  });\n\n  instance.registerHelper('log', function (message, options) {\n    var level = options.data && options.data.level != null ? parseInt(options.data.level, 10) : 1;\n    instance.log(level, message);\n  });\n\n  instance.registerHelper('lookup', function (obj, field) {\n    return obj && obj[field];\n  });\n}\n\nvar logger = {\n  methodMap: { 0: 'debug', 1: 'info', 2: 'warn', 3: 'error' },\n\n  // State enum\n  DEBUG: 0,\n  INFO: 1,\n  WARN: 2,\n  ERROR: 3,\n  level: 1,\n\n  // Can be overridden in the host environment\n  log: function log(level, message) {\n    if (typeof console !== 'undefined' && logger.level <= level) {\n      var method = logger.methodMap[level];\n      (console[method] || console.log).call(console, message); // eslint-disable-line no-console\n    }\n  }\n};\n\nexports.logger = logger;\nvar log = logger.log;\n\nexports.log = log;\n\nfunction createFrame(object) {\n  var frame = Utils.extend({}, object);\n  frame._parent = object;\n  return frame;\n}\n\n/* [args, ]options */",
    "'use strict';\n\nexports.__esModule = true;\n\nvar errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];\n\nfunction Exception(message, node) {\n  var loc = node && node.loc,\n      line = undefined,\n      column = undefined;\n  if (loc) {\n    line = loc.start.line;\n    column = loc.start.column;\n\n    message += ' - ' + line + ':' + column;\n  }\n\n  var tmp = Error.prototype.constructor.call(this, message);\n\n  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.\n  for (var idx = 0; idx < errorProps.length; idx++) {\n    this[errorProps[idx]] = tmp[errorProps[idx]];\n  }\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, Exception);\n  }\n\n  if (loc) {\n    this.lineNumber = line;\n    this.column = column;\n  }\n}\n\nException.prototype = new Error();\n\nexports['default'] = Exception;\nmodule.exports = exports['default'];",
    "'use strict';\n\nexports.__esModule = true;\n/*global window */\n\nexports['default'] = function (Handlebars) {\n  /* istanbul ignore next */\n  var root = typeof global !== 'undefined' ? global : window,\n      $Handlebars = root.Handlebars;\n  /* istanbul ignore next */\n  Handlebars.noConflict = function () {\n    if (root.Handlebars === Handlebars) {\n      root.Handlebars = $Handlebars;\n    }\n  };\n};\n\nmodule.exports = exports['default'];",
    "'use strict';\n\nvar _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };\n\nexports.__esModule = true;\nexports.checkRevision = checkRevision;\n\n// TODO: Remove this line and break up compilePartial\n\nexports.template = template;\nexports.wrapProgram = wrapProgram;\nexports.resolvePartial = resolvePartial;\nexports.invokePartial = invokePartial;\nexports.noop = noop;\n\nvar _import = require('./utils');\n\nvar Utils = _interopRequireWildcard(_import);\n\nvar _Exception = require('./exception');\n\nvar _Exception2 = _interopRequireWildcard(_Exception);\n\nvar _COMPILER_REVISION$REVISION_CHANGES$createFrame = require('./base');\n\nfunction checkRevision(compilerInfo) {\n  var compilerRevision = compilerInfo && compilerInfo[0] || 1,\n      currentRevision = _COMPILER_REVISION$REVISION_CHANGES$createFrame.COMPILER_REVISION;\n\n  if (compilerRevision !== currentRevision) {\n    if (compilerRevision < currentRevision) {\n      var runtimeVersions = _COMPILER_REVISION$REVISION_CHANGES$createFrame.REVISION_CHANGES[currentRevision],\n          compilerVersions = _COMPILER_REVISION$REVISION_CHANGES$createFrame.REVISION_CHANGES[compilerRevision];\n      throw new _Exception2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');\n    } else {\n      // Use the embedded version info since the runtime doesn't know about this revision yet\n      throw new _Exception2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');\n    }\n  }\n}\n\nfunction template(templateSpec, env) {\n  /* istanbul ignore next */\n  if (!env) {\n    throw new _Exception2['default']('No environment passed to template');\n  }\n  if (!templateSpec || !templateSpec.main) {\n    throw new _Exception2['default']('Unknown template object: ' + typeof templateSpec);\n  }\n\n  // Note: Using env.VM references rather than local var references throughout this section to allow\n  // for external users to override these as psuedo-supported APIs.\n  env.VM.checkRevision(templateSpec.compiler);\n\n  function invokePartialWrapper(partial, context, options) {\n    if (options.hash) {\n      context = Utils.extend({}, context, options.hash);\n    }\n\n    partial = env.VM.resolvePartial.call(this, partial, context, options);\n    var result = env.VM.invokePartial.call(this, partial, context, options);\n\n    if (result == null && env.compile) {\n      options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);\n      result = options.partials[options.name](context, options);\n    }\n    if (result != null) {\n      if (options.indent) {\n        var lines = result.split('\\n');\n        for (var i = 0, l = lines.length; i < l; i++) {\n          if (!lines[i] && i + 1 === l) {\n            break;\n          }\n\n          lines[i] = options.indent + lines[i];\n        }\n        result = lines.join('\\n');\n      }\n      return result;\n    } else {\n      throw new _Exception2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');\n    }\n  }\n\n  // Just add water\n  var container = {\n    strict: function strict(obj, name) {\n      if (!(name in obj)) {\n        throw new _Exception2['default']('\"' + name + '\" not defined in ' + obj);\n      }\n      return obj[name];\n    },\n    lookup: function lookup(depths, name) {\n      var len = depths.length;\n      for (var i = 0; i < len; i++) {\n        if (depths[i] && depths[i][name] != null) {\n          return depths[i][name];\n        }\n      }\n    },\n    lambda: function lambda(current, context) {\n      return typeof current === 'function' ? current.call(context) : current;\n    },\n\n    escapeExpression: Utils.escapeExpression,\n    invokePartial: invokePartialWrapper,\n\n    fn: function fn(i) {\n      return templateSpec[i];\n    },\n\n    programs: [],\n    program: function program(i, data, declaredBlockParams, blockParams, depths) {\n      var programWrapper = this.programs[i],\n          fn = this.fn(i);\n      if (data || depths || blockParams || declaredBlockParams) {\n        programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);\n      } else if (!programWrapper) {\n        programWrapper = this.programs[i] = wrapProgram(this, i, fn);\n      }\n      return programWrapper;\n    },\n\n    data: function data(value, depth) {\n      while (value && depth--) {\n        value = value._parent;\n      }\n      return value;\n    },\n    merge: function merge(param, common) {\n      var obj = param || common;\n\n      if (param && common && param !== common) {\n        obj = Utils.extend({}, common, param);\n      }\n\n      return obj;\n    },\n\n    noop: env.VM.noop,\n    compilerInfo: templateSpec.compiler\n  };\n\n  function ret(context) {\n    var options = arguments[1] === undefined ? {} : arguments[1];\n\n    var data = options.data;\n\n    ret._setup(options);\n    if (!options.partial && templateSpec.useData) {\n      data = initData(context, data);\n    }\n    var depths = undefined,\n        blockParams = templateSpec.useBlockParams ? [] : undefined;\n    if (templateSpec.useDepths) {\n      depths = options.depths ? [context].concat(options.depths) : [context];\n    }\n\n    return templateSpec.main.call(container, context, container.helpers, container.partials, data, blockParams, depths);\n  }\n  ret.isTop = true;\n\n  ret._setup = function (options) {\n    if (!options.partial) {\n      container.helpers = container.merge(options.helpers, env.helpers);\n\n      if (templateSpec.usePartial) {\n        container.partials = container.merge(options.partials, env.partials);\n      }\n    } else {\n      container.helpers = options.helpers;\n      container.partials = options.partials;\n    }\n  };\n\n  ret._child = function (i, data, blockParams, depths) {\n    if (templateSpec.useBlockParams && !blockParams) {\n      throw new _Exception2['default']('must pass block params');\n    }\n    if (templateSpec.useDepths && !depths) {\n      throw new _Exception2['default']('must pass parent depths');\n    }\n\n    return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);\n  };\n  return ret;\n}\n\nfunction wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {\n  function prog(context) {\n    var options = arguments[1] === undefined ? {} : arguments[1];\n\n    return fn.call(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), depths && [context].concat(depths));\n  }\n  prog.program = i;\n  prog.depth = depths ? depths.length : 0;\n  prog.blockParams = declaredBlockParams || 0;\n  return prog;\n}\n\nfunction resolvePartial(partial, context, options) {\n  if (!partial) {\n    partial = options.partials[options.name];\n  } else if (!partial.call && !options.name) {\n    // This is a dynamic partial that returned a string\n    options.name = partial;\n    partial = options.partials[partial];\n  }\n  return partial;\n}\n\nfunction invokePartial(partial, context, options) {\n  options.partial = true;\n\n  if (partial === undefined) {\n    throw new _Exception2['default']('The partial ' + options.name + ' could not be found');\n  } else if (partial instanceof Function) {\n    return partial(context, options);\n  }\n}\n\nfunction noop() {\n  return '';\n}\n\nfunction initData(context, data) {\n  if (!data || !('root' in data)) {\n    data = data ? _COMPILER_REVISION$REVISION_CHANGES$createFrame.createFrame(data) : {};\n    data.root = context;\n  }\n  return data;\n}",
    "'use strict';\n\nexports.__esModule = true;\n// Build out our basic SafeString type\nfunction SafeString(string) {\n  this.string = string;\n}\n\nSafeString.prototype.toString = SafeString.prototype.toHTML = function () {\n  return '' + this.string;\n};\n\nexports['default'] = SafeString;\nmodule.exports = exports['default'];",
    "'use strict';\n\nexports.__esModule = true;\nexports.extend = extend;\n\n// Older IE versions do not directly support indexOf so we must implement our own, sadly.\nexports.indexOf = indexOf;\nexports.escapeExpression = escapeExpression;\nexports.isEmpty = isEmpty;\nexports.blockParams = blockParams;\nexports.appendContextPath = appendContextPath;\nvar escape = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  '\\'': '&#x27;',\n  '`': '&#x60;'\n};\n\nvar badChars = /[&<>\"'`]/g,\n    possible = /[&<>\"'`]/;\n\nfunction escapeChar(chr) {\n  return escape[chr];\n}\n\nfunction extend(obj /* , ...source */) {\n  for (var i = 1; i < arguments.length; i++) {\n    for (var key in arguments[i]) {\n      if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {\n        obj[key] = arguments[i][key];\n      }\n    }\n  }\n\n  return obj;\n}\n\nvar toString = Object.prototype.toString;\n\nexports.toString = toString;\n// Sourced from lodash\n// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt\n/*eslint-disable func-style, no-var */\nvar isFunction = function isFunction(value) {\n  return typeof value === 'function';\n};\n// fallback for older versions of Chrome and Safari\n/* istanbul ignore next */\nif (isFunction(/x/)) {\n  exports.isFunction = isFunction = function (value) {\n    return typeof value === 'function' && toString.call(value) === '[object Function]';\n  };\n}\nvar isFunction;\nexports.isFunction = isFunction;\n/*eslint-enable func-style, no-var */\n\n/* istanbul ignore next */\nvar isArray = Array.isArray || function (value) {\n  return value && typeof value === 'object' ? toString.call(value) === '[object Array]' : false;\n};exports.isArray = isArray;\n\nfunction indexOf(array, value) {\n  for (var i = 0, len = array.length; i < len; i++) {\n    if (array[i] === value) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nfunction escapeExpression(string) {\n  if (typeof string !== 'string') {\n    // don't escape SafeStrings, since they're already safe\n    if (string && string.toHTML) {\n      return string.toHTML();\n    } else if (string == null) {\n      return '';\n    } else if (!string) {\n      return string + '';\n    }\n\n    // Force a string conversion as this will be done by the append regardless and\n    // the regex test will do this transparently behind the scenes, causing issues if\n    // an object's to string has escaped characters in it.\n    string = '' + string;\n  }\n\n  if (!possible.test(string)) {\n    return string;\n  }\n  return string.replace(badChars, escapeChar);\n}\n\nfunction isEmpty(value) {\n  if (!value && value !== 0) {\n    return true;\n  } else if (isArray(value) && value.length === 0) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction blockParams(params, ids) {\n  params.path = ids;\n  return params;\n}\n\nfunction appendContextPath(contextPath, id) {\n  return (contextPath ? contextPath + '.' : '') + id;\n}",
    "// Create a simple path alias to allow browserify to resolve\n// the runtime on a supported path.\nmodule.exports = require('./dist/cjs/handlebars.runtime')['default'];\n",
    "module.exports = require(\"handlebars/runtime\")[\"default\"];\n",
    "/*!\n * QUnit 1.19.0\n * http://qunitjs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2015-09-01T15:00Z\n */\n\n(function( global ) {\n\nvar QUnit = {};\n\nvar Date = global.Date;\nvar now = Date.now || function() {\n\treturn new Date().getTime();\n};\n\nvar setTimeout = global.setTimeout;\nvar clearTimeout = global.clearTimeout;\n\n// Store a local window from the global to allow direct references.\nvar window = global.window;\n\nvar defined = {\n\tdocument: window && window.document !== undefined,\n\tsetTimeout: setTimeout !== undefined,\n\tsessionStorage: (function() {\n\t\tvar x = \"qunit-test-string\";\n\t\ttry {\n\t\t\tsessionStorage.setItem( x, x );\n\t\t\tsessionStorage.removeItem( x );\n\t\t\treturn true;\n\t\t} catch ( e ) {\n\t\t\treturn false;\n\t\t}\n\t}() )\n};\n\nvar fileName = ( sourceFromStacktrace( 0 ) || \"\" ).replace( /(:\\d+)+\\)?/, \"\" ).replace( /.+\\//, \"\" );\nvar globalStartCalled = false;\nvar runStarted = false;\n\nvar toString = Object.prototype.toString,\n\thasOwn = Object.prototype.hasOwnProperty;\n\n// returns a new Array with the elements that are in a but not in b\nfunction diff( a, b ) {\n\tvar i, j,\n\t\tresult = a.slice();\n\n\tfor ( i = 0; i < result.length; i++ ) {\n\t\tfor ( j = 0; j < b.length; j++ ) {\n\t\t\tif ( result[ i ] === b[ j ] ) {\n\t\t\t\tresult.splice( i, 1 );\n\t\t\t\ti--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\n// from jquery.js\nfunction inArray( elem, array ) {\n\tif ( array.indexOf ) {\n\t\treturn array.indexOf( elem );\n\t}\n\n\tfor ( var i = 0, length = array.length; i < length; i++ ) {\n\t\tif ( array[ i ] === elem ) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n/**\n * Makes a clone of an object using only Array or Object as base,\n * and copies over the own enumerable properties.\n *\n * @param {Object} obj\n * @return {Object} New object with only the own properties (recursively).\n */\nfunction objectValues ( obj ) {\n\tvar key, val,\n\t\tvals = QUnit.is( \"array\", obj ) ? [] : {};\n\tfor ( key in obj ) {\n\t\tif ( hasOwn.call( obj, key ) ) {\n\t\t\tval = obj[ key ];\n\t\t\tvals[ key ] = val === Object( val ) ? objectValues( val ) : val;\n\t\t}\n\t}\n\treturn vals;\n}\n\nfunction extend( a, b, undefOnly ) {\n\tfor ( var prop in b ) {\n\t\tif ( hasOwn.call( b, prop ) ) {\n\n\t\t\t// Avoid \"Member not found\" error in IE8 caused by messing with window.constructor\n\t\t\t// This block runs on every environment, so `global` is being used instead of `window`\n\t\t\t// to avoid errors on node.\n\t\t\tif ( prop !== \"constructor\" || a !== global ) {\n\t\t\t\tif ( b[ prop ] === undefined ) {\n\t\t\t\t\tdelete a[ prop ];\n\t\t\t\t} else if ( !( undefOnly && typeof a[ prop ] !== \"undefined\" ) ) {\n\t\t\t\t\ta[ prop ] = b[ prop ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a;\n}\n\nfunction objectType( obj ) {\n\tif ( typeof obj === \"undefined\" ) {\n\t\treturn \"undefined\";\n\t}\n\n\t// Consider: typeof null === object\n\tif ( obj === null ) {\n\t\treturn \"null\";\n\t}\n\n\tvar match = toString.call( obj ).match( /^\\[object\\s(.*)\\]$/ ),\n\t\ttype = match && match[ 1 ] || \"\";\n\n\tswitch ( type ) {\n\t\tcase \"Number\":\n\t\t\tif ( isNaN( obj ) ) {\n\t\t\t\treturn \"nan\";\n\t\t\t}\n\t\t\treturn \"number\";\n\t\tcase \"String\":\n\t\tcase \"Boolean\":\n\t\tcase \"Array\":\n\t\tcase \"Set\":\n\t\tcase \"Map\":\n\t\tcase \"Date\":\n\t\tcase \"RegExp\":\n\t\tcase \"Function\":\n\t\t\treturn type.toLowerCase();\n\t}\n\tif ( typeof obj === \"object\" ) {\n\t\treturn \"object\";\n\t}\n\treturn undefined;\n}\n\n// Safe object type checking\nfunction is( type, obj ) {\n\treturn QUnit.objectType( obj ) === type;\n}\n\nvar getUrlParams = function() {\n\tvar i, current;\n\tvar urlParams = {};\n\tvar location = window.location;\n\tvar params = location.search.slice( 1 ).split( \"&\" );\n\tvar length = params.length;\n\n\tif ( params[ 0 ] ) {\n\t\tfor ( i = 0; i < length; i++ ) {\n\t\t\tcurrent = params[ i ].split( \"=\" );\n\t\t\tcurrent[ 0 ] = decodeURIComponent( current[ 0 ] );\n\n\t\t\t// allow just a key to turn on a flag, e.g., test.html?noglobals\n\t\t\tcurrent[ 1 ] = current[ 1 ] ? decodeURIComponent( current[ 1 ] ) : true;\n\t\t\tif ( urlParams[ current[ 0 ] ] ) {\n\t\t\t\turlParams[ current[ 0 ] ] = [].concat( urlParams[ current[ 0 ] ], current[ 1 ] );\n\t\t\t} else {\n\t\t\t\turlParams[ current[ 0 ] ] = current[ 1 ];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn urlParams;\n};\n\n// Doesn't support IE6 to IE9, it will return undefined on these browsers\n// See also https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error/Stack\nfunction extractStacktrace( e, offset ) {\n\toffset = offset === undefined ? 4 : offset;\n\n\tvar stack, include, i;\n\n\tif ( e.stack ) {\n\t\tstack = e.stack.split( \"\\n\" );\n\t\tif ( /^error$/i.test( stack[ 0 ] ) ) {\n\t\t\tstack.shift();\n\t\t}\n\t\tif ( fileName ) {\n\t\t\tinclude = [];\n\t\t\tfor ( i = offset; i < stack.length; i++ ) {\n\t\t\t\tif ( stack[ i ].indexOf( fileName ) !== -1 ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tinclude.push( stack[ i ] );\n\t\t\t}\n\t\t\tif ( include.length ) {\n\t\t\t\treturn include.join( \"\\n\" );\n\t\t\t}\n\t\t}\n\t\treturn stack[ offset ];\n\n\t// Support: Safari <=6 only\n\t} else if ( e.sourceURL ) {\n\n\t\t// exclude useless self-reference for generated Error objects\n\t\tif ( /qunit.js$/.test( e.sourceURL ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// for actual exceptions, this is useful\n\t\treturn e.sourceURL + \":\" + e.line;\n\t}\n}\n\nfunction sourceFromStacktrace( offset ) {\n\tvar error = new Error();\n\n\t// Support: Safari <=7 only, IE <=10 - 11 only\n\t// Not all browsers generate the `stack` property for `new Error()`, see also #636\n\tif ( !error.stack ) {\n\t\ttry {\n\t\t\tthrow error;\n\t\t} catch ( err ) {\n\t\t\terror = err;\n\t\t}\n\t}\n\n\treturn extractStacktrace( error, offset );\n}\n\n/**\n * Config object: Maintain internal state\n * Later exposed as QUnit.config\n * `config` initialized at top of scope\n */\nvar config = {\n\t// The queue of tests to run\n\tqueue: [],\n\n\t// block until document ready\n\tblocking: true,\n\n\t// by default, run previously failed tests first\n\t// very useful in combination with \"Hide passed tests\" checked\n\treorder: true,\n\n\t// by default, modify document.title when suite is done\n\taltertitle: true,\n\n\t// by default, scroll to top of the page when suite is done\n\tscrolltop: true,\n\n\t// depth up-to which object will be dumped\n\tmaxDepth: 5,\n\n\t// when enabled, all tests must call expect()\n\trequireExpects: false,\n\n\t// add checkboxes that are persisted in the query-string\n\t// when enabled, the id is set to `true` as a `QUnit.config` property\n\turlConfig: [\n\t\t{\n\t\t\tid: \"hidepassed\",\n\t\t\tlabel: \"Hide passed tests\",\n\t\t\ttooltip: \"Only show tests and assertions that fail. Stored as query-strings.\"\n\t\t},\n\t\t{\n\t\t\tid: \"noglobals\",\n\t\t\tlabel: \"Check for Globals\",\n\t\t\ttooltip: \"Enabling this will test if any test introduces new properties on the \" +\n\t\t\t\t\"global object (`window` in Browsers). Stored as query-strings.\"\n\t\t},\n\t\t{\n\t\t\tid: \"notrycatch\",\n\t\t\tlabel: \"No try-catch\",\n\t\t\ttooltip: \"Enabling this will run tests outside of a try-catch block. Makes debugging \" +\n\t\t\t\t\"exceptions in IE reasonable. Stored as query-strings.\"\n\t\t}\n\t],\n\n\t// Set of all modules.\n\tmodules: [],\n\n\t// The first unnamed module\n\tcurrentModule: {\n\t\tname: \"\",\n\t\ttests: []\n\t},\n\n\tcallbacks: {}\n};\n\nvar urlParams = defined.document ? getUrlParams() : {};\n\n// Push a loose unnamed module to the modules collection\nconfig.modules.push( config.currentModule );\n\nif ( urlParams.filter === true ) {\n\tdelete urlParams.filter;\n}\n\n// String search anywhere in moduleName+testName\nconfig.filter = urlParams.filter;\n\nconfig.testId = [];\nif ( urlParams.testId ) {\n\t// Ensure that urlParams.testId is an array\n\turlParams.testId = decodeURIComponent( urlParams.testId ).split( \",\" );\n\tfor (var i = 0; i < urlParams.testId.length; i++ ) {\n\t\tconfig.testId.push( urlParams.testId[ i ] );\n\t}\n}\n\nvar loggingCallbacks = {};\n\n// Register logging callbacks\nfunction registerLoggingCallbacks( obj ) {\n\tvar i, l, key,\n\t\tcallbackNames = [ \"begin\", \"done\", \"log\", \"testStart\", \"testDone\",\n\t\t\t\"moduleStart\", \"moduleDone\" ];\n\n\tfunction registerLoggingCallback( key ) {\n\t\tvar loggingCallback = function( callback ) {\n\t\t\tif ( objectType( callback ) !== \"function\" ) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"QUnit logging methods require a callback function as their first parameters.\"\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconfig.callbacks[ key ].push( callback );\n\t\t};\n\n\t\t// DEPRECATED: This will be removed on QUnit 2.0.0+\n\t\t// Stores the registered functions allowing restoring\n\t\t// at verifyLoggingCallbacks() if modified\n\t\tloggingCallbacks[ key ] = loggingCallback;\n\n\t\treturn loggingCallback;\n\t}\n\n\tfor ( i = 0, l = callbackNames.length; i < l; i++ ) {\n\t\tkey = callbackNames[ i ];\n\n\t\t// Initialize key collection of logging callback\n\t\tif ( objectType( config.callbacks[ key ] ) === \"undefined\" ) {\n\t\t\tconfig.callbacks[ key ] = [];\n\t\t}\n\n\t\tobj[ key ] = registerLoggingCallback( key );\n\t}\n}\n\nfunction runLoggingCallbacks( key, args ) {\n\tvar i, l, callbacks;\n\n\tcallbacks = config.callbacks[ key ];\n\tfor ( i = 0, l = callbacks.length; i < l; i++ ) {\n\t\tcallbacks[ i ]( args );\n\t}\n}\n\n// DEPRECATED: This will be removed on 2.0.0+\n// This function verifies if the loggingCallbacks were modified by the user\n// If so, it will restore it, assign the given callback and print a console warning\nfunction verifyLoggingCallbacks() {\n\tvar loggingCallback, userCallback;\n\n\tfor ( loggingCallback in loggingCallbacks ) {\n\t\tif ( QUnit[ loggingCallback ] !== loggingCallbacks[ loggingCallback ] ) {\n\n\t\t\tuserCallback = QUnit[ loggingCallback ];\n\n\t\t\t// Restore the callback function\n\t\t\tQUnit[ loggingCallback ] = loggingCallbacks[ loggingCallback ];\n\n\t\t\t// Assign the deprecated given callback\n\t\t\tQUnit[ loggingCallback ]( userCallback );\n\n\t\t\tif ( global.console && global.console.warn ) {\n\t\t\t\tglobal.console.warn(\n\t\t\t\t\t\"QUnit.\" + loggingCallback + \" was replaced with a new value.\\n\" +\n\t\t\t\t\t\"Please, check out the documentation on how to apply logging callbacks.\\n\" +\n\t\t\t\t\t\"Reference: http://api.qunitjs.com/category/callbacks/\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n}\n\n( function() {\n\tif ( !defined.document ) {\n\t\treturn;\n\t}\n\n\t// `onErrorFnPrev` initialized at top of scope\n\t// Preserve other handlers\n\tvar onErrorFnPrev = window.onerror;\n\n\t// Cover uncaught exceptions\n\t// Returning true will suppress the default browser handler,\n\t// returning false will let it run.\n\twindow.onerror = function( error, filePath, linerNr ) {\n\t\tvar ret = false;\n\t\tif ( onErrorFnPrev ) {\n\t\t\tret = onErrorFnPrev( error, filePath, linerNr );\n\t\t}\n\n\t\t// Treat return value as window.onerror itself does,\n\t\t// Only do our handling if not suppressed.\n\t\tif ( ret !== true ) {\n\t\t\tif ( QUnit.config.current ) {\n\t\t\t\tif ( QUnit.config.current.ignoreGlobalErrors ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tQUnit.pushFailure( error, filePath + \":\" + linerNr );\n\t\t\t} else {\n\t\t\t\tQUnit.test( \"global failure\", extend(function() {\n\t\t\t\t\tQUnit.pushFailure( error, filePath + \":\" + linerNr );\n\t\t\t\t}, { validTest: true } ) );\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\treturn ret;\n\t};\n} )();\n\nQUnit.urlParams = urlParams;\n\n// Figure out if we're running the tests from a server or not\nQUnit.isLocal = !( defined.document && window.location.protocol !== \"file:\" );\n\n// Expose the current QUnit version\nQUnit.version = \"1.19.0\";\n\nextend( QUnit, {\n\n\t// call on start of module test to prepend name to all tests\n\tmodule: function( name, testEnvironment ) {\n\t\tvar currentModule = {\n\t\t\tname: name,\n\t\t\ttestEnvironment: testEnvironment,\n\t\t\ttests: []\n\t\t};\n\n\t\t// DEPRECATED: handles setup/teardown functions,\n\t\t// beforeEach and afterEach should be used instead\n\t\tif ( testEnvironment && testEnvironment.setup ) {\n\t\t\ttestEnvironment.beforeEach = testEnvironment.setup;\n\t\t\tdelete testEnvironment.setup;\n\t\t}\n\t\tif ( testEnvironment && testEnvironment.teardown ) {\n\t\t\ttestEnvironment.afterEach = testEnvironment.teardown;\n\t\t\tdelete testEnvironment.teardown;\n\t\t}\n\n\t\tconfig.modules.push( currentModule );\n\t\tconfig.currentModule = currentModule;\n\t},\n\n\t// DEPRECATED: QUnit.asyncTest() will be removed in QUnit 2.0.\n\tasyncTest: asyncTest,\n\n\ttest: test,\n\n\tskip: skip,\n\n\t// DEPRECATED: The functionality of QUnit.start() will be altered in QUnit 2.0.\n\t// In QUnit 2.0, invoking it will ONLY affect the `QUnit.config.autostart` blocking behavior.\n\tstart: function( count ) {\n\t\tvar globalStartAlreadyCalled = globalStartCalled;\n\n\t\tif ( !config.current ) {\n\t\t\tglobalStartCalled = true;\n\n\t\t\tif ( runStarted ) {\n\t\t\t\tthrow new Error( \"Called start() outside of a test context while already started\" );\n\t\t\t} else if ( globalStartAlreadyCalled || count > 1 ) {\n\t\t\t\tthrow new Error( \"Called start() outside of a test context too many times\" );\n\t\t\t} else if ( config.autostart ) {\n\t\t\t\tthrow new Error( \"Called start() outside of a test context when \" +\n\t\t\t\t\t\"QUnit.config.autostart was true\" );\n\t\t\t} else if ( !config.pageLoaded ) {\n\n\t\t\t\t// The page isn't completely loaded yet, so bail out and let `QUnit.load` handle it\n\t\t\t\tconfig.autostart = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\n\t\t\t// If a test is running, adjust its semaphore\n\t\t\tconfig.current.semaphore -= count || 1;\n\n\t\t\t// Don't start until equal number of stop-calls\n\t\t\tif ( config.current.semaphore > 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// throw an Error if start is called more often than stop\n\t\t\tif ( config.current.semaphore < 0 ) {\n\t\t\t\tconfig.current.semaphore = 0;\n\n\t\t\t\tQUnit.pushFailure(\n\t\t\t\t\t\"Called start() while already started (test's semaphore was 0 already)\",\n\t\t\t\t\tsourceFromStacktrace( 2 )\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tresumeProcessing();\n\t},\n\n\t// DEPRECATED: QUnit.stop() will be removed in QUnit 2.0.\n\tstop: function( count ) {\n\n\t\t// If there isn't a test running, don't allow QUnit.stop() to be called\n\t\tif ( !config.current ) {\n\t\t\tthrow new Error( \"Called stop() outside of a test context\" );\n\t\t}\n\n\t\t// If a test is running, adjust its semaphore\n\t\tconfig.current.semaphore += count || 1;\n\n\t\tpauseProcessing();\n\t},\n\n\tconfig: config,\n\n\tis: is,\n\n\tobjectType: objectType,\n\n\textend: extend,\n\n\tload: function() {\n\t\tconfig.pageLoaded = true;\n\n\t\t// Initialize the configuration options\n\t\textend( config, {\n\t\t\tstats: { all: 0, bad: 0 },\n\t\t\tmoduleStats: { all: 0, bad: 0 },\n\t\t\tstarted: 0,\n\t\t\tupdateRate: 1000,\n\t\t\tautostart: true,\n\t\t\tfilter: \"\"\n\t\t}, true );\n\n\t\tconfig.blocking = false;\n\n\t\tif ( config.autostart ) {\n\t\t\tresumeProcessing();\n\t\t}\n\t},\n\n\tstack: function( offset ) {\n\t\toffset = ( offset || 0 ) + 2;\n\t\treturn sourceFromStacktrace( offset );\n\t}\n});\n\nregisterLoggingCallbacks( QUnit );\n\nfunction begin() {\n\tvar i, l,\n\t\tmodulesLog = [];\n\n\t// If the test run hasn't officially begun yet\n\tif ( !config.started ) {\n\n\t\t// Record the time of the test run's beginning\n\t\tconfig.started = now();\n\n\t\tverifyLoggingCallbacks();\n\n\t\t// Delete the loose unnamed module if unused.\n\t\tif ( config.modules[ 0 ].name === \"\" && config.modules[ 0 ].tests.length === 0 ) {\n\t\t\tconfig.modules.shift();\n\t\t}\n\n\t\t// Avoid unnecessary information by not logging modules' test environments\n\t\tfor ( i = 0, l = config.modules.length; i < l; i++ ) {\n\t\t\tmodulesLog.push({\n\t\t\t\tname: config.modules[ i ].name,\n\t\t\t\ttests: config.modules[ i ].tests\n\t\t\t});\n\t\t}\n\n\t\t// The test run is officially beginning now\n\t\trunLoggingCallbacks( \"begin\", {\n\t\t\ttotalTests: Test.count,\n\t\t\tmodules: modulesLog\n\t\t});\n\t}\n\n\tconfig.blocking = false;\n\tprocess( true );\n}\n\nfunction process( last ) {\n\tfunction next() {\n\t\tprocess( last );\n\t}\n\tvar start = now();\n\tconfig.depth = ( config.depth || 0 ) + 1;\n\n\twhile ( config.queue.length && !config.blocking ) {\n\t\tif ( !defined.setTimeout || config.updateRate <= 0 ||\n\t\t\t\t( ( now() - start ) < config.updateRate ) ) {\n\t\t\tif ( config.current ) {\n\n\t\t\t\t// Reset async tracking for each phase of the Test lifecycle\n\t\t\t\tconfig.current.usedAsync = false;\n\t\t\t}\n\t\t\tconfig.queue.shift()();\n\t\t} else {\n\t\t\tsetTimeout( next, 13 );\n\t\t\tbreak;\n\t\t}\n\t}\n\tconfig.depth--;\n\tif ( last && !config.blocking && !config.queue.length && config.depth === 0 ) {\n\t\tdone();\n\t}\n}\n\nfunction pauseProcessing() {\n\tconfig.blocking = true;\n\n\tif ( config.testTimeout && defined.setTimeout ) {\n\t\tclearTimeout( config.timeout );\n\t\tconfig.timeout = setTimeout(function() {\n\t\t\tif ( config.current ) {\n\t\t\t\tconfig.current.semaphore = 0;\n\t\t\t\tQUnit.pushFailure( \"Test timed out\", sourceFromStacktrace( 2 ) );\n\t\t\t} else {\n\t\t\t\tthrow new Error( \"Test timed out\" );\n\t\t\t}\n\t\t\tresumeProcessing();\n\t\t}, config.testTimeout );\n\t}\n}\n\nfunction resumeProcessing() {\n\trunStarted = true;\n\n\t// A slight delay to allow this iteration of the event loop to finish (more assertions, etc.)\n\tif ( defined.setTimeout ) {\n\t\tsetTimeout(function() {\n\t\t\tif ( config.current && config.current.semaphore > 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( config.timeout ) {\n\t\t\t\tclearTimeout( config.timeout );\n\t\t\t}\n\n\t\t\tbegin();\n\t\t}, 13 );\n\t} else {\n\t\tbegin();\n\t}\n}\n\nfunction done() {\n\tvar runtime, passed;\n\n\tconfig.autorun = true;\n\n\t// Log the last module results\n\tif ( config.previousModule ) {\n\t\trunLoggingCallbacks( \"moduleDone\", {\n\t\t\tname: config.previousModule.name,\n\t\t\ttests: config.previousModule.tests,\n\t\t\tfailed: config.moduleStats.bad,\n\t\t\tpassed: config.moduleStats.all - config.moduleStats.bad,\n\t\t\ttotal: config.moduleStats.all,\n\t\t\truntime: now() - config.moduleStats.started\n\t\t});\n\t}\n\tdelete config.previousModule;\n\n\truntime = now() - config.started;\n\tpassed = config.stats.all - config.stats.bad;\n\n\trunLoggingCallbacks( \"done\", {\n\t\tfailed: config.stats.bad,\n\t\tpassed: passed,\n\t\ttotal: config.stats.all,\n\t\truntime: runtime\n\t});\n}\n\nfunction Test( settings ) {\n\tvar i, l;\n\n\t++Test.count;\n\n\textend( this, settings );\n\tthis.assertions = [];\n\tthis.semaphore = 0;\n\tthis.usedAsync = false;\n\tthis.module = config.currentModule;\n\tthis.stack = sourceFromStacktrace( 3 );\n\n\t// Register unique strings\n\tfor ( i = 0, l = this.module.tests; i < l.length; i++ ) {\n\t\tif ( this.module.tests[ i ].name === this.testName ) {\n\t\t\tthis.testName += \" \";\n\t\t}\n\t}\n\n\tthis.testId = generateHash( this.module.name, this.testName );\n\n\tthis.module.tests.push({\n\t\tname: this.testName,\n\t\ttestId: this.testId\n\t});\n\n\tif ( settings.skip ) {\n\n\t\t// Skipped tests will fully ignore any sent callback\n\t\tthis.callback = function() {};\n\t\tthis.async = false;\n\t\tthis.expected = 0;\n\t} else {\n\t\tthis.assert = new Assert( this );\n\t}\n}\n\nTest.count = 0;\n\nTest.prototype = {\n\tbefore: function() {\n\t\tif (\n\n\t\t\t// Emit moduleStart when we're switching from one module to another\n\t\t\tthis.module !== config.previousModule ||\n\n\t\t\t\t// They could be equal (both undefined) but if the previousModule property doesn't\n\t\t\t\t// yet exist it means this is the first test in a suite that isn't wrapped in a\n\t\t\t\t// module, in which case we'll just emit a moduleStart event for 'undefined'.\n\t\t\t\t// Without this, reporters can get testStart before moduleStart  which is a problem.\n\t\t\t\t!hasOwn.call( config, \"previousModule\" )\n\t\t) {\n\t\t\tif ( hasOwn.call( config, \"previousModule\" ) ) {\n\t\t\t\trunLoggingCallbacks( \"moduleDone\", {\n\t\t\t\t\tname: config.previousModule.name,\n\t\t\t\t\ttests: config.previousModule.tests,\n\t\t\t\t\tfailed: config.moduleStats.bad,\n\t\t\t\t\tpassed: config.moduleStats.all - config.moduleStats.bad,\n\t\t\t\t\ttotal: config.moduleStats.all,\n\t\t\t\t\truntime: now() - config.moduleStats.started\n\t\t\t\t});\n\t\t\t}\n\t\t\tconfig.previousModule = this.module;\n\t\t\tconfig.moduleStats = { all: 0, bad: 0, started: now() };\n\t\t\trunLoggingCallbacks( \"moduleStart\", {\n\t\t\t\tname: this.module.name,\n\t\t\t\ttests: this.module.tests\n\t\t\t});\n\t\t}\n\n\t\tconfig.current = this;\n\n\t\tif ( this.module.testEnvironment ) {\n\t\t\tdelete this.module.testEnvironment.beforeEach;\n\t\t\tdelete this.module.testEnvironment.afterEach;\n\t\t}\n\t\tthis.testEnvironment = extend( {}, this.module.testEnvironment );\n\n\t\tthis.started = now();\n\t\trunLoggingCallbacks( \"testStart\", {\n\t\t\tname: this.testName,\n\t\t\tmodule: this.module.name,\n\t\t\ttestId: this.testId\n\t\t});\n\n\t\tif ( !config.pollution ) {\n\t\t\tsaveGlobal();\n\t\t}\n\t},\n\n\trun: function() {\n\t\tvar promise;\n\n\t\tconfig.current = this;\n\n\t\tif ( this.async ) {\n\t\t\tQUnit.stop();\n\t\t}\n\n\t\tthis.callbackStarted = now();\n\n\t\tif ( config.notrycatch ) {\n\t\t\tpromise = this.callback.call( this.testEnvironment, this.assert );\n\t\t\tthis.resolvePromise( promise );\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tpromise = this.callback.call( this.testEnvironment, this.assert );\n\t\t\tthis.resolvePromise( promise );\n\t\t} catch ( e ) {\n\t\t\tthis.pushFailure( \"Died on test #\" + ( this.assertions.length + 1 ) + \" \" +\n\t\t\t\tthis.stack + \": \" + ( e.message || e ), extractStacktrace( e, 0 ) );\n\n\t\t\t// else next test will carry the responsibility\n\t\t\tsaveGlobal();\n\n\t\t\t// Restart the tests if they're blocking\n\t\t\tif ( config.blocking ) {\n\t\t\t\tQUnit.start();\n\t\t\t}\n\t\t}\n\t},\n\n\tafter: function() {\n\t\tcheckPollution();\n\t},\n\n\tqueueHook: function( hook, hookName ) {\n\t\tvar promise,\n\t\t\ttest = this;\n\t\treturn function runHook() {\n\t\t\tconfig.current = test;\n\t\t\tif ( config.notrycatch ) {\n\t\t\t\tpromise = hook.call( test.testEnvironment, test.assert );\n\t\t\t\ttest.resolvePromise( promise, hookName );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tpromise = hook.call( test.testEnvironment, test.assert );\n\t\t\t\ttest.resolvePromise( promise, hookName );\n\t\t\t} catch ( error ) {\n\t\t\t\ttest.pushFailure( hookName + \" failed on \" + test.testName + \": \" +\n\t\t\t\t\t( error.message || error ), extractStacktrace( error, 0 ) );\n\t\t\t}\n\t\t};\n\t},\n\n\t// Currently only used for module level hooks, can be used to add global level ones\n\thooks: function( handler ) {\n\t\tvar hooks = [];\n\n\t\t// Hooks are ignored on skipped tests\n\t\tif ( this.skip ) {\n\t\t\treturn hooks;\n\t\t}\n\n\t\tif ( this.module.testEnvironment &&\n\t\t\t\tQUnit.objectType( this.module.testEnvironment[ handler ] ) === \"function\" ) {\n\t\t\thooks.push( this.queueHook( this.module.testEnvironment[ handler ], handler ) );\n\t\t}\n\n\t\treturn hooks;\n\t},\n\n\tfinish: function() {\n\t\tconfig.current = this;\n\t\tif ( config.requireExpects && this.expected === null ) {\n\t\t\tthis.pushFailure( \"Expected number of assertions to be defined, but expect() was \" +\n\t\t\t\t\"not called.\", this.stack );\n\t\t} else if ( this.expected !== null && this.expected !== this.assertions.length ) {\n\t\t\tthis.pushFailure( \"Expected \" + this.expected + \" assertions, but \" +\n\t\t\t\tthis.assertions.length + \" were run\", this.stack );\n\t\t} else if ( this.expected === null && !this.assertions.length ) {\n\t\t\tthis.pushFailure( \"Expected at least one assertion, but none were run - call \" +\n\t\t\t\t\"expect(0) to accept zero assertions.\", this.stack );\n\t\t}\n\n\t\tvar i,\n\t\t\tbad = 0;\n\n\t\tthis.runtime = now() - this.started;\n\t\tconfig.stats.all += this.assertions.length;\n\t\tconfig.moduleStats.all += this.assertions.length;\n\n\t\tfor ( i = 0; i < this.assertions.length; i++ ) {\n\t\t\tif ( !this.assertions[ i ].result ) {\n\t\t\t\tbad++;\n\t\t\t\tconfig.stats.bad++;\n\t\t\t\tconfig.moduleStats.bad++;\n\t\t\t}\n\t\t}\n\n\t\trunLoggingCallbacks( \"testDone\", {\n\t\t\tname: this.testName,\n\t\t\tmodule: this.module.name,\n\t\t\tskipped: !!this.skip,\n\t\t\tfailed: bad,\n\t\t\tpassed: this.assertions.length - bad,\n\t\t\ttotal: this.assertions.length,\n\t\t\truntime: this.runtime,\n\n\t\t\t// HTML Reporter use\n\t\t\tassertions: this.assertions,\n\t\t\ttestId: this.testId,\n\n\t\t\t// Source of Test\n\t\t\tsource: this.stack,\n\n\t\t\t// DEPRECATED: this property will be removed in 2.0.0, use runtime instead\n\t\t\tduration: this.runtime\n\t\t});\n\n\t\t// QUnit.reset() is deprecated and will be replaced for a new\n\t\t// fixture reset function on QUnit 2.0/2.1.\n\t\t// It's still called here for backwards compatibility handling\n\t\tQUnit.reset();\n\n\t\tconfig.current = undefined;\n\t},\n\n\tqueue: function() {\n\t\tvar bad,\n\t\t\ttest = this;\n\n\t\tif ( !this.valid() ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfunction run() {\n\n\t\t\t// each of these can by async\n\t\t\tsynchronize([\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.before();\n\t\t\t\t},\n\n\t\t\t\ttest.hooks( \"beforeEach\" ),\n\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.run();\n\t\t\t\t},\n\n\t\t\t\ttest.hooks( \"afterEach\" ).reverse(),\n\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.after();\n\t\t\t\t},\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.finish();\n\t\t\t\t}\n\t\t\t]);\n\t\t}\n\n\t\t// `bad` initialized at top of scope\n\t\t// defer when previous test run passed, if storage is available\n\t\tbad = QUnit.config.reorder && defined.sessionStorage &&\n\t\t\t\t+sessionStorage.getItem( \"qunit-test-\" + this.module.name + \"-\" + this.testName );\n\n\t\tif ( bad ) {\n\t\t\trun();\n\t\t} else {\n\t\t\tsynchronize( run, true );\n\t\t}\n\t},\n\n\tpush: function( result, actual, expected, message, negative ) {\n\t\tvar source,\n\t\t\tdetails = {\n\t\t\t\tmodule: this.module.name,\n\t\t\t\tname: this.testName,\n\t\t\t\tresult: result,\n\t\t\t\tmessage: message,\n\t\t\t\tactual: actual,\n\t\t\t\texpected: expected,\n\t\t\t\ttestId: this.testId,\n\t\t\t\tnegative: negative || false,\n\t\t\t\truntime: now() - this.started\n\t\t\t};\n\n\t\tif ( !result ) {\n\t\t\tsource = sourceFromStacktrace();\n\n\t\t\tif ( source ) {\n\t\t\t\tdetails.source = source;\n\t\t\t}\n\t\t}\n\n\t\trunLoggingCallbacks( \"log\", details );\n\n\t\tthis.assertions.push({\n\t\t\tresult: !!result,\n\t\t\tmessage: message\n\t\t});\n\t},\n\n\tpushFailure: function( message, source, actual ) {\n\t\tif ( !( this instanceof Test ) ) {\n\t\t\tthrow new Error( \"pushFailure() assertion outside test context, was \" +\n\t\t\t\tsourceFromStacktrace( 2 ) );\n\t\t}\n\n\t\tvar details = {\n\t\t\t\tmodule: this.module.name,\n\t\t\t\tname: this.testName,\n\t\t\t\tresult: false,\n\t\t\t\tmessage: message || \"error\",\n\t\t\t\tactual: actual || null,\n\t\t\t\ttestId: this.testId,\n\t\t\t\truntime: now() - this.started\n\t\t\t};\n\n\t\tif ( source ) {\n\t\t\tdetails.source = source;\n\t\t}\n\n\t\trunLoggingCallbacks( \"log\", details );\n\n\t\tthis.assertions.push({\n\t\t\tresult: false,\n\t\t\tmessage: message\n\t\t});\n\t},\n\n\tresolvePromise: function( promise, phase ) {\n\t\tvar then, message,\n\t\t\ttest = this;\n\t\tif ( promise != null ) {\n\t\t\tthen = promise.then;\n\t\t\tif ( QUnit.objectType( then ) === \"function\" ) {\n\t\t\t\tQUnit.stop();\n\t\t\t\tthen.call(\n\t\t\t\t\tpromise,\n\t\t\t\t\tfunction() { QUnit.start(); },\n\t\t\t\t\tfunction( error ) {\n\t\t\t\t\t\tmessage = \"Promise rejected \" +\n\t\t\t\t\t\t\t( !phase ? \"during\" : phase.replace( /Each$/, \"\" ) ) +\n\t\t\t\t\t\t\t\" \" + test.testName + \": \" + ( error.message || error );\n\t\t\t\t\t\ttest.pushFailure( message, extractStacktrace( error, 0 ) );\n\n\t\t\t\t\t\t// else next test will carry the responsibility\n\t\t\t\t\t\tsaveGlobal();\n\n\t\t\t\t\t\t// Unblock\n\t\t\t\t\t\tQUnit.start();\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t},\n\n\tvalid: function() {\n\t\tvar include,\n\t\t\tfilter = config.filter && config.filter.toLowerCase(),\n\t\t\tmodule = QUnit.urlParams.module && QUnit.urlParams.module.toLowerCase(),\n\t\t\tfullName = ( this.module.name + \": \" + this.testName ).toLowerCase();\n\n\t\t// Internally-generated tests are always valid\n\t\tif ( this.callback && this.callback.validTest ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( config.testId.length > 0 && inArray( this.testId, config.testId ) < 0 ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( module && ( !this.module.name || this.module.name.toLowerCase() !== module ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( !filter ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tinclude = filter.charAt( 0 ) !== \"!\";\n\t\tif ( !include ) {\n\t\t\tfilter = filter.slice( 1 );\n\t\t}\n\n\t\t// If the filter matches, we need to honour include\n\t\tif ( fullName.indexOf( filter ) !== -1 ) {\n\t\t\treturn include;\n\t\t}\n\n\t\t// Otherwise, do the opposite\n\t\treturn !include;\n\t}\n\n};\n\n// Resets the test setup. Useful for tests that modify the DOM.\n/*\nDEPRECATED: Use multiple tests instead of resetting inside a test.\nUse testStart or testDone for custom cleanup.\nThis method will throw an error in 2.0, and will be removed in 2.1\n*/\nQUnit.reset = function() {\n\n\t// Return on non-browser environments\n\t// This is necessary to not break on node tests\n\tif ( !defined.document ) {\n\t\treturn;\n\t}\n\n\tvar fixture = defined.document && document.getElementById &&\n\t\t\tdocument.getElementById( \"qunit-fixture\" );\n\n\tif ( fixture ) {\n\t\tfixture.innerHTML = config.fixture;\n\t}\n};\n\nQUnit.pushFailure = function() {\n\tif ( !QUnit.config.current ) {\n\t\tthrow new Error( \"pushFailure() assertion outside test context, in \" +\n\t\t\tsourceFromStacktrace( 2 ) );\n\t}\n\n\t// Gets current test obj\n\tvar currentTest = QUnit.config.current;\n\n\treturn currentTest.pushFailure.apply( currentTest, arguments );\n};\n\n// Based on Java's String.hashCode, a simple but not\n// rigorously collision resistant hashing function\nfunction generateHash( module, testName ) {\n\tvar hex,\n\t\ti = 0,\n\t\thash = 0,\n\t\tstr = module + \"\\x1C\" + testName,\n\t\tlen = str.length;\n\n\tfor ( ; i < len; i++ ) {\n\t\thash  = ( ( hash << 5 ) - hash ) + str.charCodeAt( i );\n\t\thash |= 0;\n\t}\n\n\t// Convert the possibly negative integer hash code into an 8 character hex string, which isn't\n\t// strictly necessary but increases user understanding that the id is a SHA-like hash\n\thex = ( 0x100000000 + hash ).toString( 16 );\n\tif ( hex.length < 8 ) {\n\t\thex = \"0000000\" + hex;\n\t}\n\n\treturn hex.slice( -8 );\n}\n\nfunction synchronize( callback, last ) {\n\tif ( QUnit.objectType( callback ) === \"array\" ) {\n\t\twhile ( callback.length ) {\n\t\t\tsynchronize( callback.shift() );\n\t\t}\n\t\treturn;\n\t}\n\tconfig.queue.push( callback );\n\n\tif ( config.autorun && !config.blocking ) {\n\t\tprocess( last );\n\t}\n}\n\nfunction saveGlobal() {\n\tconfig.pollution = [];\n\n\tif ( config.noglobals ) {\n\t\tfor ( var key in global ) {\n\t\t\tif ( hasOwn.call( global, key ) ) {\n\n\t\t\t\t// in Opera sometimes DOM element ids show up here, ignore them\n\t\t\t\tif ( /^qunit-test-output/.test( key ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconfig.pollution.push( key );\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction checkPollution() {\n\tvar newGlobals,\n\t\tdeletedGlobals,\n\t\told = config.pollution;\n\n\tsaveGlobal();\n\n\tnewGlobals = diff( config.pollution, old );\n\tif ( newGlobals.length > 0 ) {\n\t\tQUnit.pushFailure( \"Introduced global variable(s): \" + newGlobals.join( \", \" ) );\n\t}\n\n\tdeletedGlobals = diff( old, config.pollution );\n\tif ( deletedGlobals.length > 0 ) {\n\t\tQUnit.pushFailure( \"Deleted global variable(s): \" + deletedGlobals.join( \", \" ) );\n\t}\n}\n\n// Will be exposed as QUnit.asyncTest\nfunction asyncTest( testName, expected, callback ) {\n\tif ( arguments.length === 2 ) {\n\t\tcallback = expected;\n\t\texpected = null;\n\t}\n\n\tQUnit.test( testName, expected, callback, true );\n}\n\n// Will be exposed as QUnit.test\nfunction test( testName, expected, callback, async ) {\n\tvar newTest;\n\n\tif ( arguments.length === 2 ) {\n\t\tcallback = expected;\n\t\texpected = null;\n\t}\n\n\tnewTest = new Test({\n\t\ttestName: testName,\n\t\texpected: expected,\n\t\tasync: async,\n\t\tcallback: callback\n\t});\n\n\tnewTest.queue();\n}\n\n// Will be exposed as QUnit.skip\nfunction skip( testName ) {\n\tvar test = new Test({\n\t\ttestName: testName,\n\t\tskip: true\n\t});\n\n\ttest.queue();\n}\n\nfunction Assert( testContext ) {\n\tthis.test = testContext;\n}\n\n// Assert helpers\nQUnit.assert = Assert.prototype = {\n\n\t// Specify the number of expected assertions to guarantee that failed test\n\t// (no assertions are run at all) don't slip through.\n\texpect: function( asserts ) {\n\t\tif ( arguments.length === 1 ) {\n\t\t\tthis.test.expected = asserts;\n\t\t} else {\n\t\t\treturn this.test.expected;\n\t\t}\n\t},\n\n\t// Increment this Test's semaphore counter, then return a single-use function that\n\t// decrements that counter a maximum of once.\n\tasync: function() {\n\t\tvar test = this.test,\n\t\t\tpopped = false;\n\n\t\ttest.semaphore += 1;\n\t\ttest.usedAsync = true;\n\t\tpauseProcessing();\n\n\t\treturn function done() {\n\t\t\tif ( !popped ) {\n\t\t\t\ttest.semaphore -= 1;\n\t\t\t\tpopped = true;\n\t\t\t\tresumeProcessing();\n\t\t\t} else {\n\t\t\t\ttest.pushFailure( \"Called the callback returned from `assert.async` more than once\",\n\t\t\t\t\tsourceFromStacktrace( 2 ) );\n\t\t\t}\n\t\t};\n\t},\n\n\t// Exports test.push() to the user API\n\tpush: function( /* result, actual, expected, message, negative */ ) {\n\t\tvar assert = this,\n\t\t\tcurrentTest = ( assert instanceof Assert && assert.test ) || QUnit.config.current;\n\n\t\t// Backwards compatibility fix.\n\t\t// Allows the direct use of global exported assertions and QUnit.assert.*\n\t\t// Although, it's use is not recommended as it can leak assertions\n\t\t// to other tests from async tests, because we only get a reference to the current test,\n\t\t// not exactly the test where assertion were intended to be called.\n\t\tif ( !currentTest ) {\n\t\t\tthrow new Error( \"assertion outside test context, in \" + sourceFromStacktrace( 2 ) );\n\t\t}\n\n\t\tif ( currentTest.usedAsync === true && currentTest.semaphore === 0 ) {\n\t\t\tcurrentTest.pushFailure( \"Assertion after the final `assert.async` was resolved\",\n\t\t\t\tsourceFromStacktrace( 2 ) );\n\n\t\t\t// Allow this assertion to continue running anyway...\n\t\t}\n\n\t\tif ( !( assert instanceof Assert ) ) {\n\t\t\tassert = currentTest.assert;\n\t\t}\n\t\treturn assert.test.push.apply( assert.test, arguments );\n\t},\n\n\tok: function( result, message ) {\n\t\tmessage = message || ( result ? \"okay\" : \"failed, expected argument to be truthy, was: \" +\n\t\t\tQUnit.dump.parse( result ) );\n\t\tthis.push( !!result, result, true, message );\n\t},\n\n\tnotOk: function( result, message ) {\n\t\tmessage = message || ( !result ? \"okay\" : \"failed, expected argument to be falsy, was: \" +\n\t\t\tQUnit.dump.parse( result ) );\n\t\tthis.push( !result, result, false, message, true );\n\t},\n\n\tequal: function( actual, expected, message ) {\n\t\t/*jshint eqeqeq:false */\n\t\tthis.push( expected == actual, actual, expected, message );\n\t},\n\n\tnotEqual: function( actual, expected, message ) {\n\t\t/*jshint eqeqeq:false */\n\t\tthis.push( expected != actual, actual, expected, message, true );\n\t},\n\n\tpropEqual: function( actual, expected, message ) {\n\t\tactual = objectValues( actual );\n\t\texpected = objectValues( expected );\n\t\tthis.push( QUnit.equiv( actual, expected ), actual, expected, message );\n\t},\n\n\tnotPropEqual: function( actual, expected, message ) {\n\t\tactual = objectValues( actual );\n\t\texpected = objectValues( expected );\n\t\tthis.push( !QUnit.equiv( actual, expected ), actual, expected, message, true );\n\t},\n\n\tdeepEqual: function( actual, expected, message ) {\n\t\tthis.push( QUnit.equiv( actual, expected ), actual, expected, message );\n\t},\n\n\tnotDeepEqual: function( actual, expected, message ) {\n\t\tthis.push( !QUnit.equiv( actual, expected ), actual, expected, message, true );\n\t},\n\n\tstrictEqual: function( actual, expected, message ) {\n\t\tthis.push( expected === actual, actual, expected, message );\n\t},\n\n\tnotStrictEqual: function( actual, expected, message ) {\n\t\tthis.push( expected !== actual, actual, expected, message, true );\n\t},\n\n\t\"throws\": function( block, expected, message ) {\n\t\tvar actual, expectedType,\n\t\t\texpectedOutput = expected,\n\t\t\tok = false,\n\t\t\tcurrentTest = ( this instanceof Assert && this.test ) || QUnit.config.current;\n\n\t\t// 'expected' is optional unless doing string comparison\n\t\tif ( message == null && typeof expected === \"string\" ) {\n\t\t\tmessage = expected;\n\t\t\texpected = null;\n\t\t}\n\n\t\tcurrentTest.ignoreGlobalErrors = true;\n\t\ttry {\n\t\t\tblock.call( currentTest.testEnvironment );\n\t\t} catch (e) {\n\t\t\tactual = e;\n\t\t}\n\t\tcurrentTest.ignoreGlobalErrors = false;\n\n\t\tif ( actual ) {\n\t\t\texpectedType = QUnit.objectType( expected );\n\n\t\t\t// we don't want to validate thrown error\n\t\t\tif ( !expected ) {\n\t\t\t\tok = true;\n\t\t\t\texpectedOutput = null;\n\n\t\t\t// expected is a regexp\n\t\t\t} else if ( expectedType === \"regexp\" ) {\n\t\t\t\tok = expected.test( errorString( actual ) );\n\n\t\t\t// expected is a string\n\t\t\t} else if ( expectedType === \"string\" ) {\n\t\t\t\tok = expected === errorString( actual );\n\n\t\t\t// expected is a constructor, maybe an Error constructor\n\t\t\t} else if ( expectedType === \"function\" && actual instanceof expected ) {\n\t\t\t\tok = true;\n\n\t\t\t// expected is an Error object\n\t\t\t} else if ( expectedType === \"object\" ) {\n\t\t\t\tok = actual instanceof expected.constructor &&\n\t\t\t\t\tactual.name === expected.name &&\n\t\t\t\t\tactual.message === expected.message;\n\n\t\t\t// expected is a validation function which returns true if validation passed\n\t\t\t} else if ( expectedType === \"function\" && expected.call( {}, actual ) === true ) {\n\t\t\t\texpectedOutput = null;\n\t\t\t\tok = true;\n\t\t\t}\n\t\t}\n\n\t\tcurrentTest.assert.push( ok, actual, expectedOutput, message );\n\t}\n};\n\n// Provide an alternative to assert.throws(), for enviroments that consider throws a reserved word\n// Known to us are: Closure Compiler, Narwhal\n(function() {\n\t/*jshint sub:true */\n\tAssert.prototype.raises = Assert.prototype[ \"throws\" ];\n}());\n\nfunction errorString( error ) {\n\tvar name, message,\n\t\tresultErrorString = error.toString();\n\tif ( resultErrorString.substring( 0, 7 ) === \"[object\" ) {\n\t\tname = error.name ? error.name.toString() : \"Error\";\n\t\tmessage = error.message ? error.message.toString() : \"\";\n\t\tif ( name && message ) {\n\t\t\treturn name + \": \" + message;\n\t\t} else if ( name ) {\n\t\t\treturn name;\n\t\t} else if ( message ) {\n\t\t\treturn message;\n\t\t} else {\n\t\t\treturn \"Error\";\n\t\t}\n\t} else {\n\t\treturn resultErrorString;\n\t}\n}\n\n// Test for equality any JavaScript type.\n// Author: Philippe Rathé <prathe@gmail.com>\nQUnit.equiv = (function() {\n\n\t// Call the o related callback with the given arguments.\n\tfunction bindCallbacks( o, callbacks, args ) {\n\t\tvar prop = QUnit.objectType( o );\n\t\tif ( prop ) {\n\t\t\tif ( QUnit.objectType( callbacks[ prop ] ) === \"function\" ) {\n\t\t\t\treturn callbacks[ prop ].apply( callbacks, args );\n\t\t\t} else {\n\t\t\t\treturn callbacks[ prop ]; // or undefined\n\t\t\t}\n\t\t}\n\t}\n\n\t// the real equiv function\n\tvar innerEquiv,\n\n\t\t// stack to decide between skip/abort functions\n\t\tcallers = [],\n\n\t\t// stack to avoiding loops from circular referencing\n\t\tparents = [],\n\t\tparentsB = [],\n\n\t\tgetProto = Object.getPrototypeOf || function( obj ) {\n\t\t\t/* jshint camelcase: false, proto: true */\n\t\t\treturn obj.__proto__;\n\t\t},\n\t\tcallbacks = (function() {\n\n\t\t\t// for string, boolean, number and null\n\t\t\tfunction useStrictEquality( b, a ) {\n\n\t\t\t\t/*jshint eqeqeq:false */\n\t\t\t\tif ( b instanceof a.constructor || a instanceof b.constructor ) {\n\n\t\t\t\t\t// to catch short annotation VS 'new' annotation of a\n\t\t\t\t\t// declaration\n\t\t\t\t\t// e.g. var i = 1;\n\t\t\t\t\t// var j = new Number(1);\n\t\t\t\t\treturn a == b;\n\t\t\t\t} else {\n\t\t\t\t\treturn a === b;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\t\"string\": useStrictEquality,\n\t\t\t\t\"boolean\": useStrictEquality,\n\t\t\t\t\"number\": useStrictEquality,\n\t\t\t\t\"null\": useStrictEquality,\n\t\t\t\t\"undefined\": useStrictEquality,\n\n\t\t\t\t\"nan\": function( b ) {\n\t\t\t\t\treturn isNaN( b );\n\t\t\t\t},\n\n\t\t\t\t\"date\": function( b, a ) {\n\t\t\t\t\treturn QUnit.objectType( b ) === \"date\" && a.valueOf() === b.valueOf();\n\t\t\t\t},\n\n\t\t\t\t\"regexp\": function( b, a ) {\n\t\t\t\t\treturn QUnit.objectType( b ) === \"regexp\" &&\n\n\t\t\t\t\t\t// the regex itself\n\t\t\t\t\t\ta.source === b.source &&\n\n\t\t\t\t\t\t// and its modifiers\n\t\t\t\t\t\ta.global === b.global &&\n\n\t\t\t\t\t\t// (gmi) ...\n\t\t\t\t\t\ta.ignoreCase === b.ignoreCase &&\n\t\t\t\t\t\ta.multiline === b.multiline &&\n\t\t\t\t\t\ta.sticky === b.sticky;\n\t\t\t\t},\n\n\t\t\t\t// - skip when the property is a method of an instance (OOP)\n\t\t\t\t// - abort otherwise,\n\t\t\t\t// initial === would have catch identical references anyway\n\t\t\t\t\"function\": function() {\n\t\t\t\t\tvar caller = callers[ callers.length - 1 ];\n\t\t\t\t\treturn caller !== Object && typeof caller !== \"undefined\";\n\t\t\t\t},\n\n\t\t\t\t\"array\": function( b, a ) {\n\t\t\t\t\tvar i, j, len, loop, aCircular, bCircular;\n\n\t\t\t\t\t// b could be an object literal here\n\t\t\t\t\tif ( QUnit.objectType( b ) !== \"array\" ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tlen = a.length;\n\t\t\t\t\tif ( len !== b.length ) {\n\t\t\t\t\t\t// safe and faster\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\t// track reference to avoid circular references\n\t\t\t\t\tparents.push( a );\n\t\t\t\t\tparentsB.push( b );\n\t\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\t\tloop = false;\n\t\t\t\t\t\tfor ( j = 0; j < parents.length; j++ ) {\n\t\t\t\t\t\t\taCircular = parents[ j ] === a[ i ];\n\t\t\t\t\t\t\tbCircular = parentsB[ j ] === b[ i ];\n\t\t\t\t\t\t\tif ( aCircular || bCircular ) {\n\t\t\t\t\t\t\t\tif ( a[ i ] === b[ i ] || aCircular && bCircular ) {\n\t\t\t\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tparents.pop();\n\t\t\t\t\t\t\t\t\tparentsB.pop();\n\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( !loop && !innerEquiv( a[ i ], b[ i ] ) ) {\n\t\t\t\t\t\t\tparents.pop();\n\t\t\t\t\t\t\tparentsB.pop();\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tparents.pop();\n\t\t\t\t\tparentsB.pop();\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\n\t\t\t\t\"set\": function( b, a ) {\n\t\t\t\t\tvar aArray, bArray;\n\n\t\t\t\t\t// b could be any object here\n\t\t\t\t\tif ( QUnit.objectType( b ) !== \"set\" ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\taArray = [];\n\t\t\t\t\ta.forEach( function( v ) {\n\t\t\t\t\t\taArray.push( v );\n\t\t\t\t\t});\n\t\t\t\t\tbArray = [];\n\t\t\t\t\tb.forEach( function( v ) {\n\t\t\t\t\t\tbArray.push( v );\n\t\t\t\t\t});\n\n\t\t\t\t\treturn innerEquiv( bArray, aArray );\n\t\t\t\t},\n\n\t\t\t\t\"map\": function( b, a ) {\n\t\t\t\t\tvar aArray, bArray;\n\n\t\t\t\t\t// b could be any object here\n\t\t\t\t\tif ( QUnit.objectType( b ) !== \"map\" ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\taArray = [];\n\t\t\t\t\ta.forEach( function( v, k ) {\n\t\t\t\t\t\taArray.push( [ k, v ] );\n\t\t\t\t\t});\n\t\t\t\t\tbArray = [];\n\t\t\t\t\tb.forEach( function( v, k ) {\n\t\t\t\t\t\tbArray.push( [ k, v ] );\n\t\t\t\t\t});\n\n\t\t\t\t\treturn innerEquiv( bArray, aArray );\n\t\t\t\t},\n\n\t\t\t\t\"object\": function( b, a ) {\n\n\t\t\t\t\t/*jshint forin:false */\n\t\t\t\t\tvar i, j, loop, aCircular, bCircular,\n\t\t\t\t\t\t// Default to true\n\t\t\t\t\t\teq = true,\n\t\t\t\t\t\taProperties = [],\n\t\t\t\t\t\tbProperties = [];\n\n\t\t\t\t\t// comparing constructors is more strict than using\n\t\t\t\t\t// instanceof\n\t\t\t\t\tif ( a.constructor !== b.constructor ) {\n\n\t\t\t\t\t\t// Allow objects with no prototype to be equivalent to\n\t\t\t\t\t\t// objects with Object as their constructor.\n\t\t\t\t\t\tif ( !( ( getProto( a ) === null && getProto( b ) === Object.prototype ) ||\n\t\t\t\t\t\t\t( getProto( b ) === null && getProto( a ) === Object.prototype ) ) ) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// stack constructor before traversing properties\n\t\t\t\t\tcallers.push( a.constructor );\n\n\t\t\t\t\t// track reference to avoid circular references\n\t\t\t\t\tparents.push( a );\n\t\t\t\t\tparentsB.push( b );\n\n\t\t\t\t\t// be strict: don't ensure hasOwnProperty and go deep\n\t\t\t\t\tfor ( i in a ) {\n\t\t\t\t\t\tloop = false;\n\t\t\t\t\t\tfor ( j = 0; j < parents.length; j++ ) {\n\t\t\t\t\t\t\taCircular = parents[ j ] === a[ i ];\n\t\t\t\t\t\t\tbCircular = parentsB[ j ] === b[ i ];\n\t\t\t\t\t\t\tif ( aCircular || bCircular ) {\n\t\t\t\t\t\t\t\tif ( a[ i ] === b[ i ] || aCircular && bCircular ) {\n\t\t\t\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\teq = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\taProperties.push( i );\n\t\t\t\t\t\tif ( !loop && !innerEquiv( a[ i ], b[ i ] ) ) {\n\t\t\t\t\t\t\teq = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tparents.pop();\n\t\t\t\t\tparentsB.pop();\n\t\t\t\t\tcallers.pop(); // unstack, we are done\n\n\t\t\t\t\tfor ( i in b ) {\n\t\t\t\t\t\tbProperties.push( i ); // collect b's properties\n\t\t\t\t\t}\n\n\t\t\t\t\t// Ensures identical properties name\n\t\t\t\t\treturn eq && innerEquiv( aProperties.sort(), bProperties.sort() );\n\t\t\t\t}\n\t\t\t};\n\t\t}());\n\n\tinnerEquiv = function() { // can take multiple arguments\n\t\tvar args = [].slice.apply( arguments );\n\t\tif ( args.length < 2 ) {\n\t\t\treturn true; // end transition\n\t\t}\n\n\t\treturn ( (function( a, b ) {\n\t\t\tif ( a === b ) {\n\t\t\t\treturn true; // catch the most you can\n\t\t\t} else if ( a === null || b === null || typeof a === \"undefined\" ||\n\t\t\t\t\ttypeof b === \"undefined\" ||\n\t\t\t\t\tQUnit.objectType( a ) !== QUnit.objectType( b ) ) {\n\n\t\t\t\t// don't lose time with error prone cases\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\treturn bindCallbacks( a, callbacks, [ b, a ] );\n\t\t\t}\n\n\t\t\t// apply transition with (1..n) arguments\n\t\t}( args[ 0 ], args[ 1 ] ) ) &&\n\t\t\tinnerEquiv.apply( this, args.splice( 1, args.length - 1 ) ) );\n\t};\n\n\treturn innerEquiv;\n}());\n\n// Based on jsDump by Ariel Flesler\n// http://flesler.blogspot.com/2008/05/jsdump-pretty-dump-of-any-javascript.html\nQUnit.dump = (function() {\n\tfunction quote( str ) {\n\t\treturn \"\\\"\" + str.toString().replace( /\\\\/g, \"\\\\\\\\\" ).replace( /\"/g, \"\\\\\\\"\" ) + \"\\\"\";\n\t}\n\tfunction literal( o ) {\n\t\treturn o + \"\";\n\t}\n\tfunction join( pre, arr, post ) {\n\t\tvar s = dump.separator(),\n\t\t\tbase = dump.indent(),\n\t\t\tinner = dump.indent( 1 );\n\t\tif ( arr.join ) {\n\t\t\tarr = arr.join( \",\" + s + inner );\n\t\t}\n\t\tif ( !arr ) {\n\t\t\treturn pre + post;\n\t\t}\n\t\treturn [ pre, inner + arr, base + post ].join( s );\n\t}\n\tfunction array( arr, stack ) {\n\t\tvar i = arr.length,\n\t\t\tret = new Array( i );\n\n\t\tif ( dump.maxDepth && dump.depth > dump.maxDepth ) {\n\t\t\treturn \"[object Array]\";\n\t\t}\n\n\t\tthis.up();\n\t\twhile ( i-- ) {\n\t\t\tret[ i ] = this.parse( arr[ i ], undefined, stack );\n\t\t}\n\t\tthis.down();\n\t\treturn join( \"[\", ret, \"]\" );\n\t}\n\n\tvar reName = /^function (\\w+)/,\n\t\tdump = {\n\n\t\t\t// objType is used mostly internally, you can fix a (custom) type in advance\n\t\t\tparse: function( obj, objType, stack ) {\n\t\t\t\tstack = stack || [];\n\t\t\t\tvar res, parser, parserType,\n\t\t\t\t\tinStack = inArray( obj, stack );\n\n\t\t\t\tif ( inStack !== -1 ) {\n\t\t\t\t\treturn \"recursion(\" + ( inStack - stack.length ) + \")\";\n\t\t\t\t}\n\n\t\t\t\tobjType = objType || this.typeOf( obj  );\n\t\t\t\tparser = this.parsers[ objType ];\n\t\t\t\tparserType = typeof parser;\n\n\t\t\t\tif ( parserType === \"function\" ) {\n\t\t\t\t\tstack.push( obj );\n\t\t\t\t\tres = parser.call( this, obj, stack );\n\t\t\t\t\tstack.pop();\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\treturn ( parserType === \"string\" ) ? parser : this.parsers.error;\n\t\t\t},\n\t\t\ttypeOf: function( obj ) {\n\t\t\t\tvar type;\n\t\t\t\tif ( obj === null ) {\n\t\t\t\t\ttype = \"null\";\n\t\t\t\t} else if ( typeof obj === \"undefined\" ) {\n\t\t\t\t\ttype = \"undefined\";\n\t\t\t\t} else if ( QUnit.is( \"regexp\", obj ) ) {\n\t\t\t\t\ttype = \"regexp\";\n\t\t\t\t} else if ( QUnit.is( \"date\", obj ) ) {\n\t\t\t\t\ttype = \"date\";\n\t\t\t\t} else if ( QUnit.is( \"function\", obj ) ) {\n\t\t\t\t\ttype = \"function\";\n\t\t\t\t} else if ( obj.setInterval !== undefined &&\n\t\t\t\t\t\tobj.document !== undefined &&\n\t\t\t\t\t\tobj.nodeType === undefined ) {\n\t\t\t\t\ttype = \"window\";\n\t\t\t\t} else if ( obj.nodeType === 9 ) {\n\t\t\t\t\ttype = \"document\";\n\t\t\t\t} else if ( obj.nodeType ) {\n\t\t\t\t\ttype = \"node\";\n\t\t\t\t} else if (\n\n\t\t\t\t\t// native arrays\n\t\t\t\t\ttoString.call( obj ) === \"[object Array]\" ||\n\n\t\t\t\t\t// NodeList objects\n\t\t\t\t\t( typeof obj.length === \"number\" && obj.item !== undefined &&\n\t\t\t\t\t( obj.length ? obj.item( 0 ) === obj[ 0 ] : ( obj.item( 0 ) === null &&\n\t\t\t\t\tobj[ 0 ] === undefined ) ) )\n\t\t\t\t) {\n\t\t\t\t\ttype = \"array\";\n\t\t\t\t} else if ( obj.constructor === Error.prototype.constructor ) {\n\t\t\t\t\ttype = \"error\";\n\t\t\t\t} else {\n\t\t\t\t\ttype = typeof obj;\n\t\t\t\t}\n\t\t\t\treturn type;\n\t\t\t},\n\t\t\tseparator: function() {\n\t\t\t\treturn this.multiline ? this.HTML ? \"<br />\" : \"\\n\" : this.HTML ? \"&#160;\" : \" \";\n\t\t\t},\n\t\t\t// extra can be a number, shortcut for increasing-calling-decreasing\n\t\t\tindent: function( extra ) {\n\t\t\t\tif ( !this.multiline ) {\n\t\t\t\t\treturn \"\";\n\t\t\t\t}\n\t\t\t\tvar chr = this.indentChar;\n\t\t\t\tif ( this.HTML ) {\n\t\t\t\t\tchr = chr.replace( /\\t/g, \"   \" ).replace( / /g, \"&#160;\" );\n\t\t\t\t}\n\t\t\t\treturn new Array( this.depth + ( extra || 0 ) ).join( chr );\n\t\t\t},\n\t\t\tup: function( a ) {\n\t\t\t\tthis.depth += a || 1;\n\t\t\t},\n\t\t\tdown: function( a ) {\n\t\t\t\tthis.depth -= a || 1;\n\t\t\t},\n\t\t\tsetParser: function( name, parser ) {\n\t\t\t\tthis.parsers[ name ] = parser;\n\t\t\t},\n\t\t\t// The next 3 are exposed so you can use them\n\t\t\tquote: quote,\n\t\t\tliteral: literal,\n\t\t\tjoin: join,\n\t\t\t//\n\t\t\tdepth: 1,\n\t\t\tmaxDepth: QUnit.config.maxDepth,\n\n\t\t\t// This is the list of parsers, to modify them, use dump.setParser\n\t\t\tparsers: {\n\t\t\t\twindow: \"[Window]\",\n\t\t\t\tdocument: \"[Document]\",\n\t\t\t\terror: function( error ) {\n\t\t\t\t\treturn \"Error(\\\"\" + error.message + \"\\\")\";\n\t\t\t\t},\n\t\t\t\tunknown: \"[Unknown]\",\n\t\t\t\t\"null\": \"null\",\n\t\t\t\t\"undefined\": \"undefined\",\n\t\t\t\t\"function\": function( fn ) {\n\t\t\t\t\tvar ret = \"function\",\n\n\t\t\t\t\t\t// functions never have name in IE\n\t\t\t\t\t\tname = \"name\" in fn ? fn.name : ( reName.exec( fn ) || [] )[ 1 ];\n\n\t\t\t\t\tif ( name ) {\n\t\t\t\t\t\tret += \" \" + name;\n\t\t\t\t\t}\n\t\t\t\t\tret += \"( \";\n\n\t\t\t\t\tret = [ ret, dump.parse( fn, \"functionArgs\" ), \"){\" ].join( \"\" );\n\t\t\t\t\treturn join( ret, dump.parse( fn, \"functionCode\" ), \"}\" );\n\t\t\t\t},\n\t\t\t\tarray: array,\n\t\t\t\tnodelist: array,\n\t\t\t\t\"arguments\": array,\n\t\t\t\tobject: function( map, stack ) {\n\t\t\t\t\tvar keys, key, val, i, nonEnumerableProperties,\n\t\t\t\t\t\tret = [];\n\n\t\t\t\t\tif ( dump.maxDepth && dump.depth > dump.maxDepth ) {\n\t\t\t\t\t\treturn \"[object Object]\";\n\t\t\t\t\t}\n\n\t\t\t\t\tdump.up();\n\t\t\t\t\tkeys = [];\n\t\t\t\t\tfor ( key in map ) {\n\t\t\t\t\t\tkeys.push( key );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Some properties are not always enumerable on Error objects.\n\t\t\t\t\tnonEnumerableProperties = [ \"message\", \"name\" ];\n\t\t\t\t\tfor ( i in nonEnumerableProperties ) {\n\t\t\t\t\t\tkey = nonEnumerableProperties[ i ];\n\t\t\t\t\t\tif ( key in map && inArray( key, keys ) < 0 ) {\n\t\t\t\t\t\t\tkeys.push( key );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tkeys.sort();\n\t\t\t\t\tfor ( i = 0; i < keys.length; i++ ) {\n\t\t\t\t\t\tkey = keys[ i ];\n\t\t\t\t\t\tval = map[ key ];\n\t\t\t\t\t\tret.push( dump.parse( key, \"key\" ) + \": \" +\n\t\t\t\t\t\t\tdump.parse( val, undefined, stack ) );\n\t\t\t\t\t}\n\t\t\t\t\tdump.down();\n\t\t\t\t\treturn join( \"{\", ret, \"}\" );\n\t\t\t\t},\n\t\t\t\tnode: function( node ) {\n\t\t\t\t\tvar len, i, val,\n\t\t\t\t\t\topen = dump.HTML ? \"&lt;\" : \"<\",\n\t\t\t\t\t\tclose = dump.HTML ? \"&gt;\" : \">\",\n\t\t\t\t\t\ttag = node.nodeName.toLowerCase(),\n\t\t\t\t\t\tret = open + tag,\n\t\t\t\t\t\tattrs = node.attributes;\n\n\t\t\t\t\tif ( attrs ) {\n\t\t\t\t\t\tfor ( i = 0, len = attrs.length; i < len; i++ ) {\n\t\t\t\t\t\t\tval = attrs[ i ].nodeValue;\n\n\t\t\t\t\t\t\t// IE6 includes all attributes in .attributes, even ones not explicitly\n\t\t\t\t\t\t\t// set. Those have values like undefined, null, 0, false, \"\" or\n\t\t\t\t\t\t\t// \"inherit\".\n\t\t\t\t\t\t\tif ( val && val !== \"inherit\" ) {\n\t\t\t\t\t\t\t\tret += \" \" + attrs[ i ].nodeName + \"=\" +\n\t\t\t\t\t\t\t\t\tdump.parse( val, \"attribute\" );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tret += close;\n\n\t\t\t\t\t// Show content of TextNode or CDATASection\n\t\t\t\t\tif ( node.nodeType === 3 || node.nodeType === 4 ) {\n\t\t\t\t\t\tret += node.nodeValue;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn ret + open + \"/\" + tag + close;\n\t\t\t\t},\n\n\t\t\t\t// function calls it internally, it's the arguments part of the function\n\t\t\t\tfunctionArgs: function( fn ) {\n\t\t\t\t\tvar args,\n\t\t\t\t\t\tl = fn.length;\n\n\t\t\t\t\tif ( !l ) {\n\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t}\n\n\t\t\t\t\targs = new Array( l );\n\t\t\t\t\twhile ( l-- ) {\n\n\t\t\t\t\t\t// 97 is 'a'\n\t\t\t\t\t\targs[ l ] = String.fromCharCode( 97 + l );\n\t\t\t\t\t}\n\t\t\t\t\treturn \" \" + args.join( \", \" ) + \" \";\n\t\t\t\t},\n\t\t\t\t// object calls it internally, the key part of an item in a map\n\t\t\t\tkey: quote,\n\t\t\t\t// function calls it internally, it's the content of the function\n\t\t\t\tfunctionCode: \"[code]\",\n\t\t\t\t// node calls it internally, it's an html attribute value\n\t\t\t\tattribute: quote,\n\t\t\t\tstring: quote,\n\t\t\t\tdate: quote,\n\t\t\t\tregexp: literal,\n\t\t\t\tnumber: literal,\n\t\t\t\t\"boolean\": literal\n\t\t\t},\n\t\t\t// if true, entities are escaped ( <, >, \\t, space and \\n )\n\t\t\tHTML: false,\n\t\t\t// indentation unit\n\t\t\tindentChar: \"  \",\n\t\t\t// if true, items in a collection, are separated by a \\n, else just a space.\n\t\t\tmultiline: true\n\t\t};\n\n\treturn dump;\n}());\n\n// back compat\nQUnit.jsDump = QUnit.dump;\n\n// For browser, export only select globals\nif ( defined.document ) {\n\n\t// Deprecated\n\t// Extend assert methods to QUnit and Global scope through Backwards compatibility\n\t(function() {\n\t\tvar i,\n\t\t\tassertions = Assert.prototype;\n\n\t\tfunction applyCurrent( current ) {\n\t\t\treturn function() {\n\t\t\t\tvar assert = new Assert( QUnit.config.current );\n\t\t\t\tcurrent.apply( assert, arguments );\n\t\t\t};\n\t\t}\n\n\t\tfor ( i in assertions ) {\n\t\t\tQUnit[ i ] = applyCurrent( assertions[ i ] );\n\t\t}\n\t})();\n\n\t(function() {\n\t\tvar i, l,\n\t\t\tkeys = [\n\t\t\t\t\"test\",\n\t\t\t\t\"module\",\n\t\t\t\t\"expect\",\n\t\t\t\t\"asyncTest\",\n\t\t\t\t\"start\",\n\t\t\t\t\"stop\",\n\t\t\t\t\"ok\",\n\t\t\t\t\"notOk\",\n\t\t\t\t\"equal\",\n\t\t\t\t\"notEqual\",\n\t\t\t\t\"propEqual\",\n\t\t\t\t\"notPropEqual\",\n\t\t\t\t\"deepEqual\",\n\t\t\t\t\"notDeepEqual\",\n\t\t\t\t\"strictEqual\",\n\t\t\t\t\"notStrictEqual\",\n\t\t\t\t\"throws\"\n\t\t\t];\n\n\t\tfor ( i = 0, l = keys.length; i < l; i++ ) {\n\t\t\twindow[ keys[ i ] ] = QUnit[ keys[ i ] ];\n\t\t}\n\t})();\n\n\twindow.QUnit = QUnit;\n}\n\n// For nodejs\nif ( typeof module !== \"undefined\" && module && module.exports ) {\n\tmodule.exports = QUnit;\n\n\t// For consistency with CommonJS environments' exports\n\tmodule.exports.QUnit = QUnit;\n}\n\n// For CommonJS with exports, but without module.exports, like Rhino\nif ( typeof exports !== \"undefined\" && exports ) {\n\texports.QUnit = QUnit;\n}\n\nif ( typeof define === \"function\" && define.amd ) {\n\tdefine( function() {\n\t\treturn QUnit;\n\t} );\n\tQUnit.config.autostart = false;\n}\n\n/*\n * This file is a modified version of google-diff-match-patch's JavaScript implementation\n * (https://code.google.com/p/google-diff-match-patch/source/browse/trunk/javascript/diff_match_patch_uncompressed.js),\n * modifications are licensed as more fully set forth in LICENSE.txt.\n *\n * The original source of google-diff-match-patch is attributable and licensed as follows:\n *\n * Copyright 2006 Google Inc.\n * http://code.google.com/p/google-diff-match-patch/\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * More Info:\n *  https://code.google.com/p/google-diff-match-patch/\n *\n * Usage: QUnit.diff(expected, actual)\n *\n */\nQUnit.diff = ( function() {\n\tfunction DiffMatchPatch() {\n\t}\n\n\t//  DIFF FUNCTIONS\n\n\t/**\n\t * The data structure representing a diff is an array of tuples:\n\t * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n\t * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n\t */\n\tvar DIFF_DELETE = -1,\n\t\tDIFF_INSERT = 1,\n\t\tDIFF_EQUAL = 0;\n\n\t/**\n\t * Find the differences between two texts.  Simplifies the problem by stripping\n\t * any common prefix or suffix off the texts before diffing.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {boolean=} optChecklines Optional speedup flag. If present and false,\n\t *     then don't run a line-level diff first to identify the changed areas.\n\t *     Defaults to true, which does a faster, slightly less optimal diff.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.DiffMain = function( text1, text2, optChecklines ) {\n\t\tvar deadline, checklines, commonlength,\n\t\t\tcommonprefix, commonsuffix, diffs;\n\n\t\t// The diff must be complete in up to 1 second.\n\t\tdeadline = ( new Date() ).getTime() + 1000;\n\n\t\t// Check for null inputs.\n\t\tif ( text1 === null || text2 === null ) {\n\t\t\tthrow new Error( \"Null input. (DiffMain)\" );\n\t\t}\n\n\t\t// Check for equality (speedup).\n\t\tif ( text1 === text2 ) {\n\t\t\tif ( text1 ) {\n\t\t\t\treturn [\n\t\t\t\t\t[ DIFF_EQUAL, text1 ]\n\t\t\t\t];\n\t\t\t}\n\t\t\treturn [];\n\t\t}\n\n\t\tif ( typeof optChecklines === \"undefined\" ) {\n\t\t\toptChecklines = true;\n\t\t}\n\n\t\tchecklines = optChecklines;\n\n\t\t// Trim off common prefix (speedup).\n\t\tcommonlength = this.diffCommonPrefix( text1, text2 );\n\t\tcommonprefix = text1.substring( 0, commonlength );\n\t\ttext1 = text1.substring( commonlength );\n\t\ttext2 = text2.substring( commonlength );\n\n\t\t// Trim off common suffix (speedup).\n\t\tcommonlength = this.diffCommonSuffix( text1, text2 );\n\t\tcommonsuffix = text1.substring( text1.length - commonlength );\n\t\ttext1 = text1.substring( 0, text1.length - commonlength );\n\t\ttext2 = text2.substring( 0, text2.length - commonlength );\n\n\t\t// Compute the diff on the middle block.\n\t\tdiffs = this.diffCompute( text1, text2, checklines, deadline );\n\n\t\t// Restore the prefix and suffix.\n\t\tif ( commonprefix ) {\n\t\t\tdiffs.unshift( [ DIFF_EQUAL, commonprefix ] );\n\t\t}\n\t\tif ( commonsuffix ) {\n\t\t\tdiffs.push( [ DIFF_EQUAL, commonsuffix ] );\n\t\t}\n\t\tthis.diffCleanupMerge( diffs );\n\t\treturn diffs;\n\t};\n\n\t/**\n\t * Reduce the number of edits by eliminating operationally trivial equalities.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.diffCleanupEfficiency = function( diffs ) {\n\t\tvar changes, equalities, equalitiesLength, lastequality,\n\t\t\tpointer, preIns, preDel, postIns, postDel;\n\t\tchanges = false;\n\t\tequalities = []; // Stack of indices where equalities are found.\n\t\tequalitiesLength = 0; // Keeping our own length var is faster in JS.\n\t\t/** @type {?string} */\n\t\tlastequality = null;\n\t\t// Always equal to diffs[equalities[equalitiesLength - 1]][1]\n\t\tpointer = 0; // Index of current position.\n\t\t// Is there an insertion operation before the last equality.\n\t\tpreIns = false;\n\t\t// Is there a deletion operation before the last equality.\n\t\tpreDel = false;\n\t\t// Is there an insertion operation after the last equality.\n\t\tpostIns = false;\n\t\t// Is there a deletion operation after the last equality.\n\t\tpostDel = false;\n\t\twhile ( pointer < diffs.length ) {\n\n\t\t\t// Equality found.\n\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_EQUAL ) {\n\t\t\t\tif ( diffs[ pointer ][ 1 ].length < 4 && ( postIns || postDel ) ) {\n\n\t\t\t\t\t// Candidate found.\n\t\t\t\t\tequalities[ equalitiesLength++ ] = pointer;\n\t\t\t\t\tpreIns = postIns;\n\t\t\t\t\tpreDel = postDel;\n\t\t\t\t\tlastequality = diffs[ pointer ][ 1 ];\n\t\t\t\t} else {\n\n\t\t\t\t\t// Not a candidate, and can never become one.\n\t\t\t\t\tequalitiesLength = 0;\n\t\t\t\t\tlastequality = null;\n\t\t\t\t}\n\t\t\t\tpostIns = postDel = false;\n\n\t\t\t// An insertion or deletion.\n\t\t\t} else {\n\n\t\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_DELETE ) {\n\t\t\t\t\tpostDel = true;\n\t\t\t\t} else {\n\t\t\t\t\tpostIns = true;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Five types to be split:\n\t\t\t\t * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n\t\t\t\t * <ins>A</ins>X<ins>C</ins><del>D</del>\n\t\t\t\t * <ins>A</ins><del>B</del>X<ins>C</ins>\n\t\t\t\t * <ins>A</del>X<ins>C</ins><del>D</del>\n\t\t\t\t * <ins>A</ins><del>B</del>X<del>C</del>\n\t\t\t\t */\n\t\t\t\tif ( lastequality && ( ( preIns && preDel && postIns && postDel ) ||\n\t\t\t\t\t\t( ( lastequality.length < 2 ) &&\n\t\t\t\t\t\t( preIns + preDel + postIns + postDel ) === 3 ) ) ) {\n\n\t\t\t\t\t// Duplicate record.\n\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\tequalities[ equalitiesLength - 1 ],\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t[ DIFF_DELETE, lastequality ]\n\t\t\t\t\t);\n\n\t\t\t\t\t// Change second copy to insert.\n\t\t\t\t\tdiffs[ equalities[ equalitiesLength - 1 ] + 1 ][ 0 ] = DIFF_INSERT;\n\t\t\t\t\tequalitiesLength--; // Throw away the equality we just deleted;\n\t\t\t\t\tlastequality = null;\n\t\t\t\t\tif ( preIns && preDel ) {\n\t\t\t\t\t\t// No changes made which could affect previous entry, keep going.\n\t\t\t\t\t\tpostIns = postDel = true;\n\t\t\t\t\t\tequalitiesLength = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tequalitiesLength--; // Throw away the previous equality.\n\t\t\t\t\t\tpointer = equalitiesLength > 0 ? equalities[ equalitiesLength - 1 ] : -1;\n\t\t\t\t\t\tpostIns = postDel = false;\n\t\t\t\t\t}\n\t\t\t\t\tchanges = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\n\t\tif ( changes ) {\n\t\t\tthis.diffCleanupMerge( diffs );\n\t\t}\n\t};\n\n\t/**\n\t * Convert a diff array into a pretty HTML report.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t * @param {integer} string to be beautified.\n\t * @return {string} HTML representation.\n\t */\n\tDiffMatchPatch.prototype.diffPrettyHtml = function( diffs ) {\n\t\tvar op, data, x,\n\t\t\thtml = [];\n\t\tfor ( x = 0; x < diffs.length; x++ ) {\n\t\t\top = diffs[ x ][ 0 ]; // Operation (insert, delete, equal)\n\t\t\tdata = diffs[ x ][ 1 ]; // Text of change.\n\t\t\tswitch ( op ) {\n\t\t\tcase DIFF_INSERT:\n\t\t\t\thtml[ x ] = \"<ins>\" + data + \"</ins>\";\n\t\t\t\tbreak;\n\t\t\tcase DIFF_DELETE:\n\t\t\t\thtml[ x ] = \"<del>\" + data + \"</del>\";\n\t\t\t\tbreak;\n\t\t\tcase DIFF_EQUAL:\n\t\t\t\thtml[ x ] = \"<span>\" + data + \"</span>\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn html.join( \"\" );\n\t};\n\n\t/**\n\t * Determine the common prefix of two strings.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {number} The number of characters common to the start of each\n\t *     string.\n\t */\n\tDiffMatchPatch.prototype.diffCommonPrefix = function( text1, text2 ) {\n\t\tvar pointermid, pointermax, pointermin, pointerstart;\n\t\t// Quick check for common null cases.\n\t\tif ( !text1 || !text2 || text1.charAt( 0 ) !== text2.charAt( 0 ) ) {\n\t\t\treturn 0;\n\t\t}\n\t\t// Binary search.\n\t\t// Performance analysis: http://neil.fraser.name/news/2007/10/09/\n\t\tpointermin = 0;\n\t\tpointermax = Math.min( text1.length, text2.length );\n\t\tpointermid = pointermax;\n\t\tpointerstart = 0;\n\t\twhile ( pointermin < pointermid ) {\n\t\t\tif ( text1.substring( pointerstart, pointermid ) ===\n\t\t\t\t\ttext2.substring( pointerstart, pointermid ) ) {\n\t\t\t\tpointermin = pointermid;\n\t\t\t\tpointerstart = pointermin;\n\t\t\t} else {\n\t\t\t\tpointermax = pointermid;\n\t\t\t}\n\t\t\tpointermid = Math.floor( ( pointermax - pointermin ) / 2 + pointermin );\n\t\t}\n\t\treturn pointermid;\n\t};\n\n\t/**\n\t * Determine the common suffix of two strings.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {number} The number of characters common to the end of each string.\n\t */\n\tDiffMatchPatch.prototype.diffCommonSuffix = function( text1, text2 ) {\n\t\tvar pointermid, pointermax, pointermin, pointerend;\n\t\t// Quick check for common null cases.\n\t\tif ( !text1 ||\n\t\t\t\t!text2 ||\n\t\t\t\ttext1.charAt( text1.length - 1 ) !== text2.charAt( text2.length - 1 ) ) {\n\t\t\treturn 0;\n\t\t}\n\t\t// Binary search.\n\t\t// Performance analysis: http://neil.fraser.name/news/2007/10/09/\n\t\tpointermin = 0;\n\t\tpointermax = Math.min( text1.length, text2.length );\n\t\tpointermid = pointermax;\n\t\tpointerend = 0;\n\t\twhile ( pointermin < pointermid ) {\n\t\t\tif ( text1.substring( text1.length - pointermid, text1.length - pointerend ) ===\n\t\t\t\t\ttext2.substring( text2.length - pointermid, text2.length - pointerend ) ) {\n\t\t\t\tpointermin = pointermid;\n\t\t\t\tpointerend = pointermin;\n\t\t\t} else {\n\t\t\t\tpointermax = pointermid;\n\t\t\t}\n\t\t\tpointermid = Math.floor( ( pointermax - pointermin ) / 2 + pointermin );\n\t\t}\n\t\treturn pointermid;\n\t};\n\n\t/**\n\t * Find the differences between two texts.  Assumes that the texts do not\n\t * have any common prefix or suffix.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {boolean} checklines Speedup flag.  If false, then don't run a\n\t *     line-level diff first to identify the changed areas.\n\t *     If true, then run a faster, slightly less optimal diff.\n\t * @param {number} deadline Time when the diff should be complete by.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffCompute = function( text1, text2, checklines, deadline ) {\n\t\tvar diffs, longtext, shorttext, i, hm,\n\t\t\ttext1A, text2A, text1B, text2B,\n\t\t\tmidCommon, diffsA, diffsB;\n\n\t\tif ( !text1 ) {\n\t\t\t// Just add some text (speedup).\n\t\t\treturn [\n\t\t\t\t[ DIFF_INSERT, text2 ]\n\t\t\t];\n\t\t}\n\n\t\tif ( !text2 ) {\n\t\t\t// Just delete some text (speedup).\n\t\t\treturn [\n\t\t\t\t[ DIFF_DELETE, text1 ]\n\t\t\t];\n\t\t}\n\n\t\tlongtext = text1.length > text2.length ? text1 : text2;\n\t\tshorttext = text1.length > text2.length ? text2 : text1;\n\t\ti = longtext.indexOf( shorttext );\n\t\tif ( i !== -1 ) {\n\t\t\t// Shorter text is inside the longer text (speedup).\n\t\t\tdiffs = [\n\t\t\t\t[ DIFF_INSERT, longtext.substring( 0, i ) ],\n\t\t\t\t[ DIFF_EQUAL, shorttext ],\n\t\t\t\t[ DIFF_INSERT, longtext.substring( i + shorttext.length ) ]\n\t\t\t];\n\t\t\t// Swap insertions for deletions if diff is reversed.\n\t\t\tif ( text1.length > text2.length ) {\n\t\t\t\tdiffs[ 0 ][ 0 ] = diffs[ 2 ][ 0 ] = DIFF_DELETE;\n\t\t\t}\n\t\t\treturn diffs;\n\t\t}\n\n\t\tif ( shorttext.length === 1 ) {\n\t\t\t// Single character string.\n\t\t\t// After the previous speedup, the character can't be an equality.\n\t\t\treturn [\n\t\t\t\t[ DIFF_DELETE, text1 ],\n\t\t\t\t[ DIFF_INSERT, text2 ]\n\t\t\t];\n\t\t}\n\n\t\t// Check to see if the problem can be split in two.\n\t\thm = this.diffHalfMatch( text1, text2 );\n\t\tif ( hm ) {\n\t\t\t// A half-match was found, sort out the return data.\n\t\t\ttext1A = hm[ 0 ];\n\t\t\ttext1B = hm[ 1 ];\n\t\t\ttext2A = hm[ 2 ];\n\t\t\ttext2B = hm[ 3 ];\n\t\t\tmidCommon = hm[ 4 ];\n\t\t\t// Send both pairs off for separate processing.\n\t\t\tdiffsA = this.DiffMain( text1A, text2A, checklines, deadline );\n\t\t\tdiffsB = this.DiffMain( text1B, text2B, checklines, deadline );\n\t\t\t// Merge the results.\n\t\t\treturn diffsA.concat( [\n\t\t\t\t[ DIFF_EQUAL, midCommon ]\n\t\t\t], diffsB );\n\t\t}\n\n\t\tif ( checklines && text1.length > 100 && text2.length > 100 ) {\n\t\t\treturn this.diffLineMode( text1, text2, deadline );\n\t\t}\n\n\t\treturn this.diffBisect( text1, text2, deadline );\n\t};\n\n\t/**\n\t * Do the two texts share a substring which is at least half the length of the\n\t * longer text?\n\t * This speedup can produce non-minimal diffs.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {Array.<string>} Five element Array, containing the prefix of\n\t *     text1, the suffix of text1, the prefix of text2, the suffix of\n\t *     text2 and the common middle.  Or null if there was no match.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffHalfMatch = function( text1, text2 ) {\n\t\tvar longtext, shorttext, dmp,\n\t\t\ttext1A, text2B, text2A, text1B, midCommon,\n\t\t\thm1, hm2, hm;\n\n\t\tlongtext = text1.length > text2.length ? text1 : text2;\n\t\tshorttext = text1.length > text2.length ? text2 : text1;\n\t\tif ( longtext.length < 4 || shorttext.length * 2 < longtext.length ) {\n\t\t\treturn null; // Pointless.\n\t\t}\n\t\tdmp = this; // 'this' becomes 'window' in a closure.\n\n\t\t/**\n\t\t * Does a substring of shorttext exist within longtext such that the substring\n\t\t * is at least half the length of longtext?\n\t\t * Closure, but does not reference any external variables.\n\t\t * @param {string} longtext Longer string.\n\t\t * @param {string} shorttext Shorter string.\n\t\t * @param {number} i Start index of quarter length substring within longtext.\n\t\t * @return {Array.<string>} Five element Array, containing the prefix of\n\t\t *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n\t\t *     of shorttext and the common middle.  Or null if there was no match.\n\t\t * @private\n\t\t */\n\t\tfunction diffHalfMatchI( longtext, shorttext, i ) {\n\t\t\tvar seed, j, bestCommon, prefixLength, suffixLength,\n\t\t\t\tbestLongtextA, bestLongtextB, bestShorttextA, bestShorttextB;\n\t\t\t// Start with a 1/4 length substring at position i as a seed.\n\t\t\tseed = longtext.substring( i, i + Math.floor( longtext.length / 4 ) );\n\t\t\tj = -1;\n\t\t\tbestCommon = \"\";\n\t\t\twhile ( ( j = shorttext.indexOf( seed, j + 1 ) ) !== -1 ) {\n\t\t\t\tprefixLength = dmp.diffCommonPrefix( longtext.substring( i ),\n\t\t\t\t\tshorttext.substring( j ) );\n\t\t\t\tsuffixLength = dmp.diffCommonSuffix( longtext.substring( 0, i ),\n\t\t\t\t\tshorttext.substring( 0, j ) );\n\t\t\t\tif ( bestCommon.length < suffixLength + prefixLength ) {\n\t\t\t\t\tbestCommon = shorttext.substring( j - suffixLength, j ) +\n\t\t\t\t\t\tshorttext.substring( j, j + prefixLength );\n\t\t\t\t\tbestLongtextA = longtext.substring( 0, i - suffixLength );\n\t\t\t\t\tbestLongtextB = longtext.substring( i + prefixLength );\n\t\t\t\t\tbestShorttextA = shorttext.substring( 0, j - suffixLength );\n\t\t\t\t\tbestShorttextB = shorttext.substring( j + prefixLength );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( bestCommon.length * 2 >= longtext.length ) {\n\t\t\t\treturn [ bestLongtextA, bestLongtextB,\n\t\t\t\t\tbestShorttextA, bestShorttextB, bestCommon\n\t\t\t\t];\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\t// First check if the second quarter is the seed for a half-match.\n\t\thm1 = diffHalfMatchI( longtext, shorttext,\n\t\t\tMath.ceil( longtext.length / 4 ) );\n\t\t// Check again based on the third quarter.\n\t\thm2 = diffHalfMatchI( longtext, shorttext,\n\t\t\tMath.ceil( longtext.length / 2 ) );\n\t\tif ( !hm1 && !hm2 ) {\n\t\t\treturn null;\n\t\t} else if ( !hm2 ) {\n\t\t\thm = hm1;\n\t\t} else if ( !hm1 ) {\n\t\t\thm = hm2;\n\t\t} else {\n\t\t\t// Both matched.  Select the longest.\n\t\t\thm = hm1[ 4 ].length > hm2[ 4 ].length ? hm1 : hm2;\n\t\t}\n\n\t\t// A half-match was found, sort out the return data.\n\t\ttext1A, text1B, text2A, text2B;\n\t\tif ( text1.length > text2.length ) {\n\t\t\ttext1A = hm[ 0 ];\n\t\t\ttext1B = hm[ 1 ];\n\t\t\ttext2A = hm[ 2 ];\n\t\t\ttext2B = hm[ 3 ];\n\t\t} else {\n\t\t\ttext2A = hm[ 0 ];\n\t\t\ttext2B = hm[ 1 ];\n\t\t\ttext1A = hm[ 2 ];\n\t\t\ttext1B = hm[ 3 ];\n\t\t}\n\t\tmidCommon = hm[ 4 ];\n\t\treturn [ text1A, text1B, text2A, text2B, midCommon ];\n\t};\n\n\t/**\n\t * Do a quick line-level diff on both strings, then rediff the parts for\n\t * greater accuracy.\n\t * This speedup can produce non-minimal diffs.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {number} deadline Time when the diff should be complete by.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffLineMode = function( text1, text2, deadline ) {\n\t\tvar a, diffs, linearray, pointer, countInsert,\n\t\t\tcountDelete, textInsert, textDelete, j;\n\t\t// Scan the text on a line-by-line basis first.\n\t\ta = this.diffLinesToChars( text1, text2 );\n\t\ttext1 = a.chars1;\n\t\ttext2 = a.chars2;\n\t\tlinearray = a.lineArray;\n\n\t\tdiffs = this.DiffMain( text1, text2, false, deadline );\n\n\t\t// Convert the diff back to original text.\n\t\tthis.diffCharsToLines( diffs, linearray );\n\t\t// Eliminate freak matches (e.g. blank lines)\n\t\tthis.diffCleanupSemantic( diffs );\n\n\t\t// Rediff any replacement blocks, this time character-by-character.\n\t\t// Add a dummy entry at the end.\n\t\tdiffs.push( [ DIFF_EQUAL, \"\" ] );\n\t\tpointer = 0;\n\t\tcountDelete = 0;\n\t\tcountInsert = 0;\n\t\ttextDelete = \"\";\n\t\ttextInsert = \"\";\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tswitch ( diffs[ pointer ][ 0 ] ) {\n\t\t\tcase DIFF_INSERT:\n\t\t\t\tcountInsert++;\n\t\t\t\ttextInsert += diffs[ pointer ][ 1 ];\n\t\t\t\tbreak;\n\t\t\tcase DIFF_DELETE:\n\t\t\t\tcountDelete++;\n\t\t\t\ttextDelete += diffs[ pointer ][ 1 ];\n\t\t\t\tbreak;\n\t\t\tcase DIFF_EQUAL:\n\t\t\t\t// Upon reaching an equality, check for prior redundancies.\n\t\t\t\tif ( countDelete >= 1 && countInsert >= 1 ) {\n\t\t\t\t\t// Delete the offending records and add the merged ones.\n\t\t\t\t\tdiffs.splice( pointer - countDelete - countInsert,\n\t\t\t\t\t\tcountDelete + countInsert );\n\t\t\t\t\tpointer = pointer - countDelete - countInsert;\n\t\t\t\t\ta = this.DiffMain( textDelete, textInsert, false, deadline );\n\t\t\t\t\tfor ( j = a.length - 1; j >= 0; j-- ) {\n\t\t\t\t\t\tdiffs.splice( pointer, 0, a[ j ] );\n\t\t\t\t\t}\n\t\t\t\t\tpointer = pointer + a.length;\n\t\t\t\t}\n\t\t\t\tcountInsert = 0;\n\t\t\t\tcountDelete = 0;\n\t\t\t\ttextDelete = \"\";\n\t\t\t\ttextInsert = \"\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\t\tdiffs.pop(); // Remove the dummy entry at the end.\n\n\t\treturn diffs;\n\t};\n\n\t/**\n\t * Find the 'middle snake' of a diff, split the problem in two\n\t * and return the recursively constructed diff.\n\t * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {number} deadline Time at which to bail if not yet complete.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffBisect = function( text1, text2, deadline ) {\n\t\tvar text1Length, text2Length, maxD, vOffset, vLength,\n\t\t\tv1, v2, x, delta, front, k1start, k1end, k2start,\n\t\t\tk2end, k2Offset, k1Offset, x1, x2, y1, y2, d, k1, k2;\n\t\t// Cache the text lengths to prevent multiple calls.\n\t\ttext1Length = text1.length;\n\t\ttext2Length = text2.length;\n\t\tmaxD = Math.ceil( ( text1Length + text2Length ) / 2 );\n\t\tvOffset = maxD;\n\t\tvLength = 2 * maxD;\n\t\tv1 = new Array( vLength );\n\t\tv2 = new Array( vLength );\n\t\t// Setting all elements to -1 is faster in Chrome & Firefox than mixing\n\t\t// integers and undefined.\n\t\tfor ( x = 0; x < vLength; x++ ) {\n\t\t\tv1[ x ] = -1;\n\t\t\tv2[ x ] = -1;\n\t\t}\n\t\tv1[ vOffset + 1 ] = 0;\n\t\tv2[ vOffset + 1 ] = 0;\n\t\tdelta = text1Length - text2Length;\n\t\t// If the total number of characters is odd, then the front path will collide\n\t\t// with the reverse path.\n\t\tfront = ( delta % 2 !== 0 );\n\t\t// Offsets for start and end of k loop.\n\t\t// Prevents mapping of space beyond the grid.\n\t\tk1start = 0;\n\t\tk1end = 0;\n\t\tk2start = 0;\n\t\tk2end = 0;\n\t\tfor ( d = 0; d < maxD; d++ ) {\n\t\t\t// Bail out if deadline is reached.\n\t\t\tif ( ( new Date() ).getTime() > deadline ) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Walk the front path one step.\n\t\t\tfor ( k1 = -d + k1start; k1 <= d - k1end; k1 += 2 ) {\n\t\t\t\tk1Offset = vOffset + k1;\n\t\t\t\tif ( k1 === -d || ( k1 !== d && v1[ k1Offset - 1 ] < v1[ k1Offset + 1 ] ) ) {\n\t\t\t\t\tx1 = v1[ k1Offset + 1 ];\n\t\t\t\t} else {\n\t\t\t\t\tx1 = v1[ k1Offset - 1 ] + 1;\n\t\t\t\t}\n\t\t\t\ty1 = x1 - k1;\n\t\t\t\twhile ( x1 < text1Length && y1 < text2Length &&\n\t\t\t\t\ttext1.charAt( x1 ) === text2.charAt( y1 ) ) {\n\t\t\t\t\tx1++;\n\t\t\t\t\ty1++;\n\t\t\t\t}\n\t\t\t\tv1[ k1Offset ] = x1;\n\t\t\t\tif ( x1 > text1Length ) {\n\t\t\t\t\t// Ran off the right of the graph.\n\t\t\t\t\tk1end += 2;\n\t\t\t\t} else if ( y1 > text2Length ) {\n\t\t\t\t\t// Ran off the bottom of the graph.\n\t\t\t\t\tk1start += 2;\n\t\t\t\t} else if ( front ) {\n\t\t\t\t\tk2Offset = vOffset + delta - k1;\n\t\t\t\t\tif ( k2Offset >= 0 && k2Offset < vLength && v2[ k2Offset ] !== -1 ) {\n\t\t\t\t\t\t// Mirror x2 onto top-left coordinate system.\n\t\t\t\t\t\tx2 = text1Length - v2[ k2Offset ];\n\t\t\t\t\t\tif ( x1 >= x2 ) {\n\t\t\t\t\t\t\t// Overlap detected.\n\t\t\t\t\t\t\treturn this.diffBisectSplit( text1, text2, x1, y1, deadline );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Walk the reverse path one step.\n\t\t\tfor ( k2 = -d + k2start; k2 <= d - k2end; k2 += 2 ) {\n\t\t\t\tk2Offset = vOffset + k2;\n\t\t\t\tif ( k2 === -d || ( k2 !== d && v2[ k2Offset - 1 ] < v2[ k2Offset + 1 ] ) ) {\n\t\t\t\t\tx2 = v2[ k2Offset + 1 ];\n\t\t\t\t} else {\n\t\t\t\t\tx2 = v2[ k2Offset - 1 ] + 1;\n\t\t\t\t}\n\t\t\t\ty2 = x2 - k2;\n\t\t\t\twhile ( x2 < text1Length && y2 < text2Length &&\n\t\t\t\t\ttext1.charAt( text1Length - x2 - 1 ) ===\n\t\t\t\t\ttext2.charAt( text2Length - y2 - 1 ) ) {\n\t\t\t\t\tx2++;\n\t\t\t\t\ty2++;\n\t\t\t\t}\n\t\t\t\tv2[ k2Offset ] = x2;\n\t\t\t\tif ( x2 > text1Length ) {\n\t\t\t\t\t// Ran off the left of the graph.\n\t\t\t\t\tk2end += 2;\n\t\t\t\t} else if ( y2 > text2Length ) {\n\t\t\t\t\t// Ran off the top of the graph.\n\t\t\t\t\tk2start += 2;\n\t\t\t\t} else if ( !front ) {\n\t\t\t\t\tk1Offset = vOffset + delta - k2;\n\t\t\t\t\tif ( k1Offset >= 0 && k1Offset < vLength && v1[ k1Offset ] !== -1 ) {\n\t\t\t\t\t\tx1 = v1[ k1Offset ];\n\t\t\t\t\t\ty1 = vOffset + x1 - k1Offset;\n\t\t\t\t\t\t// Mirror x2 onto top-left coordinate system.\n\t\t\t\t\t\tx2 = text1Length - x2;\n\t\t\t\t\t\tif ( x1 >= x2 ) {\n\t\t\t\t\t\t\t// Overlap detected.\n\t\t\t\t\t\t\treturn this.diffBisectSplit( text1, text2, x1, y1, deadline );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Diff took too long and hit the deadline or\n\t\t// number of diffs equals number of characters, no commonality at all.\n\t\treturn [\n\t\t\t[ DIFF_DELETE, text1 ],\n\t\t\t[ DIFF_INSERT, text2 ]\n\t\t];\n\t};\n\n\t/**\n\t * Given the location of the 'middle snake', split the diff in two parts\n\t * and recurse.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {number} x Index of split point in text1.\n\t * @param {number} y Index of split point in text2.\n\t * @param {number} deadline Time at which to bail if not yet complete.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffBisectSplit = function( text1, text2, x, y, deadline ) {\n\t\tvar text1a, text1b, text2a, text2b, diffs, diffsb;\n\t\ttext1a = text1.substring( 0, x );\n\t\ttext2a = text2.substring( 0, y );\n\t\ttext1b = text1.substring( x );\n\t\ttext2b = text2.substring( y );\n\n\t\t// Compute both diffs serially.\n\t\tdiffs = this.DiffMain( text1a, text2a, false, deadline );\n\t\tdiffsb = this.DiffMain( text1b, text2b, false, deadline );\n\n\t\treturn diffs.concat( diffsb );\n\t};\n\n\t/**\n\t * Reduce the number of edits by eliminating semantically trivial equalities.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.diffCleanupSemantic = function( diffs ) {\n\t\tvar changes, equalities, equalitiesLength, lastequality,\n\t\t\tpointer, lengthInsertions2, lengthDeletions2, lengthInsertions1,\n\t\t\tlengthDeletions1, deletion, insertion, overlapLength1, overlapLength2;\n\t\tchanges = false;\n\t\tequalities = []; // Stack of indices where equalities are found.\n\t\tequalitiesLength = 0; // Keeping our own length var is faster in JS.\n\t\t/** @type {?string} */\n\t\tlastequality = null;\n\t\t// Always equal to diffs[equalities[equalitiesLength - 1]][1]\n\t\tpointer = 0; // Index of current position.\n\t\t// Number of characters that changed prior to the equality.\n\t\tlengthInsertions1 = 0;\n\t\tlengthDeletions1 = 0;\n\t\t// Number of characters that changed after the equality.\n\t\tlengthInsertions2 = 0;\n\t\tlengthDeletions2 = 0;\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_EQUAL ) { // Equality found.\n\t\t\t\tequalities[ equalitiesLength++ ] = pointer;\n\t\t\t\tlengthInsertions1 = lengthInsertions2;\n\t\t\t\tlengthDeletions1 = lengthDeletions2;\n\t\t\t\tlengthInsertions2 = 0;\n\t\t\t\tlengthDeletions2 = 0;\n\t\t\t\tlastequality = diffs[ pointer ][ 1 ];\n\t\t\t} else { // An insertion or deletion.\n\t\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_INSERT ) {\n\t\t\t\t\tlengthInsertions2 += diffs[ pointer ][ 1 ].length;\n\t\t\t\t} else {\n\t\t\t\t\tlengthDeletions2 += diffs[ pointer ][ 1 ].length;\n\t\t\t\t}\n\t\t\t\t// Eliminate an equality that is smaller or equal to the edits on both\n\t\t\t\t// sides of it.\n\t\t\t\tif ( lastequality && ( lastequality.length <=\n\t\t\t\t\t\tMath.max( lengthInsertions1, lengthDeletions1 ) ) &&\n\t\t\t\t\t\t( lastequality.length <= Math.max( lengthInsertions2,\n\t\t\t\t\t\t\tlengthDeletions2 ) ) ) {\n\n\t\t\t\t\t// Duplicate record.\n\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\tequalities[ equalitiesLength - 1 ],\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t[ DIFF_DELETE, lastequality ]\n\t\t\t\t\t);\n\n\t\t\t\t\t// Change second copy to insert.\n\t\t\t\t\tdiffs[ equalities[ equalitiesLength - 1 ] + 1 ][ 0 ] = DIFF_INSERT;\n\n\t\t\t\t\t// Throw away the equality we just deleted.\n\t\t\t\t\tequalitiesLength--;\n\n\t\t\t\t\t// Throw away the previous equality (it needs to be reevaluated).\n\t\t\t\t\tequalitiesLength--;\n\t\t\t\t\tpointer = equalitiesLength > 0 ? equalities[ equalitiesLength - 1 ] : -1;\n\n\t\t\t\t\t// Reset the counters.\n\t\t\t\t\tlengthInsertions1 = 0;\n\t\t\t\t\tlengthDeletions1 = 0;\n\t\t\t\t\tlengthInsertions2 = 0;\n\t\t\t\t\tlengthDeletions2 = 0;\n\t\t\t\t\tlastequality = null;\n\t\t\t\t\tchanges = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\n\t\t// Normalize the diff.\n\t\tif ( changes ) {\n\t\t\tthis.diffCleanupMerge( diffs );\n\t\t}\n\n\t\t// Find any overlaps between deletions and insertions.\n\t\t// e.g: <del>abcxxx</del><ins>xxxdef</ins>\n\t\t//   -> <del>abc</del>xxx<ins>def</ins>\n\t\t// e.g: <del>xxxabc</del><ins>defxxx</ins>\n\t\t//   -> <ins>def</ins>xxx<del>abc</del>\n\t\t// Only extract an overlap if it is as big as the edit ahead or behind it.\n\t\tpointer = 1;\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tif ( diffs[ pointer - 1 ][ 0 ] === DIFF_DELETE &&\n\t\t\t\t\tdiffs[ pointer ][ 0 ] === DIFF_INSERT ) {\n\t\t\t\tdeletion = diffs[ pointer - 1 ][ 1 ];\n\t\t\t\tinsertion = diffs[ pointer ][ 1 ];\n\t\t\t\toverlapLength1 = this.diffCommonOverlap( deletion, insertion );\n\t\t\t\toverlapLength2 = this.diffCommonOverlap( insertion, deletion );\n\t\t\t\tif ( overlapLength1 >= overlapLength2 ) {\n\t\t\t\t\tif ( overlapLength1 >= deletion.length / 2 ||\n\t\t\t\t\t\t\toverlapLength1 >= insertion.length / 2 ) {\n\t\t\t\t\t\t// Overlap found.  Insert an equality and trim the surrounding edits.\n\t\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\t\tpointer,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t[ DIFF_EQUAL, insertion.substring( 0, overlapLength1 ) ]\n\t\t\t\t\t\t);\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] =\n\t\t\t\t\t\t\tdeletion.substring( 0, deletion.length - overlapLength1 );\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] = insertion.substring( overlapLength1 );\n\t\t\t\t\t\tpointer++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ( overlapLength2 >= deletion.length / 2 ||\n\t\t\t\t\t\t\toverlapLength2 >= insertion.length / 2 ) {\n\n\t\t\t\t\t\t// Reverse overlap found.\n\t\t\t\t\t\t// Insert an equality and swap and trim the surrounding edits.\n\t\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\t\tpointer,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t[ DIFF_EQUAL, deletion.substring( 0, overlapLength2 ) ]\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 0 ] = DIFF_INSERT;\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] =\n\t\t\t\t\t\t\tinsertion.substring( 0, insertion.length - overlapLength2 );\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 0 ] = DIFF_DELETE;\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] =\n\t\t\t\t\t\t\tdeletion.substring( overlapLength2 );\n\t\t\t\t\t\tpointer++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpointer++;\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\t};\n\n\t/**\n\t * Determine if the suffix of one string is the prefix of another.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {number} The number of characters common to the end of the first\n\t *     string and the start of the second string.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffCommonOverlap = function( text1, text2 ) {\n\t\tvar text1Length, text2Length, textLength,\n\t\t\tbest, length, pattern, found;\n\t\t// Cache the text lengths to prevent multiple calls.\n\t\ttext1Length = text1.length;\n\t\ttext2Length = text2.length;\n\t\t// Eliminate the null case.\n\t\tif ( text1Length === 0 || text2Length === 0 ) {\n\t\t\treturn 0;\n\t\t}\n\t\t// Truncate the longer string.\n\t\tif ( text1Length > text2Length ) {\n\t\t\ttext1 = text1.substring( text1Length - text2Length );\n\t\t} else if ( text1Length < text2Length ) {\n\t\t\ttext2 = text2.substring( 0, text1Length );\n\t\t}\n\t\ttextLength = Math.min( text1Length, text2Length );\n\t\t// Quick check for the worst case.\n\t\tif ( text1 === text2 ) {\n\t\t\treturn textLength;\n\t\t}\n\n\t\t// Start by looking for a single character match\n\t\t// and increase length until no match is found.\n\t\t// Performance analysis: http://neil.fraser.name/news/2010/11/04/\n\t\tbest = 0;\n\t\tlength = 1;\n\t\twhile ( true ) {\n\t\t\tpattern = text1.substring( textLength - length );\n\t\t\tfound = text2.indexOf( pattern );\n\t\t\tif ( found === -1 ) {\n\t\t\t\treturn best;\n\t\t\t}\n\t\t\tlength += found;\n\t\t\tif ( found === 0 || text1.substring( textLength - length ) ===\n\t\t\t\t\ttext2.substring( 0, length ) ) {\n\t\t\t\tbest = length;\n\t\t\t\tlength++;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Split two texts into an array of strings.  Reduce the texts to a string of\n\t * hashes where each Unicode character represents one line.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\n\t *     An object containing the encoded text1, the encoded text2 and\n\t *     the array of unique strings.\n\t *     The zeroth element of the array of unique strings is intentionally blank.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffLinesToChars = function( text1, text2 ) {\n\t\tvar lineArray, lineHash, chars1, chars2;\n\t\tlineArray = []; // e.g. lineArray[4] === 'Hello\\n'\n\t\tlineHash = {}; // e.g. lineHash['Hello\\n'] === 4\n\n\t\t// '\\x00' is a valid character, but various debuggers don't like it.\n\t\t// So we'll insert a junk entry to avoid generating a null character.\n\t\tlineArray[ 0 ] = \"\";\n\n\t\t/**\n\t\t * Split a text into an array of strings.  Reduce the texts to a string of\n\t\t * hashes where each Unicode character represents one line.\n\t\t * Modifies linearray and linehash through being a closure.\n\t\t * @param {string} text String to encode.\n\t\t * @return {string} Encoded string.\n\t\t * @private\n\t\t */\n\t\tfunction diffLinesToCharsMunge( text ) {\n\t\t\tvar chars, lineStart, lineEnd, lineArrayLength, line;\n\t\t\tchars = \"\";\n\t\t\t// Walk the text, pulling out a substring for each line.\n\t\t\t// text.split('\\n') would would temporarily double our memory footprint.\n\t\t\t// Modifying text would create many large strings to garbage collect.\n\t\t\tlineStart = 0;\n\t\t\tlineEnd = -1;\n\t\t\t// Keeping our own length variable is faster than looking it up.\n\t\t\tlineArrayLength = lineArray.length;\n\t\t\twhile ( lineEnd < text.length - 1 ) {\n\t\t\t\tlineEnd = text.indexOf( \"\\n\", lineStart );\n\t\t\t\tif ( lineEnd === -1 ) {\n\t\t\t\t\tlineEnd = text.length - 1;\n\t\t\t\t}\n\t\t\t\tline = text.substring( lineStart, lineEnd + 1 );\n\t\t\t\tlineStart = lineEnd + 1;\n\n\t\t\t\tif ( lineHash.hasOwnProperty ? lineHash.hasOwnProperty( line ) :\n\t\t\t\t\t\t\t( lineHash[ line ] !== undefined ) ) {\n\t\t\t\t\tchars += String.fromCharCode( lineHash[ line ] );\n\t\t\t\t} else {\n\t\t\t\t\tchars += String.fromCharCode( lineArrayLength );\n\t\t\t\t\tlineHash[ line ] = lineArrayLength;\n\t\t\t\t\tlineArray[ lineArrayLength++ ] = line;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn chars;\n\t\t}\n\n\t\tchars1 = diffLinesToCharsMunge( text1 );\n\t\tchars2 = diffLinesToCharsMunge( text2 );\n\t\treturn {\n\t\t\tchars1: chars1,\n\t\t\tchars2: chars2,\n\t\t\tlineArray: lineArray\n\t\t};\n\t};\n\n\t/**\n\t * Rehydrate the text in a diff from a string of line hashes to real lines of\n\t * text.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t * @param {!Array.<string>} lineArray Array of unique strings.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffCharsToLines = function( diffs, lineArray ) {\n\t\tvar x, chars, text, y;\n\t\tfor ( x = 0; x < diffs.length; x++ ) {\n\t\t\tchars = diffs[ x ][ 1 ];\n\t\t\ttext = [];\n\t\t\tfor ( y = 0; y < chars.length; y++ ) {\n\t\t\t\ttext[ y ] = lineArray[ chars.charCodeAt( y ) ];\n\t\t\t}\n\t\t\tdiffs[ x ][ 1 ] = text.join( \"\" );\n\t\t}\n\t};\n\n\t/**\n\t * Reorder and merge like edit sections.  Merge equalities.\n\t * Any edit section can move as long as it doesn't cross an equality.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.diffCleanupMerge = function( diffs ) {\n\t\tvar pointer, countDelete, countInsert, textInsert, textDelete,\n\t\t\tcommonlength, changes, diffPointer, position;\n\t\tdiffs.push( [ DIFF_EQUAL, \"\" ] ); // Add a dummy entry at the end.\n\t\tpointer = 0;\n\t\tcountDelete = 0;\n\t\tcountInsert = 0;\n\t\ttextDelete = \"\";\n\t\ttextInsert = \"\";\n\t\tcommonlength;\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tswitch ( diffs[ pointer ][ 0 ] ) {\n\t\t\tcase DIFF_INSERT:\n\t\t\t\tcountInsert++;\n\t\t\t\ttextInsert += diffs[ pointer ][ 1 ];\n\t\t\t\tpointer++;\n\t\t\t\tbreak;\n\t\t\tcase DIFF_DELETE:\n\t\t\t\tcountDelete++;\n\t\t\t\ttextDelete += diffs[ pointer ][ 1 ];\n\t\t\t\tpointer++;\n\t\t\t\tbreak;\n\t\t\tcase DIFF_EQUAL:\n\t\t\t\t// Upon reaching an equality, check for prior redundancies.\n\t\t\t\tif ( countDelete + countInsert > 1 ) {\n\t\t\t\t\tif ( countDelete !== 0 && countInsert !== 0 ) {\n\t\t\t\t\t\t// Factor out any common prefixies.\n\t\t\t\t\t\tcommonlength = this.diffCommonPrefix( textInsert, textDelete );\n\t\t\t\t\t\tif ( commonlength !== 0 ) {\n\t\t\t\t\t\t\tif ( ( pointer - countDelete - countInsert ) > 0 &&\n\t\t\t\t\t\t\t\t\tdiffs[ pointer - countDelete - countInsert - 1 ][ 0 ] ===\n\t\t\t\t\t\t\t\t\tDIFF_EQUAL ) {\n\t\t\t\t\t\t\t\tdiffs[ pointer - countDelete - countInsert - 1 ][ 1 ] +=\n\t\t\t\t\t\t\t\t\ttextInsert.substring( 0, commonlength );\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdiffs.splice( 0, 0, [ DIFF_EQUAL,\n\t\t\t\t\t\t\t\t\ttextInsert.substring( 0, commonlength )\n\t\t\t\t\t\t\t\t] );\n\t\t\t\t\t\t\t\tpointer++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttextInsert = textInsert.substring( commonlength );\n\t\t\t\t\t\t\ttextDelete = textDelete.substring( commonlength );\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Factor out any common suffixies.\n\t\t\t\t\t\tcommonlength = this.diffCommonSuffix( textInsert, textDelete );\n\t\t\t\t\t\tif ( commonlength !== 0 ) {\n\t\t\t\t\t\t\tdiffs[ pointer ][ 1 ] = textInsert.substring( textInsert.length -\n\t\t\t\t\t\t\t\t\tcommonlength ) + diffs[ pointer ][ 1 ];\n\t\t\t\t\t\t\ttextInsert = textInsert.substring( 0, textInsert.length -\n\t\t\t\t\t\t\t\tcommonlength );\n\t\t\t\t\t\t\ttextDelete = textDelete.substring( 0, textDelete.length -\n\t\t\t\t\t\t\t\tcommonlength );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Delete the offending records and add the merged ones.\n\t\t\t\t\tif ( countDelete === 0 ) {\n\t\t\t\t\t\tdiffs.splice( pointer - countInsert,\n\t\t\t\t\t\t\tcountDelete + countInsert, [ DIFF_INSERT, textInsert ] );\n\t\t\t\t\t} else if ( countInsert === 0 ) {\n\t\t\t\t\t\tdiffs.splice( pointer - countDelete,\n\t\t\t\t\t\t\tcountDelete + countInsert, [ DIFF_DELETE, textDelete ] );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\t\tpointer - countDelete - countInsert,\n\t\t\t\t\t\t\tcountDelete + countInsert,\n\t\t\t\t\t\t\t[ DIFF_DELETE, textDelete ], [ DIFF_INSERT, textInsert ]\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tpointer = pointer - countDelete - countInsert +\n\t\t\t\t\t\t( countDelete ? 1 : 0 ) + ( countInsert ? 1 : 0 ) + 1;\n\t\t\t\t} else if ( pointer !== 0 && diffs[ pointer - 1 ][ 0 ] === DIFF_EQUAL ) {\n\n\t\t\t\t\t// Merge this equality with the previous one.\n\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] += diffs[ pointer ][ 1 ];\n\t\t\t\t\tdiffs.splice( pointer, 1 );\n\t\t\t\t} else {\n\t\t\t\t\tpointer++;\n\t\t\t\t}\n\t\t\t\tcountInsert = 0;\n\t\t\t\tcountDelete = 0;\n\t\t\t\ttextDelete = \"\";\n\t\t\t\ttextInsert = \"\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ( diffs[ diffs.length - 1 ][ 1 ] === \"\" ) {\n\t\t\tdiffs.pop(); // Remove the dummy entry at the end.\n\t\t}\n\n\t\t// Second pass: look for single edits surrounded on both sides by equalities\n\t\t// which can be shifted sideways to eliminate an equality.\n\t\t// e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n\t\tchanges = false;\n\t\tpointer = 1;\n\n\t\t// Intentionally ignore the first and last element (don't need checking).\n\t\twhile ( pointer < diffs.length - 1 ) {\n\t\t\tif ( diffs[ pointer - 1 ][ 0 ] === DIFF_EQUAL &&\n\t\t\t\t\tdiffs[ pointer + 1 ][ 0 ] === DIFF_EQUAL ) {\n\n\t\t\t\tdiffPointer = diffs[ pointer ][ 1 ];\n\t\t\t\tposition = diffPointer.substring(\n\t\t\t\t\tdiffPointer.length - diffs[ pointer - 1 ][ 1 ].length\n\t\t\t\t);\n\n\t\t\t\t// This is a single edit surrounded by equalities.\n\t\t\t\tif ( position === diffs[ pointer - 1 ][ 1 ] ) {\n\n\t\t\t\t\t// Shift the edit over the previous equality.\n\t\t\t\t\tdiffs[ pointer ][ 1 ] = diffs[ pointer - 1 ][ 1 ] +\n\t\t\t\t\t\tdiffs[ pointer ][ 1 ].substring( 0, diffs[ pointer ][ 1 ].length -\n\t\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ].length );\n\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] =\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] + diffs[ pointer + 1 ][ 1 ];\n\t\t\t\t\tdiffs.splice( pointer - 1, 1 );\n\t\t\t\t\tchanges = true;\n\t\t\t\t} else if ( diffPointer.substring( 0, diffs[ pointer + 1 ][ 1 ].length ) ===\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] ) {\n\n\t\t\t\t\t// Shift the edit over the next equality.\n\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] += diffs[ pointer + 1 ][ 1 ];\n\t\t\t\t\tdiffs[ pointer ][ 1 ] =\n\t\t\t\t\t\tdiffs[ pointer ][ 1 ].substring( diffs[ pointer + 1 ][ 1 ].length ) +\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ];\n\t\t\t\t\tdiffs.splice( pointer + 1, 1 );\n\t\t\t\t\tchanges = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\t\t// If shifts were made, the diff needs reordering and another shift sweep.\n\t\tif ( changes ) {\n\t\t\tthis.diffCleanupMerge( diffs );\n\t\t}\n\t};\n\n\treturn function( o, n ) {\n\t\tvar diff, output, text;\n\t\tdiff = new DiffMatchPatch();\n\t\toutput = diff.DiffMain( o, n );\n\t\tdiff.diffCleanupEfficiency( output );\n\t\ttext = diff.diffPrettyHtml( output );\n\n\t\treturn text;\n\t};\n}() );\n\n// Get a reference to the global object, like window in browsers\n}( (function() {\n\treturn this;\n})() ));\n\n(function() {\n\n// Don't load the HTML Reporter on non-Browser environments\nif ( typeof window === \"undefined\" || !window.document ) {\n\treturn;\n}\n\n// Deprecated QUnit.init - Ref #530\n// Re-initialize the configuration options\nQUnit.init = function() {\n\tvar tests, banner, result, qunit,\n\t\tconfig = QUnit.config;\n\n\tconfig.stats = { all: 0, bad: 0 };\n\tconfig.moduleStats = { all: 0, bad: 0 };\n\tconfig.started = 0;\n\tconfig.updateRate = 1000;\n\tconfig.blocking = false;\n\tconfig.autostart = true;\n\tconfig.autorun = false;\n\tconfig.filter = \"\";\n\tconfig.queue = [];\n\n\t// Return on non-browser environments\n\t// This is necessary to not break on node tests\n\tif ( typeof window === \"undefined\" ) {\n\t\treturn;\n\t}\n\n\tqunit = id( \"qunit\" );\n\tif ( qunit ) {\n\t\tqunit.innerHTML =\n\t\t\t\"<h1 id='qunit-header'>\" + escapeText( document.title ) + \"</h1>\" +\n\t\t\t\"<h2 id='qunit-banner'></h2>\" +\n\t\t\t\"<div id='qunit-testrunner-toolbar'></div>\" +\n\t\t\t\"<h2 id='qunit-userAgent'></h2>\" +\n\t\t\t\"<ol id='qunit-tests'></ol>\";\n\t}\n\n\ttests = id( \"qunit-tests\" );\n\tbanner = id( \"qunit-banner\" );\n\tresult = id( \"qunit-testresult\" );\n\n\tif ( tests ) {\n\t\ttests.innerHTML = \"\";\n\t}\n\n\tif ( banner ) {\n\t\tbanner.className = \"\";\n\t}\n\n\tif ( result ) {\n\t\tresult.parentNode.removeChild( result );\n\t}\n\n\tif ( tests ) {\n\t\tresult = document.createElement( \"p\" );\n\t\tresult.id = \"qunit-testresult\";\n\t\tresult.className = \"result\";\n\t\ttests.parentNode.insertBefore( result, tests );\n\t\tresult.innerHTML = \"Running...<br />&#160;\";\n\t}\n};\n\nvar config = QUnit.config,\n\thasOwn = Object.prototype.hasOwnProperty,\n\tdefined = {\n\t\tdocument: window.document !== undefined,\n\t\tsessionStorage: (function() {\n\t\t\tvar x = \"qunit-test-string\";\n\t\t\ttry {\n\t\t\t\tsessionStorage.setItem( x, x );\n\t\t\t\tsessionStorage.removeItem( x );\n\t\t\t\treturn true;\n\t\t\t} catch ( e ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}())\n\t},\n\tmodulesList = [];\n\n/**\n* Escape text for attribute or text content.\n*/\nfunction escapeText( s ) {\n\tif ( !s ) {\n\t\treturn \"\";\n\t}\n\ts = s + \"\";\n\n\t// Both single quotes and double quotes (for attributes)\n\treturn s.replace( /['\"<>&]/g, function( s ) {\n\t\tswitch ( s ) {\n\t\tcase \"'\":\n\t\t\treturn \"&#039;\";\n\t\tcase \"\\\"\":\n\t\t\treturn \"&quot;\";\n\t\tcase \"<\":\n\t\t\treturn \"&lt;\";\n\t\tcase \">\":\n\t\t\treturn \"&gt;\";\n\t\tcase \"&\":\n\t\t\treturn \"&amp;\";\n\t\t}\n\t});\n}\n\n/**\n * @param {HTMLElement} elem\n * @param {string} type\n * @param {Function} fn\n */\nfunction addEvent( elem, type, fn ) {\n\tif ( elem.addEventListener ) {\n\n\t\t// Standards-based browsers\n\t\telem.addEventListener( type, fn, false );\n\t} else if ( elem.attachEvent ) {\n\n\t\t// support: IE <9\n\t\telem.attachEvent( \"on\" + type, function() {\n\t\t\tvar event = window.event;\n\t\t\tif ( !event.target ) {\n\t\t\t\tevent.target = event.srcElement || document;\n\t\t\t}\n\n\t\t\tfn.call( elem, event );\n\t\t});\n\t}\n}\n\n/**\n * @param {Array|NodeList} elems\n * @param {string} type\n * @param {Function} fn\n */\nfunction addEvents( elems, type, fn ) {\n\tvar i = elems.length;\n\twhile ( i-- ) {\n\t\taddEvent( elems[ i ], type, fn );\n\t}\n}\n\nfunction hasClass( elem, name ) {\n\treturn ( \" \" + elem.className + \" \" ).indexOf( \" \" + name + \" \" ) >= 0;\n}\n\nfunction addClass( elem, name ) {\n\tif ( !hasClass( elem, name ) ) {\n\t\telem.className += ( elem.className ? \" \" : \"\" ) + name;\n\t}\n}\n\nfunction toggleClass( elem, name ) {\n\tif ( hasClass( elem, name ) ) {\n\t\tremoveClass( elem, name );\n\t} else {\n\t\taddClass( elem, name );\n\t}\n}\n\nfunction removeClass( elem, name ) {\n\tvar set = \" \" + elem.className + \" \";\n\n\t// Class name may appear multiple times\n\twhile ( set.indexOf( \" \" + name + \" \" ) >= 0 ) {\n\t\tset = set.replace( \" \" + name + \" \", \" \" );\n\t}\n\n\t// trim for prettiness\n\telem.className = typeof set.trim === \"function\" ? set.trim() : set.replace( /^\\s+|\\s+$/g, \"\" );\n}\n\nfunction id( name ) {\n\treturn defined.document && document.getElementById && document.getElementById( name );\n}\n\nfunction getUrlConfigHtml() {\n\tvar i, j, val,\n\t\tescaped, escapedTooltip,\n\t\tselection = false,\n\t\tlen = config.urlConfig.length,\n\t\turlConfigHtml = \"\";\n\n\tfor ( i = 0; i < len; i++ ) {\n\t\tval = config.urlConfig[ i ];\n\t\tif ( typeof val === \"string\" ) {\n\t\t\tval = {\n\t\t\t\tid: val,\n\t\t\t\tlabel: val\n\t\t\t};\n\t\t}\n\n\t\tescaped = escapeText( val.id );\n\t\tescapedTooltip = escapeText( val.tooltip );\n\n\t\tif ( config[ val.id ] === undefined ) {\n\t\t\tconfig[ val.id ] = QUnit.urlParams[ val.id ];\n\t\t}\n\n\t\tif ( !val.value || typeof val.value === \"string\" ) {\n\t\t\turlConfigHtml += \"<input id='qunit-urlconfig-\" + escaped +\n\t\t\t\t\"' name='\" + escaped + \"' type='checkbox'\" +\n\t\t\t\t( val.value ? \" value='\" + escapeText( val.value ) + \"'\" : \"\" ) +\n\t\t\t\t( config[ val.id ] ? \" checked='checked'\" : \"\" ) +\n\t\t\t\t\" title='\" + escapedTooltip + \"' /><label for='qunit-urlconfig-\" + escaped +\n\t\t\t\t\"' title='\" + escapedTooltip + \"'>\" + val.label + \"</label>\";\n\t\t} else {\n\t\t\turlConfigHtml += \"<label for='qunit-urlconfig-\" + escaped +\n\t\t\t\t\"' title='\" + escapedTooltip + \"'>\" + val.label +\n\t\t\t\t\": </label><select id='qunit-urlconfig-\" + escaped +\n\t\t\t\t\"' name='\" + escaped + \"' title='\" + escapedTooltip + \"'><option></option>\";\n\n\t\t\tif ( QUnit.is( \"array\", val.value ) ) {\n\t\t\t\tfor ( j = 0; j < val.value.length; j++ ) {\n\t\t\t\t\tescaped = escapeText( val.value[ j ] );\n\t\t\t\t\turlConfigHtml += \"<option value='\" + escaped + \"'\" +\n\t\t\t\t\t\t( config[ val.id ] === val.value[ j ] ?\n\t\t\t\t\t\t\t( selection = true ) && \" selected='selected'\" : \"\" ) +\n\t\t\t\t\t\t\">\" + escaped + \"</option>\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( j in val.value ) {\n\t\t\t\t\tif ( hasOwn.call( val.value, j ) ) {\n\t\t\t\t\t\turlConfigHtml += \"<option value='\" + escapeText( j ) + \"'\" +\n\t\t\t\t\t\t\t( config[ val.id ] === j ?\n\t\t\t\t\t\t\t\t( selection = true ) && \" selected='selected'\" : \"\" ) +\n\t\t\t\t\t\t\t\">\" + escapeText( val.value[ j ] ) + \"</option>\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( config[ val.id ] && !selection ) {\n\t\t\t\tescaped = escapeText( config[ val.id ] );\n\t\t\t\turlConfigHtml += \"<option value='\" + escaped +\n\t\t\t\t\t\"' selected='selected' disabled='disabled'>\" + escaped + \"</option>\";\n\t\t\t}\n\t\t\turlConfigHtml += \"</select>\";\n\t\t}\n\t}\n\n\treturn urlConfigHtml;\n}\n\n// Handle \"click\" events on toolbar checkboxes and \"change\" for select menus.\n// Updates the URL with the new state of `config.urlConfig` values.\nfunction toolbarChanged() {\n\tvar updatedUrl, value,\n\t\tfield = this,\n\t\tparams = {};\n\n\t// Detect if field is a select menu or a checkbox\n\tif ( \"selectedIndex\" in field ) {\n\t\tvalue = field.options[ field.selectedIndex ].value || undefined;\n\t} else {\n\t\tvalue = field.checked ? ( field.defaultValue || true ) : undefined;\n\t}\n\n\tparams[ field.name ] = value;\n\tupdatedUrl = setUrl( params );\n\n\tif ( \"hidepassed\" === field.name && \"replaceState\" in window.history ) {\n\t\tconfig[ field.name ] = value || false;\n\t\tif ( value ) {\n\t\t\taddClass( id( \"qunit-tests\" ), \"hidepass\" );\n\t\t} else {\n\t\t\tremoveClass( id( \"qunit-tests\" ), \"hidepass\" );\n\t\t}\n\n\t\t// It is not necessary to refresh the whole page\n\t\twindow.history.replaceState( null, \"\", updatedUrl );\n\t} else {\n\t\twindow.location = updatedUrl;\n\t}\n}\n\nfunction setUrl( params ) {\n\tvar key,\n\t\tquerystring = \"?\";\n\n\tparams = QUnit.extend( QUnit.extend( {}, QUnit.urlParams ), params );\n\n\tfor ( key in params ) {\n\t\tif ( hasOwn.call( params, key ) ) {\n\t\t\tif ( params[ key ] === undefined ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tquerystring += encodeURIComponent( key );\n\t\t\tif ( params[ key ] !== true ) {\n\t\t\t\tquerystring += \"=\" + encodeURIComponent( params[ key ] );\n\t\t\t}\n\t\t\tquerystring += \"&\";\n\t\t}\n\t}\n\treturn location.protocol + \"//\" + location.host +\n\t\tlocation.pathname + querystring.slice( 0, -1 );\n}\n\nfunction applyUrlParams() {\n\tvar selectedModule,\n\t\tmodulesList = id( \"qunit-modulefilter\" ),\n\t\tfilter = id( \"qunit-filter-input\" ).value;\n\n\tselectedModule = modulesList ?\n\t\tdecodeURIComponent( modulesList.options[ modulesList.selectedIndex ].value ) :\n\t\tundefined;\n\n\twindow.location = setUrl({\n\t\tmodule: ( selectedModule === \"\" ) ? undefined : selectedModule,\n\t\tfilter: ( filter === \"\" ) ? undefined : filter,\n\n\t\t// Remove testId filter\n\t\ttestId: undefined\n\t});\n}\n\nfunction toolbarUrlConfigContainer() {\n\tvar urlConfigContainer = document.createElement( \"span\" );\n\n\turlConfigContainer.innerHTML = getUrlConfigHtml();\n\taddClass( urlConfigContainer, \"qunit-url-config\" );\n\n\t// For oldIE support:\n\t// * Add handlers to the individual elements instead of the container\n\t// * Use \"click\" instead of \"change\" for checkboxes\n\taddEvents( urlConfigContainer.getElementsByTagName( \"input\" ), \"click\", toolbarChanged );\n\taddEvents( urlConfigContainer.getElementsByTagName( \"select\" ), \"change\", toolbarChanged );\n\n\treturn urlConfigContainer;\n}\n\nfunction toolbarLooseFilter() {\n\tvar filter = document.createElement( \"form\" ),\n\t\tlabel = document.createElement( \"label\" ),\n\t\tinput = document.createElement( \"input\" ),\n\t\tbutton = document.createElement( \"button\" );\n\n\taddClass( filter, \"qunit-filter\" );\n\n\tlabel.innerHTML = \"Filter: \";\n\n\tinput.type = \"text\";\n\tinput.value = config.filter || \"\";\n\tinput.name = \"filter\";\n\tinput.id = \"qunit-filter-input\";\n\n\tbutton.innerHTML = \"Go\";\n\n\tlabel.appendChild( input );\n\n\tfilter.appendChild( label );\n\tfilter.appendChild( button );\n\taddEvent( filter, \"submit\", function( ev ) {\n\t\tapplyUrlParams();\n\n\t\tif ( ev && ev.preventDefault ) {\n\t\t\tev.preventDefault();\n\t\t}\n\n\t\treturn false;\n\t});\n\n\treturn filter;\n}\n\nfunction toolbarModuleFilterHtml() {\n\tvar i,\n\t\tmoduleFilterHtml = \"\";\n\n\tif ( !modulesList.length ) {\n\t\treturn false;\n\t}\n\n\tmodulesList.sort(function( a, b ) {\n\t\treturn a.localeCompare( b );\n\t});\n\n\tmoduleFilterHtml += \"<label for='qunit-modulefilter'>Module: </label>\" +\n\t\t\"<select id='qunit-modulefilter' name='modulefilter'><option value='' \" +\n\t\t( QUnit.urlParams.module === undefined ? \"selected='selected'\" : \"\" ) +\n\t\t\">< All Modules ></option>\";\n\n\tfor ( i = 0; i < modulesList.length; i++ ) {\n\t\tmoduleFilterHtml += \"<option value='\" +\n\t\t\tescapeText( encodeURIComponent( modulesList[ i ] ) ) + \"' \" +\n\t\t\t( QUnit.urlParams.module === modulesList[ i ] ? \"selected='selected'\" : \"\" ) +\n\t\t\t\">\" + escapeText( modulesList[ i ] ) + \"</option>\";\n\t}\n\tmoduleFilterHtml += \"</select>\";\n\n\treturn moduleFilterHtml;\n}\n\nfunction toolbarModuleFilter() {\n\tvar toolbar = id( \"qunit-testrunner-toolbar\" ),\n\t\tmoduleFilter = document.createElement( \"span\" ),\n\t\tmoduleFilterHtml = toolbarModuleFilterHtml();\n\n\tif ( !toolbar || !moduleFilterHtml ) {\n\t\treturn false;\n\t}\n\n\tmoduleFilter.setAttribute( \"id\", \"qunit-modulefilter-container\" );\n\tmoduleFilter.innerHTML = moduleFilterHtml;\n\n\taddEvent( moduleFilter.lastChild, \"change\", applyUrlParams );\n\n\ttoolbar.appendChild( moduleFilter );\n}\n\nfunction appendToolbar() {\n\tvar toolbar = id( \"qunit-testrunner-toolbar\" );\n\n\tif ( toolbar ) {\n\t\ttoolbar.appendChild( toolbarUrlConfigContainer() );\n\t\ttoolbar.appendChild( toolbarLooseFilter() );\n\t}\n}\n\nfunction appendHeader() {\n\tvar header = id( \"qunit-header\" );\n\n\tif ( header ) {\n\t\theader.innerHTML = \"<a href='\" +\n\t\t\tsetUrl({ filter: undefined, module: undefined, testId: undefined }) +\n\t\t\t\"'>\" + header.innerHTML + \"</a> \";\n\t}\n}\n\nfunction appendBanner() {\n\tvar banner = id( \"qunit-banner\" );\n\n\tif ( banner ) {\n\t\tbanner.className = \"\";\n\t}\n}\n\nfunction appendTestResults() {\n\tvar tests = id( \"qunit-tests\" ),\n\t\tresult = id( \"qunit-testresult\" );\n\n\tif ( result ) {\n\t\tresult.parentNode.removeChild( result );\n\t}\n\n\tif ( tests ) {\n\t\ttests.innerHTML = \"\";\n\t\tresult = document.createElement( \"p\" );\n\t\tresult.id = \"qunit-testresult\";\n\t\tresult.className = \"result\";\n\t\ttests.parentNode.insertBefore( result, tests );\n\t\tresult.innerHTML = \"Running...<br />&#160;\";\n\t}\n}\n\nfunction storeFixture() {\n\tvar fixture = id( \"qunit-fixture\" );\n\tif ( fixture ) {\n\t\tconfig.fixture = fixture.innerHTML;\n\t}\n}\n\nfunction appendUserAgent() {\n\tvar userAgent = id( \"qunit-userAgent\" );\n\n\tif ( userAgent ) {\n\t\tuserAgent.innerHTML = \"\";\n\t\tuserAgent.appendChild(\n\t\t\tdocument.createTextNode(\n\t\t\t\t\"QUnit \" + QUnit.version  + \"; \" + navigator.userAgent\n\t\t\t)\n\t\t);\n\t}\n}\n\nfunction appendTestsList( modules ) {\n\tvar i, l, x, z, test, moduleObj;\n\n\tfor ( i = 0, l = modules.length; i < l; i++ ) {\n\t\tmoduleObj = modules[ i ];\n\n\t\tif ( moduleObj.name ) {\n\t\t\tmodulesList.push( moduleObj.name );\n\t\t}\n\n\t\tfor ( x = 0, z = moduleObj.tests.length; x < z; x++ ) {\n\t\t\ttest = moduleObj.tests[ x ];\n\n\t\t\tappendTest( test.name, test.testId, moduleObj.name );\n\t\t}\n\t}\n}\n\nfunction appendTest( name, testId, moduleName ) {\n\tvar title, rerunTrigger, testBlock, assertList,\n\t\ttests = id( \"qunit-tests\" );\n\n\tif ( !tests ) {\n\t\treturn;\n\t}\n\n\ttitle = document.createElement( \"strong\" );\n\ttitle.innerHTML = getNameHtml( name, moduleName );\n\n\trerunTrigger = document.createElement( \"a\" );\n\trerunTrigger.innerHTML = \"Rerun\";\n\trerunTrigger.href = setUrl({ testId: testId });\n\n\ttestBlock = document.createElement( \"li\" );\n\ttestBlock.appendChild( title );\n\ttestBlock.appendChild( rerunTrigger );\n\ttestBlock.id = \"qunit-test-output-\" + testId;\n\n\tassertList = document.createElement( \"ol\" );\n\tassertList.className = \"qunit-assert-list\";\n\n\ttestBlock.appendChild( assertList );\n\n\ttests.appendChild( testBlock );\n}\n\n// HTML Reporter initialization and load\nQUnit.begin(function( details ) {\n\tvar qunit = id( \"qunit\" );\n\n\t// Fixture is the only one necessary to run without the #qunit element\n\tstoreFixture();\n\n\tif ( qunit ) {\n\t\tqunit.innerHTML =\n\t\t\t\"<h1 id='qunit-header'>\" + escapeText( document.title ) + \"</h1>\" +\n\t\t\t\"<h2 id='qunit-banner'></h2>\" +\n\t\t\t\"<div id='qunit-testrunner-toolbar'></div>\" +\n\t\t\t\"<h2 id='qunit-userAgent'></h2>\" +\n\t\t\t\"<ol id='qunit-tests'></ol>\";\n\t}\n\n\tappendHeader();\n\tappendBanner();\n\tappendTestResults();\n\tappendUserAgent();\n\tappendToolbar();\n\tappendTestsList( details.modules );\n\ttoolbarModuleFilter();\n\n\tif ( qunit && config.hidepassed ) {\n\t\taddClass( qunit.lastChild, \"hidepass\" );\n\t}\n});\n\nQUnit.done(function( details ) {\n\tvar i, key,\n\t\tbanner = id( \"qunit-banner\" ),\n\t\ttests = id( \"qunit-tests\" ),\n\t\thtml = [\n\t\t\t\"Tests completed in \",\n\t\t\tdetails.runtime,\n\t\t\t\" milliseconds.<br />\",\n\t\t\t\"<span class='passed'>\",\n\t\t\tdetails.passed,\n\t\t\t\"</span> assertions of <span class='total'>\",\n\t\t\tdetails.total,\n\t\t\t\"</span> passed, <span class='failed'>\",\n\t\t\tdetails.failed,\n\t\t\t\"</span> failed.\"\n\t\t].join( \"\" );\n\n\tif ( banner ) {\n\t\tbanner.className = details.failed ? \"qunit-fail\" : \"qunit-pass\";\n\t}\n\n\tif ( tests ) {\n\t\tid( \"qunit-testresult\" ).innerHTML = html;\n\t}\n\n\tif ( config.altertitle && defined.document && document.title ) {\n\n\t\t// show ✖ for good, ✔ for bad suite result in title\n\t\t// use escape sequences in case file gets loaded with non-utf-8-charset\n\t\tdocument.title = [\n\t\t\t( details.failed ? \"\\u2716\" : \"\\u2714\" ),\n\t\t\tdocument.title.replace( /^[\\u2714\\u2716] /i, \"\" )\n\t\t].join( \" \" );\n\t}\n\n\t// clear own sessionStorage items if all tests passed\n\tif ( config.reorder && defined.sessionStorage && details.failed === 0 ) {\n\t\tfor ( i = 0; i < sessionStorage.length; i++ ) {\n\t\t\tkey = sessionStorage.key( i++ );\n\t\t\tif ( key.indexOf( \"qunit-test-\" ) === 0 ) {\n\t\t\t\tsessionStorage.removeItem( key );\n\t\t\t}\n\t\t}\n\t}\n\n\t// scroll back to top to show results\n\tif ( config.scrolltop && window.scrollTo ) {\n\t\twindow.scrollTo( 0, 0 );\n\t}\n});\n\nfunction getNameHtml( name, module ) {\n\tvar nameHtml = \"\";\n\n\tif ( module ) {\n\t\tnameHtml = \"<span class='module-name'>\" + escapeText( module ) + \"</span>: \";\n\t}\n\n\tnameHtml += \"<span class='test-name'>\" + escapeText( name ) + \"</span>\";\n\n\treturn nameHtml;\n}\n\nQUnit.testStart(function( details ) {\n\tvar running, testBlock, bad;\n\n\ttestBlock = id( \"qunit-test-output-\" + details.testId );\n\tif ( testBlock ) {\n\t\ttestBlock.className = \"running\";\n\t} else {\n\n\t\t// Report later registered tests\n\t\tappendTest( details.name, details.testId, details.module );\n\t}\n\n\trunning = id( \"qunit-testresult\" );\n\tif ( running ) {\n\t\tbad = QUnit.config.reorder && defined.sessionStorage &&\n\t\t\t+sessionStorage.getItem( \"qunit-test-\" + details.module + \"-\" + details.name );\n\n\t\trunning.innerHTML = ( bad ?\n\t\t\t\"Rerunning previously failed test: <br />\" :\n\t\t\t\"Running: <br />\" ) +\n\t\t\tgetNameHtml( details.name, details.module );\n\t}\n\n});\n\nfunction stripHtml( string ) {\n\t// strip tags, html entity and whitespaces\n\treturn string.replace(/<\\/?[^>]+(>|$)/g, \"\").replace(/\\&quot;/g, \"\").replace(/\\s+/g, \"\");\n}\n\nQUnit.log(function( details ) {\n\tvar assertList, assertLi,\n\t\tmessage, expected, actual, diff,\n\t\tshowDiff = false,\n\t\ttestItem = id( \"qunit-test-output-\" + details.testId );\n\n\tif ( !testItem ) {\n\t\treturn;\n\t}\n\n\tmessage = escapeText( details.message ) || ( details.result ? \"okay\" : \"failed\" );\n\tmessage = \"<span class='test-message'>\" + message + \"</span>\";\n\tmessage += \"<span class='runtime'>@ \" + details.runtime + \" ms</span>\";\n\n\t// pushFailure doesn't provide details.expected\n\t// when it calls, it's implicit to also not show expected and diff stuff\n\t// Also, we need to check details.expected existence, as it can exist and be undefined\n\tif ( !details.result && hasOwn.call( details, \"expected\" ) ) {\n\t\tif ( details.negative ) {\n\t\t\texpected = escapeText( \"NOT \" + QUnit.dump.parse( details.expected ) );\n\t\t} else {\n\t\t\texpected = escapeText( QUnit.dump.parse( details.expected ) );\n\t\t}\n\n\t\tactual = escapeText( QUnit.dump.parse( details.actual ) );\n\t\tmessage += \"<table><tr class='test-expected'><th>Expected: </th><td><pre>\" +\n\t\t\texpected +\n\t\t\t\"</pre></td></tr>\";\n\n\t\tif ( actual !== expected ) {\n\n\t\t\tmessage += \"<tr class='test-actual'><th>Result: </th><td><pre>\" +\n\t\t\t\tactual + \"</pre></td></tr>\";\n\n\t\t\t// Don't show diff if actual or expected are booleans\n\t\t\tif ( !( /^(true|false)$/.test( actual ) ) &&\n\t\t\t\t\t!( /^(true|false)$/.test( expected ) ) ) {\n\t\t\t\tdiff = QUnit.diff( expected, actual );\n\t\t\t\tshowDiff = stripHtml( diff ).length !==\n\t\t\t\t\tstripHtml( expected ).length +\n\t\t\t\t\tstripHtml( actual ).length;\n\t\t\t}\n\n\t\t\t// Don't show diff if expected and actual are totally different\n\t\t\tif ( showDiff ) {\n\t\t\t\tmessage += \"<tr class='test-diff'><th>Diff: </th><td><pre>\" +\n\t\t\t\t\tdiff + \"</pre></td></tr>\";\n\t\t\t}\n\t\t} else if ( expected.indexOf( \"[object Array]\" ) !== -1 ||\n\t\t\t\texpected.indexOf( \"[object Object]\" ) !== -1 ) {\n\t\t\tmessage += \"<tr class='test-message'><th>Message: </th><td>\" +\n\t\t\t\t\"Diff suppressed as the depth of object is more than current max depth (\" +\n\t\t\t\tQUnit.config.maxDepth + \").<p>Hint: Use <code>QUnit.dump.maxDepth</code> to \" +\n\t\t\t\t\" run with a higher max depth or <a href='\" + setUrl({ maxDepth: -1 }) + \"'>\" +\n\t\t\t\t\"Rerun</a> without max depth.</p></td></tr>\";\n\t\t}\n\n\t\tif ( details.source ) {\n\t\t\tmessage += \"<tr class='test-source'><th>Source: </th><td><pre>\" +\n\t\t\t\tescapeText( details.source ) + \"</pre></td></tr>\";\n\t\t}\n\n\t\tmessage += \"</table>\";\n\n\t// this occours when pushFailure is set and we have an extracted stack trace\n\t} else if ( !details.result && details.source ) {\n\t\tmessage += \"<table>\" +\n\t\t\t\"<tr class='test-source'><th>Source: </th><td><pre>\" +\n\t\t\tescapeText( details.source ) + \"</pre></td></tr>\" +\n\t\t\t\"</table>\";\n\t}\n\n\tassertList = testItem.getElementsByTagName( \"ol\" )[ 0 ];\n\n\tassertLi = document.createElement( \"li\" );\n\tassertLi.className = details.result ? \"pass\" : \"fail\";\n\tassertLi.innerHTML = message;\n\tassertList.appendChild( assertLi );\n});\n\nQUnit.testDone(function( details ) {\n\tvar testTitle, time, testItem, assertList,\n\t\tgood, bad, testCounts, skipped, sourceName,\n\t\ttests = id( \"qunit-tests\" );\n\n\tif ( !tests ) {\n\t\treturn;\n\t}\n\n\ttestItem = id( \"qunit-test-output-\" + details.testId );\n\n\tassertList = testItem.getElementsByTagName( \"ol\" )[ 0 ];\n\n\tgood = details.passed;\n\tbad = details.failed;\n\n\t// store result when possible\n\tif ( config.reorder && defined.sessionStorage ) {\n\t\tif ( bad ) {\n\t\t\tsessionStorage.setItem( \"qunit-test-\" + details.module + \"-\" + details.name, bad );\n\t\t} else {\n\t\t\tsessionStorage.removeItem( \"qunit-test-\" + details.module + \"-\" + details.name );\n\t\t}\n\t}\n\n\tif ( bad === 0 ) {\n\t\taddClass( assertList, \"qunit-collapsed\" );\n\t}\n\n\t// testItem.firstChild is the test name\n\ttestTitle = testItem.firstChild;\n\n\ttestCounts = bad ?\n\t\t\"<b class='failed'>\" + bad + \"</b>, \" + \"<b class='passed'>\" + good + \"</b>, \" :\n\t\t\"\";\n\n\ttestTitle.innerHTML += \" <b class='counts'>(\" + testCounts +\n\t\tdetails.assertions.length + \")</b>\";\n\n\tif ( details.skipped ) {\n\t\ttestItem.className = \"skipped\";\n\t\tskipped = document.createElement( \"em\" );\n\t\tskipped.className = \"qunit-skipped-label\";\n\t\tskipped.innerHTML = \"skipped\";\n\t\ttestItem.insertBefore( skipped, testTitle );\n\t} else {\n\t\taddEvent( testTitle, \"click\", function() {\n\t\t\ttoggleClass( assertList, \"qunit-collapsed\" );\n\t\t});\n\n\t\ttestItem.className = bad ? \"fail\" : \"pass\";\n\n\t\ttime = document.createElement( \"span\" );\n\t\ttime.className = \"runtime\";\n\t\ttime.innerHTML = details.runtime + \" ms\";\n\t\ttestItem.insertBefore( time, assertList );\n\t}\n\n\t// Show the source of the test when showing assertions\n\tif ( details.source ) {\n\t\tsourceName = document.createElement( \"p\" );\n\t\tsourceName.innerHTML = \"<strong>Source: </strong>\" + details.source;\n\t\taddClass( sourceName, \"qunit-source\" );\n\t\tif ( bad === 0 ) {\n\t\t\taddClass( sourceName, \"qunit-collapsed\" );\n\t\t}\n\t\taddEvent( testTitle, \"click\", function() {\n\t\t\ttoggleClass( sourceName, \"qunit-collapsed\" );\n\t\t});\n\t\ttestItem.appendChild( sourceName );\n\t}\n});\n\nif ( defined.document ) {\n\n\t// Avoid readyState issue with phantomjs\n\t// Ref: #818\n\tvar notPhantom = ( function( p ) {\n\t\treturn !( p && p.version && p.version.major > 0 );\n\t} )( window.phantom );\n\n\tif ( notPhantom && document.readyState === \"complete\" ) {\n\t\tQUnit.load();\n\t} else {\n\t\taddEvent( window, \"load\", QUnit.load );\n\t}\n} else {\n\tconfig.pageLoaded = true;\n\tconfig.autorun = true;\n}\n\n})();\n",
    "/**\n * @license\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n// @version 0.7.2\nwindow.WebComponents = window.WebComponents || {};\n\n(function(scope) {\n  var flags = scope.flags || {};\n  var file = \"webcomponents.js\";\n  var script = document.querySelector('script[src*=\"' + file + '\"]');\n  if (!flags.noOpts) {\n    location.search.slice(1).split(\"&\").forEach(function(option) {\n      var parts = option.split(\"=\");\n      var match;\n      if (parts[0] && (match = parts[0].match(/wc-(.+)/))) {\n        flags[match[1]] = parts[1] || true;\n      }\n    });\n    if (script) {\n      for (var i = 0, a; a = script.attributes[i]; i++) {\n        if (a.name !== \"src\") {\n          flags[a.name] = a.value || true;\n        }\n      }\n    }\n    if (flags.log && flags.log.split) {\n      var parts = flags.log.split(\",\");\n      flags.log = {};\n      parts.forEach(function(f) {\n        flags.log[f] = true;\n      });\n    } else {\n      flags.log = {};\n    }\n  }\n  flags.shadow = flags.shadow || flags.shadowdom || flags.polyfill;\n  if (flags.shadow === \"native\") {\n    flags.shadow = false;\n  } else {\n    flags.shadow = flags.shadow || !HTMLElement.prototype.createShadowRoot;\n  }\n  if (flags.register) {\n    window.CustomElements = window.CustomElements || {\n      flags: {}\n    };\n    window.CustomElements.flags.register = flags.register;\n  }\n  scope.flags = flags;\n})(WebComponents);\n\nif (WebComponents.flags.shadow) {\n  if (typeof WeakMap === \"undefined\") {\n    (function() {\n      var defineProperty = Object.defineProperty;\n      var counter = Date.now() % 1e9;\n      var WeakMap = function() {\n        this.name = \"__st\" + (Math.random() * 1e9 >>> 0) + (counter++ + \"__\");\n      };\n      WeakMap.prototype = {\n        set: function(key, value) {\n          var entry = key[this.name];\n          if (entry && entry[0] === key) entry[1] = value; else defineProperty(key, this.name, {\n            value: [ key, value ],\n            writable: true\n          });\n          return this;\n        },\n        get: function(key) {\n          var entry;\n          return (entry = key[this.name]) && entry[0] === key ? entry[1] : undefined;\n        },\n        \"delete\": function(key) {\n          var entry = key[this.name];\n          if (!entry || entry[0] !== key) return false;\n          entry[0] = entry[1] = undefined;\n          return true;\n        },\n        has: function(key) {\n          var entry = key[this.name];\n          if (!entry) return false;\n          return entry[0] === key;\n        }\n      };\n      window.WeakMap = WeakMap;\n    })();\n  }\n  window.ShadowDOMPolyfill = {};\n  (function(scope) {\n    \"use strict\";\n    var constructorTable = new WeakMap();\n    var nativePrototypeTable = new WeakMap();\n    var wrappers = Object.create(null);\n    function detectEval() {\n      if (typeof chrome !== \"undefined\" && chrome.app && chrome.app.runtime) {\n        return false;\n      }\n      if (navigator.getDeviceStorage) {\n        return false;\n      }\n      try {\n        var f = new Function(\"return true;\");\n        return f();\n      } catch (ex) {\n        return false;\n      }\n    }\n    var hasEval = detectEval();\n    function assert(b) {\n      if (!b) throw new Error(\"Assertion failed\");\n    }\n    var defineProperty = Object.defineProperty;\n    var getOwnPropertyNames = Object.getOwnPropertyNames;\n    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n    function mixin(to, from) {\n      var names = getOwnPropertyNames(from);\n      for (var i = 0; i < names.length; i++) {\n        var name = names[i];\n        defineProperty(to, name, getOwnPropertyDescriptor(from, name));\n      }\n      return to;\n    }\n    function mixinStatics(to, from) {\n      var names = getOwnPropertyNames(from);\n      for (var i = 0; i < names.length; i++) {\n        var name = names[i];\n        switch (name) {\n         case \"arguments\":\n         case \"caller\":\n         case \"length\":\n         case \"name\":\n         case \"prototype\":\n         case \"toString\":\n          continue;\n        }\n        defineProperty(to, name, getOwnPropertyDescriptor(from, name));\n      }\n      return to;\n    }\n    function oneOf(object, propertyNames) {\n      for (var i = 0; i < propertyNames.length; i++) {\n        if (propertyNames[i] in object) return propertyNames[i];\n      }\n    }\n    var nonEnumerableDataDescriptor = {\n      value: undefined,\n      configurable: true,\n      enumerable: false,\n      writable: true\n    };\n    function defineNonEnumerableDataProperty(object, name, value) {\n      nonEnumerableDataDescriptor.value = value;\n      defineProperty(object, name, nonEnumerableDataDescriptor);\n    }\n    getOwnPropertyNames(window);\n    function getWrapperConstructor(node) {\n      var nativePrototype = node.__proto__ || Object.getPrototypeOf(node);\n      if (isFirefox) {\n        try {\n          getOwnPropertyNames(nativePrototype);\n        } catch (error) {\n          nativePrototype = nativePrototype.__proto__;\n        }\n      }\n      var wrapperConstructor = constructorTable.get(nativePrototype);\n      if (wrapperConstructor) return wrapperConstructor;\n      var parentWrapperConstructor = getWrapperConstructor(nativePrototype);\n      var GeneratedWrapper = createWrapperConstructor(parentWrapperConstructor);\n      registerInternal(nativePrototype, GeneratedWrapper, node);\n      return GeneratedWrapper;\n    }\n    function addForwardingProperties(nativePrototype, wrapperPrototype) {\n      installProperty(nativePrototype, wrapperPrototype, true);\n    }\n    function registerInstanceProperties(wrapperPrototype, instanceObject) {\n      installProperty(instanceObject, wrapperPrototype, false);\n    }\n    var isFirefox = /Firefox/.test(navigator.userAgent);\n    var dummyDescriptor = {\n      get: function() {},\n      set: function(v) {},\n      configurable: true,\n      enumerable: true\n    };\n    function isEventHandlerName(name) {\n      return /^on[a-z]+$/.test(name);\n    }\n    function isIdentifierName(name) {\n      return /^[a-zA-Z_$][a-zA-Z_$0-9]*$/.test(name);\n    }\n    function getGetter(name) {\n      return hasEval && isIdentifierName(name) ? new Function(\"return this.__impl4cf1e782hg__.\" + name) : function() {\n        return this.__impl4cf1e782hg__[name];\n      };\n    }\n    function getSetter(name) {\n      return hasEval && isIdentifierName(name) ? new Function(\"v\", \"this.__impl4cf1e782hg__.\" + name + \" = v\") : function(v) {\n        this.__impl4cf1e782hg__[name] = v;\n      };\n    }\n    function getMethod(name) {\n      return hasEval && isIdentifierName(name) ? new Function(\"return this.__impl4cf1e782hg__.\" + name + \".apply(this.__impl4cf1e782hg__, arguments)\") : function() {\n        return this.__impl4cf1e782hg__[name].apply(this.__impl4cf1e782hg__, arguments);\n      };\n    }\n    function getDescriptor(source, name) {\n      try {\n        return Object.getOwnPropertyDescriptor(source, name);\n      } catch (ex) {\n        return dummyDescriptor;\n      }\n    }\n    var isBrokenSafari = function() {\n      var descr = Object.getOwnPropertyDescriptor(Node.prototype, \"nodeType\");\n      return descr && !descr.get && !descr.set;\n    }();\n    function installProperty(source, target, allowMethod, opt_blacklist) {\n      var names = getOwnPropertyNames(source);\n      for (var i = 0; i < names.length; i++) {\n        var name = names[i];\n        if (name === \"polymerBlackList_\") continue;\n        if (name in target) continue;\n        if (source.polymerBlackList_ && source.polymerBlackList_[name]) continue;\n        if (isFirefox) {\n          source.__lookupGetter__(name);\n        }\n        var descriptor = getDescriptor(source, name);\n        var getter, setter;\n        if (allowMethod && typeof descriptor.value === \"function\") {\n          target[name] = getMethod(name);\n          continue;\n        }\n        var isEvent = isEventHandlerName(name);\n        if (isEvent) getter = scope.getEventHandlerGetter(name); else getter = getGetter(name);\n        if (descriptor.writable || descriptor.set || isBrokenSafari) {\n          if (isEvent) setter = scope.getEventHandlerSetter(name); else setter = getSetter(name);\n        }\n        var configurable = isBrokenSafari || descriptor.configurable;\n        defineProperty(target, name, {\n          get: getter,\n          set: setter,\n          configurable: configurable,\n          enumerable: descriptor.enumerable\n        });\n      }\n    }\n    function register(nativeConstructor, wrapperConstructor, opt_instance) {\n      if (nativeConstructor == null) {\n        return;\n      }\n      var nativePrototype = nativeConstructor.prototype;\n      registerInternal(nativePrototype, wrapperConstructor, opt_instance);\n      mixinStatics(wrapperConstructor, nativeConstructor);\n    }\n    function registerInternal(nativePrototype, wrapperConstructor, opt_instance) {\n      var wrapperPrototype = wrapperConstructor.prototype;\n      assert(constructorTable.get(nativePrototype) === undefined);\n      constructorTable.set(nativePrototype, wrapperConstructor);\n      nativePrototypeTable.set(wrapperPrototype, nativePrototype);\n      addForwardingProperties(nativePrototype, wrapperPrototype);\n      if (opt_instance) registerInstanceProperties(wrapperPrototype, opt_instance);\n      defineNonEnumerableDataProperty(wrapperPrototype, \"constructor\", wrapperConstructor);\n      wrapperConstructor.prototype = wrapperPrototype;\n    }\n    function isWrapperFor(wrapperConstructor, nativeConstructor) {\n      return constructorTable.get(nativeConstructor.prototype) === wrapperConstructor;\n    }\n    function registerObject(object) {\n      var nativePrototype = Object.getPrototypeOf(object);\n      var superWrapperConstructor = getWrapperConstructor(nativePrototype);\n      var GeneratedWrapper = createWrapperConstructor(superWrapperConstructor);\n      registerInternal(nativePrototype, GeneratedWrapper, object);\n      return GeneratedWrapper;\n    }\n    function createWrapperConstructor(superWrapperConstructor) {\n      function GeneratedWrapper(node) {\n        superWrapperConstructor.call(this, node);\n      }\n      var p = Object.create(superWrapperConstructor.prototype);\n      p.constructor = GeneratedWrapper;\n      GeneratedWrapper.prototype = p;\n      return GeneratedWrapper;\n    }\n    function isWrapper(object) {\n      return object && object.__impl4cf1e782hg__;\n    }\n    function isNative(object) {\n      return !isWrapper(object);\n    }\n    function wrap(impl) {\n      if (impl === null) return null;\n      assert(isNative(impl));\n      return impl.__wrapper8e3dd93a60__ || (impl.__wrapper8e3dd93a60__ = new (getWrapperConstructor(impl))(impl));\n    }\n    function unwrap(wrapper) {\n      if (wrapper === null) return null;\n      assert(isWrapper(wrapper));\n      return wrapper.__impl4cf1e782hg__;\n    }\n    function unsafeUnwrap(wrapper) {\n      return wrapper.__impl4cf1e782hg__;\n    }\n    function setWrapper(impl, wrapper) {\n      wrapper.__impl4cf1e782hg__ = impl;\n      impl.__wrapper8e3dd93a60__ = wrapper;\n    }\n    function unwrapIfNeeded(object) {\n      return object && isWrapper(object) ? unwrap(object) : object;\n    }\n    function wrapIfNeeded(object) {\n      return object && !isWrapper(object) ? wrap(object) : object;\n    }\n    function rewrap(node, wrapper) {\n      if (wrapper === null) return;\n      assert(isNative(node));\n      assert(wrapper === undefined || isWrapper(wrapper));\n      node.__wrapper8e3dd93a60__ = wrapper;\n    }\n    var getterDescriptor = {\n      get: undefined,\n      configurable: true,\n      enumerable: true\n    };\n    function defineGetter(constructor, name, getter) {\n      getterDescriptor.get = getter;\n      defineProperty(constructor.prototype, name, getterDescriptor);\n    }\n    function defineWrapGetter(constructor, name) {\n      defineGetter(constructor, name, function() {\n        return wrap(this.__impl4cf1e782hg__[name]);\n      });\n    }\n    function forwardMethodsToWrapper(constructors, names) {\n      constructors.forEach(function(constructor) {\n        names.forEach(function(name) {\n          constructor.prototype[name] = function() {\n            var w = wrapIfNeeded(this);\n            return w[name].apply(w, arguments);\n          };\n        });\n      });\n    }\n    scope.assert = assert;\n    scope.constructorTable = constructorTable;\n    scope.defineGetter = defineGetter;\n    scope.defineWrapGetter = defineWrapGetter;\n    scope.forwardMethodsToWrapper = forwardMethodsToWrapper;\n    scope.isIdentifierName = isIdentifierName;\n    scope.isWrapper = isWrapper;\n    scope.isWrapperFor = isWrapperFor;\n    scope.mixin = mixin;\n    scope.nativePrototypeTable = nativePrototypeTable;\n    scope.oneOf = oneOf;\n    scope.registerObject = registerObject;\n    scope.registerWrapper = register;\n    scope.rewrap = rewrap;\n    scope.setWrapper = setWrapper;\n    scope.unsafeUnwrap = unsafeUnwrap;\n    scope.unwrap = unwrap;\n    scope.unwrapIfNeeded = unwrapIfNeeded;\n    scope.wrap = wrap;\n    scope.wrapIfNeeded = wrapIfNeeded;\n    scope.wrappers = wrappers;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    function newSplice(index, removed, addedCount) {\n      return {\n        index: index,\n        removed: removed,\n        addedCount: addedCount\n      };\n    }\n    var EDIT_LEAVE = 0;\n    var EDIT_UPDATE = 1;\n    var EDIT_ADD = 2;\n    var EDIT_DELETE = 3;\n    function ArraySplice() {}\n    ArraySplice.prototype = {\n      calcEditDistances: function(current, currentStart, currentEnd, old, oldStart, oldEnd) {\n        var rowCount = oldEnd - oldStart + 1;\n        var columnCount = currentEnd - currentStart + 1;\n        var distances = new Array(rowCount);\n        for (var i = 0; i < rowCount; i++) {\n          distances[i] = new Array(columnCount);\n          distances[i][0] = i;\n        }\n        for (var j = 0; j < columnCount; j++) distances[0][j] = j;\n        for (var i = 1; i < rowCount; i++) {\n          for (var j = 1; j < columnCount; j++) {\n            if (this.equals(current[currentStart + j - 1], old[oldStart + i - 1])) distances[i][j] = distances[i - 1][j - 1]; else {\n              var north = distances[i - 1][j] + 1;\n              var west = distances[i][j - 1] + 1;\n              distances[i][j] = north < west ? north : west;\n            }\n          }\n        }\n        return distances;\n      },\n      spliceOperationsFromEditDistances: function(distances) {\n        var i = distances.length - 1;\n        var j = distances[0].length - 1;\n        var current = distances[i][j];\n        var edits = [];\n        while (i > 0 || j > 0) {\n          if (i == 0) {\n            edits.push(EDIT_ADD);\n            j--;\n            continue;\n          }\n          if (j == 0) {\n            edits.push(EDIT_DELETE);\n            i--;\n            continue;\n          }\n          var northWest = distances[i - 1][j - 1];\n          var west = distances[i - 1][j];\n          var north = distances[i][j - 1];\n          var min;\n          if (west < north) min = west < northWest ? west : northWest; else min = north < northWest ? north : northWest;\n          if (min == northWest) {\n            if (northWest == current) {\n              edits.push(EDIT_LEAVE);\n            } else {\n              edits.push(EDIT_UPDATE);\n              current = northWest;\n            }\n            i--;\n            j--;\n          } else if (min == west) {\n            edits.push(EDIT_DELETE);\n            i--;\n            current = west;\n          } else {\n            edits.push(EDIT_ADD);\n            j--;\n            current = north;\n          }\n        }\n        edits.reverse();\n        return edits;\n      },\n      calcSplices: function(current, currentStart, currentEnd, old, oldStart, oldEnd) {\n        var prefixCount = 0;\n        var suffixCount = 0;\n        var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);\n        if (currentStart == 0 && oldStart == 0) prefixCount = this.sharedPrefix(current, old, minLength);\n        if (currentEnd == current.length && oldEnd == old.length) suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);\n        currentStart += prefixCount;\n        oldStart += prefixCount;\n        currentEnd -= suffixCount;\n        oldEnd -= suffixCount;\n        if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0) return [];\n        if (currentStart == currentEnd) {\n          var splice = newSplice(currentStart, [], 0);\n          while (oldStart < oldEnd) splice.removed.push(old[oldStart++]);\n          return [ splice ];\n        } else if (oldStart == oldEnd) return [ newSplice(currentStart, [], currentEnd - currentStart) ];\n        var ops = this.spliceOperationsFromEditDistances(this.calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));\n        var splice = undefined;\n        var splices = [];\n        var index = currentStart;\n        var oldIndex = oldStart;\n        for (var i = 0; i < ops.length; i++) {\n          switch (ops[i]) {\n           case EDIT_LEAVE:\n            if (splice) {\n              splices.push(splice);\n              splice = undefined;\n            }\n            index++;\n            oldIndex++;\n            break;\n\n           case EDIT_UPDATE:\n            if (!splice) splice = newSplice(index, [], 0);\n            splice.addedCount++;\n            index++;\n            splice.removed.push(old[oldIndex]);\n            oldIndex++;\n            break;\n\n           case EDIT_ADD:\n            if (!splice) splice = newSplice(index, [], 0);\n            splice.addedCount++;\n            index++;\n            break;\n\n           case EDIT_DELETE:\n            if (!splice) splice = newSplice(index, [], 0);\n            splice.removed.push(old[oldIndex]);\n            oldIndex++;\n            break;\n          }\n        }\n        if (splice) {\n          splices.push(splice);\n        }\n        return splices;\n      },\n      sharedPrefix: function(current, old, searchLength) {\n        for (var i = 0; i < searchLength; i++) if (!this.equals(current[i], old[i])) return i;\n        return searchLength;\n      },\n      sharedSuffix: function(current, old, searchLength) {\n        var index1 = current.length;\n        var index2 = old.length;\n        var count = 0;\n        while (count < searchLength && this.equals(current[--index1], old[--index2])) count++;\n        return count;\n      },\n      calculateSplices: function(current, previous) {\n        return this.calcSplices(current, 0, current.length, previous, 0, previous.length);\n      },\n      equals: function(currentValue, previousValue) {\n        return currentValue === previousValue;\n      }\n    };\n    scope.ArraySplice = ArraySplice;\n  })(window.ShadowDOMPolyfill);\n  (function(context) {\n    \"use strict\";\n    var OriginalMutationObserver = window.MutationObserver;\n    var callbacks = [];\n    var pending = false;\n    var timerFunc;\n    function handle() {\n      pending = false;\n      var copies = callbacks.slice(0);\n      callbacks = [];\n      for (var i = 0; i < copies.length; i++) {\n        (0, copies[i])();\n      }\n    }\n    if (OriginalMutationObserver) {\n      var counter = 1;\n      var observer = new OriginalMutationObserver(handle);\n      var textNode = document.createTextNode(counter);\n      observer.observe(textNode, {\n        characterData: true\n      });\n      timerFunc = function() {\n        counter = (counter + 1) % 2;\n        textNode.data = counter;\n      };\n    } else {\n      timerFunc = window.setTimeout;\n    }\n    function setEndOfMicrotask(func) {\n      callbacks.push(func);\n      if (pending) return;\n      pending = true;\n      timerFunc(handle, 0);\n    }\n    context.setEndOfMicrotask = setEndOfMicrotask;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var setEndOfMicrotask = scope.setEndOfMicrotask;\n    var wrapIfNeeded = scope.wrapIfNeeded;\n    var wrappers = scope.wrappers;\n    var registrationsTable = new WeakMap();\n    var globalMutationObservers = [];\n    var isScheduled = false;\n    function scheduleCallback(observer) {\n      if (observer.scheduled_) return;\n      observer.scheduled_ = true;\n      globalMutationObservers.push(observer);\n      if (isScheduled) return;\n      setEndOfMicrotask(notifyObservers);\n      isScheduled = true;\n    }\n    function notifyObservers() {\n      isScheduled = false;\n      while (globalMutationObservers.length) {\n        var notifyList = globalMutationObservers;\n        globalMutationObservers = [];\n        notifyList.sort(function(x, y) {\n          return x.uid_ - y.uid_;\n        });\n        for (var i = 0; i < notifyList.length; i++) {\n          var mo = notifyList[i];\n          mo.scheduled_ = false;\n          var queue = mo.takeRecords();\n          removeTransientObserversFor(mo);\n          if (queue.length) {\n            mo.callback_(queue, mo);\n          }\n        }\n      }\n    }\n    function MutationRecord(type, target) {\n      this.type = type;\n      this.target = target;\n      this.addedNodes = new wrappers.NodeList();\n      this.removedNodes = new wrappers.NodeList();\n      this.previousSibling = null;\n      this.nextSibling = null;\n      this.attributeName = null;\n      this.attributeNamespace = null;\n      this.oldValue = null;\n    }\n    function registerTransientObservers(ancestor, node) {\n      for (;ancestor; ancestor = ancestor.parentNode) {\n        var registrations = registrationsTable.get(ancestor);\n        if (!registrations) continue;\n        for (var i = 0; i < registrations.length; i++) {\n          var registration = registrations[i];\n          if (registration.options.subtree) registration.addTransientObserver(node);\n        }\n      }\n    }\n    function removeTransientObserversFor(observer) {\n      for (var i = 0; i < observer.nodes_.length; i++) {\n        var node = observer.nodes_[i];\n        var registrations = registrationsTable.get(node);\n        if (!registrations) return;\n        for (var j = 0; j < registrations.length; j++) {\n          var registration = registrations[j];\n          if (registration.observer === observer) registration.removeTransientObservers();\n        }\n      }\n    }\n    function enqueueMutation(target, type, data) {\n      var interestedObservers = Object.create(null);\n      var associatedStrings = Object.create(null);\n      for (var node = target; node; node = node.parentNode) {\n        var registrations = registrationsTable.get(node);\n        if (!registrations) continue;\n        for (var j = 0; j < registrations.length; j++) {\n          var registration = registrations[j];\n          var options = registration.options;\n          if (node !== target && !options.subtree) continue;\n          if (type === \"attributes\" && !options.attributes) continue;\n          if (type === \"attributes\" && options.attributeFilter && (data.namespace !== null || options.attributeFilter.indexOf(data.name) === -1)) {\n            continue;\n          }\n          if (type === \"characterData\" && !options.characterData) continue;\n          if (type === \"childList\" && !options.childList) continue;\n          var observer = registration.observer;\n          interestedObservers[observer.uid_] = observer;\n          if (type === \"attributes\" && options.attributeOldValue || type === \"characterData\" && options.characterDataOldValue) {\n            associatedStrings[observer.uid_] = data.oldValue;\n          }\n        }\n      }\n      for (var uid in interestedObservers) {\n        var observer = interestedObservers[uid];\n        var record = new MutationRecord(type, target);\n        if (\"name\" in data && \"namespace\" in data) {\n          record.attributeName = data.name;\n          record.attributeNamespace = data.namespace;\n        }\n        if (data.addedNodes) record.addedNodes = data.addedNodes;\n        if (data.removedNodes) record.removedNodes = data.removedNodes;\n        if (data.previousSibling) record.previousSibling = data.previousSibling;\n        if (data.nextSibling) record.nextSibling = data.nextSibling;\n        if (associatedStrings[uid] !== undefined) record.oldValue = associatedStrings[uid];\n        scheduleCallback(observer);\n        observer.records_.push(record);\n      }\n    }\n    var slice = Array.prototype.slice;\n    function MutationObserverOptions(options) {\n      this.childList = !!options.childList;\n      this.subtree = !!options.subtree;\n      if (!(\"attributes\" in options) && (\"attributeOldValue\" in options || \"attributeFilter\" in options)) {\n        this.attributes = true;\n      } else {\n        this.attributes = !!options.attributes;\n      }\n      if (\"characterDataOldValue\" in options && !(\"characterData\" in options)) this.characterData = true; else this.characterData = !!options.characterData;\n      if (!this.attributes && (options.attributeOldValue || \"attributeFilter\" in options) || !this.characterData && options.characterDataOldValue) {\n        throw new TypeError();\n      }\n      this.characterData = !!options.characterData;\n      this.attributeOldValue = !!options.attributeOldValue;\n      this.characterDataOldValue = !!options.characterDataOldValue;\n      if (\"attributeFilter\" in options) {\n        if (options.attributeFilter == null || typeof options.attributeFilter !== \"object\") {\n          throw new TypeError();\n        }\n        this.attributeFilter = slice.call(options.attributeFilter);\n      } else {\n        this.attributeFilter = null;\n      }\n    }\n    var uidCounter = 0;\n    function MutationObserver(callback) {\n      this.callback_ = callback;\n      this.nodes_ = [];\n      this.records_ = [];\n      this.uid_ = ++uidCounter;\n      this.scheduled_ = false;\n    }\n    MutationObserver.prototype = {\n      constructor: MutationObserver,\n      observe: function(target, options) {\n        target = wrapIfNeeded(target);\n        var newOptions = new MutationObserverOptions(options);\n        var registration;\n        var registrations = registrationsTable.get(target);\n        if (!registrations) registrationsTable.set(target, registrations = []);\n        for (var i = 0; i < registrations.length; i++) {\n          if (registrations[i].observer === this) {\n            registration = registrations[i];\n            registration.removeTransientObservers();\n            registration.options = newOptions;\n          }\n        }\n        if (!registration) {\n          registration = new Registration(this, target, newOptions);\n          registrations.push(registration);\n          this.nodes_.push(target);\n        }\n      },\n      disconnect: function() {\n        this.nodes_.forEach(function(node) {\n          var registrations = registrationsTable.get(node);\n          for (var i = 0; i < registrations.length; i++) {\n            var registration = registrations[i];\n            if (registration.observer === this) {\n              registrations.splice(i, 1);\n              break;\n            }\n          }\n        }, this);\n        this.records_ = [];\n      },\n      takeRecords: function() {\n        var copyOfRecords = this.records_;\n        this.records_ = [];\n        return copyOfRecords;\n      }\n    };\n    function Registration(observer, target, options) {\n      this.observer = observer;\n      this.target = target;\n      this.options = options;\n      this.transientObservedNodes = [];\n    }\n    Registration.prototype = {\n      addTransientObserver: function(node) {\n        if (node === this.target) return;\n        scheduleCallback(this.observer);\n        this.transientObservedNodes.push(node);\n        var registrations = registrationsTable.get(node);\n        if (!registrations) registrationsTable.set(node, registrations = []);\n        registrations.push(this);\n      },\n      removeTransientObservers: function() {\n        var transientObservedNodes = this.transientObservedNodes;\n        this.transientObservedNodes = [];\n        for (var i = 0; i < transientObservedNodes.length; i++) {\n          var node = transientObservedNodes[i];\n          var registrations = registrationsTable.get(node);\n          for (var j = 0; j < registrations.length; j++) {\n            if (registrations[j] === this) {\n              registrations.splice(j, 1);\n              break;\n            }\n          }\n        }\n      }\n    };\n    scope.enqueueMutation = enqueueMutation;\n    scope.registerTransientObservers = registerTransientObservers;\n    scope.wrappers.MutationObserver = MutationObserver;\n    scope.wrappers.MutationRecord = MutationRecord;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    function TreeScope(root, parent) {\n      this.root = root;\n      this.parent = parent;\n    }\n    TreeScope.prototype = {\n      get renderer() {\n        if (this.root instanceof scope.wrappers.ShadowRoot) {\n          return scope.getRendererForHost(this.root.host);\n        }\n        return null;\n      },\n      contains: function(treeScope) {\n        for (;treeScope; treeScope = treeScope.parent) {\n          if (treeScope === this) return true;\n        }\n        return false;\n      }\n    };\n    function setTreeScope(node, treeScope) {\n      if (node.treeScope_ !== treeScope) {\n        node.treeScope_ = treeScope;\n        for (var sr = node.shadowRoot; sr; sr = sr.olderShadowRoot) {\n          sr.treeScope_.parent = treeScope;\n        }\n        for (var child = node.firstChild; child; child = child.nextSibling) {\n          setTreeScope(child, treeScope);\n        }\n      }\n    }\n    function getTreeScope(node) {\n      if (node instanceof scope.wrappers.Window) {\n        debugger;\n      }\n      if (node.treeScope_) return node.treeScope_;\n      var parent = node.parentNode;\n      var treeScope;\n      if (parent) treeScope = getTreeScope(parent); else treeScope = new TreeScope(node, null);\n      return node.treeScope_ = treeScope;\n    }\n    scope.TreeScope = TreeScope;\n    scope.getTreeScope = getTreeScope;\n    scope.setTreeScope = setTreeScope;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var forwardMethodsToWrapper = scope.forwardMethodsToWrapper;\n    var getTreeScope = scope.getTreeScope;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var setWrapper = scope.setWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var unwrap = scope.unwrap;\n    var wrap = scope.wrap;\n    var wrappers = scope.wrappers;\n    var wrappedFuns = new WeakMap();\n    var listenersTable = new WeakMap();\n    var handledEventsTable = new WeakMap();\n    var currentlyDispatchingEvents = new WeakMap();\n    var targetTable = new WeakMap();\n    var currentTargetTable = new WeakMap();\n    var relatedTargetTable = new WeakMap();\n    var eventPhaseTable = new WeakMap();\n    var stopPropagationTable = new WeakMap();\n    var stopImmediatePropagationTable = new WeakMap();\n    var eventHandlersTable = new WeakMap();\n    var eventPathTable = new WeakMap();\n    function isShadowRoot(node) {\n      return node instanceof wrappers.ShadowRoot;\n    }\n    function rootOfNode(node) {\n      return getTreeScope(node).root;\n    }\n    function getEventPath(node, event) {\n      var path = [];\n      var current = node;\n      path.push(current);\n      while (current) {\n        var destinationInsertionPoints = getDestinationInsertionPoints(current);\n        if (destinationInsertionPoints && destinationInsertionPoints.length > 0) {\n          for (var i = 0; i < destinationInsertionPoints.length; i++) {\n            var insertionPoint = destinationInsertionPoints[i];\n            if (isShadowInsertionPoint(insertionPoint)) {\n              var shadowRoot = rootOfNode(insertionPoint);\n              var olderShadowRoot = shadowRoot.olderShadowRoot;\n              if (olderShadowRoot) path.push(olderShadowRoot);\n            }\n            path.push(insertionPoint);\n          }\n          current = destinationInsertionPoints[destinationInsertionPoints.length - 1];\n        } else {\n          if (isShadowRoot(current)) {\n            if (inSameTree(node, current) && eventMustBeStopped(event)) {\n              break;\n            }\n            current = current.host;\n            path.push(current);\n          } else {\n            current = current.parentNode;\n            if (current) path.push(current);\n          }\n        }\n      }\n      return path;\n    }\n    function eventMustBeStopped(event) {\n      if (!event) return false;\n      switch (event.type) {\n       case \"abort\":\n       case \"error\":\n       case \"select\":\n       case \"change\":\n       case \"load\":\n       case \"reset\":\n       case \"resize\":\n       case \"scroll\":\n       case \"selectstart\":\n        return true;\n      }\n      return false;\n    }\n    function isShadowInsertionPoint(node) {\n      return node instanceof HTMLShadowElement;\n    }\n    function getDestinationInsertionPoints(node) {\n      return scope.getDestinationInsertionPoints(node);\n    }\n    function eventRetargetting(path, currentTarget) {\n      if (path.length === 0) return currentTarget;\n      if (currentTarget instanceof wrappers.Window) currentTarget = currentTarget.document;\n      var currentTargetTree = getTreeScope(currentTarget);\n      var originalTarget = path[0];\n      var originalTargetTree = getTreeScope(originalTarget);\n      var relativeTargetTree = lowestCommonInclusiveAncestor(currentTargetTree, originalTargetTree);\n      for (var i = 0; i < path.length; i++) {\n        var node = path[i];\n        if (getTreeScope(node) === relativeTargetTree) return node;\n      }\n      return path[path.length - 1];\n    }\n    function getTreeScopeAncestors(treeScope) {\n      var ancestors = [];\n      for (;treeScope; treeScope = treeScope.parent) {\n        ancestors.push(treeScope);\n      }\n      return ancestors;\n    }\n    function lowestCommonInclusiveAncestor(tsA, tsB) {\n      var ancestorsA = getTreeScopeAncestors(tsA);\n      var ancestorsB = getTreeScopeAncestors(tsB);\n      var result = null;\n      while (ancestorsA.length > 0 && ancestorsB.length > 0) {\n        var a = ancestorsA.pop();\n        var b = ancestorsB.pop();\n        if (a === b) result = a; else break;\n      }\n      return result;\n    }\n    function getTreeScopeRoot(ts) {\n      if (!ts.parent) return ts;\n      return getTreeScopeRoot(ts.parent);\n    }\n    function relatedTargetResolution(event, currentTarget, relatedTarget) {\n      if (currentTarget instanceof wrappers.Window) currentTarget = currentTarget.document;\n      var currentTargetTree = getTreeScope(currentTarget);\n      var relatedTargetTree = getTreeScope(relatedTarget);\n      var relatedTargetEventPath = getEventPath(relatedTarget, event);\n      var lowestCommonAncestorTree;\n      var lowestCommonAncestorTree = lowestCommonInclusiveAncestor(currentTargetTree, relatedTargetTree);\n      if (!lowestCommonAncestorTree) lowestCommonAncestorTree = relatedTargetTree.root;\n      for (var commonAncestorTree = lowestCommonAncestorTree; commonAncestorTree; commonAncestorTree = commonAncestorTree.parent) {\n        var adjustedRelatedTarget;\n        for (var i = 0; i < relatedTargetEventPath.length; i++) {\n          var node = relatedTargetEventPath[i];\n          if (getTreeScope(node) === commonAncestorTree) return node;\n        }\n      }\n      return null;\n    }\n    function inSameTree(a, b) {\n      return getTreeScope(a) === getTreeScope(b);\n    }\n    var NONE = 0;\n    var CAPTURING_PHASE = 1;\n    var AT_TARGET = 2;\n    var BUBBLING_PHASE = 3;\n    var pendingError;\n    function dispatchOriginalEvent(originalEvent) {\n      if (handledEventsTable.get(originalEvent)) return;\n      handledEventsTable.set(originalEvent, true);\n      dispatchEvent(wrap(originalEvent), wrap(originalEvent.target));\n      if (pendingError) {\n        var err = pendingError;\n        pendingError = null;\n        throw err;\n      }\n    }\n    function isLoadLikeEvent(event) {\n      switch (event.type) {\n       case \"load\":\n       case \"beforeunload\":\n       case \"unload\":\n        return true;\n      }\n      return false;\n    }\n    function dispatchEvent(event, originalWrapperTarget) {\n      if (currentlyDispatchingEvents.get(event)) throw new Error(\"InvalidStateError\");\n      currentlyDispatchingEvents.set(event, true);\n      scope.renderAllPending();\n      var eventPath;\n      var overrideTarget;\n      var win;\n      if (isLoadLikeEvent(event) && !event.bubbles) {\n        var doc = originalWrapperTarget;\n        if (doc instanceof wrappers.Document && (win = doc.defaultView)) {\n          overrideTarget = doc;\n          eventPath = [];\n        }\n      }\n      if (!eventPath) {\n        if (originalWrapperTarget instanceof wrappers.Window) {\n          win = originalWrapperTarget;\n          eventPath = [];\n        } else {\n          eventPath = getEventPath(originalWrapperTarget, event);\n          if (!isLoadLikeEvent(event)) {\n            var doc = eventPath[eventPath.length - 1];\n            if (doc instanceof wrappers.Document) win = doc.defaultView;\n          }\n        }\n      }\n      eventPathTable.set(event, eventPath);\n      if (dispatchCapturing(event, eventPath, win, overrideTarget)) {\n        if (dispatchAtTarget(event, eventPath, win, overrideTarget)) {\n          dispatchBubbling(event, eventPath, win, overrideTarget);\n        }\n      }\n      eventPhaseTable.set(event, NONE);\n      currentTargetTable.delete(event, null);\n      currentlyDispatchingEvents.delete(event);\n      return event.defaultPrevented;\n    }\n    function dispatchCapturing(event, eventPath, win, overrideTarget) {\n      var phase = CAPTURING_PHASE;\n      if (win) {\n        if (!invoke(win, event, phase, eventPath, overrideTarget)) return false;\n      }\n      for (var i = eventPath.length - 1; i > 0; i--) {\n        if (!invoke(eventPath[i], event, phase, eventPath, overrideTarget)) return false;\n      }\n      return true;\n    }\n    function dispatchAtTarget(event, eventPath, win, overrideTarget) {\n      var phase = AT_TARGET;\n      var currentTarget = eventPath[0] || win;\n      return invoke(currentTarget, event, phase, eventPath, overrideTarget);\n    }\n    function dispatchBubbling(event, eventPath, win, overrideTarget) {\n      var phase = BUBBLING_PHASE;\n      for (var i = 1; i < eventPath.length; i++) {\n        if (!invoke(eventPath[i], event, phase, eventPath, overrideTarget)) return;\n      }\n      if (win && eventPath.length > 0) {\n        invoke(win, event, phase, eventPath, overrideTarget);\n      }\n    }\n    function invoke(currentTarget, event, phase, eventPath, overrideTarget) {\n      var listeners = listenersTable.get(currentTarget);\n      if (!listeners) return true;\n      var target = overrideTarget || eventRetargetting(eventPath, currentTarget);\n      if (target === currentTarget) {\n        if (phase === CAPTURING_PHASE) return true;\n        if (phase === BUBBLING_PHASE) phase = AT_TARGET;\n      } else if (phase === BUBBLING_PHASE && !event.bubbles) {\n        return true;\n      }\n      if (\"relatedTarget\" in event) {\n        var originalEvent = unwrap(event);\n        var unwrappedRelatedTarget = originalEvent.relatedTarget;\n        if (unwrappedRelatedTarget) {\n          if (unwrappedRelatedTarget instanceof Object && unwrappedRelatedTarget.addEventListener) {\n            var relatedTarget = wrap(unwrappedRelatedTarget);\n            var adjusted = relatedTargetResolution(event, currentTarget, relatedTarget);\n            if (adjusted === target) return true;\n          } else {\n            adjusted = null;\n          }\n          relatedTargetTable.set(event, adjusted);\n        }\n      }\n      eventPhaseTable.set(event, phase);\n      var type = event.type;\n      var anyRemoved = false;\n      targetTable.set(event, target);\n      currentTargetTable.set(event, currentTarget);\n      listeners.depth++;\n      for (var i = 0, len = listeners.length; i < len; i++) {\n        var listener = listeners[i];\n        if (listener.removed) {\n          anyRemoved = true;\n          continue;\n        }\n        if (listener.type !== type || !listener.capture && phase === CAPTURING_PHASE || listener.capture && phase === BUBBLING_PHASE) {\n          continue;\n        }\n        try {\n          if (typeof listener.handler === \"function\") listener.handler.call(currentTarget, event); else listener.handler.handleEvent(event);\n          if (stopImmediatePropagationTable.get(event)) return false;\n        } catch (ex) {\n          if (!pendingError) pendingError = ex;\n        }\n      }\n      listeners.depth--;\n      if (anyRemoved && listeners.depth === 0) {\n        var copy = listeners.slice();\n        listeners.length = 0;\n        for (var i = 0; i < copy.length; i++) {\n          if (!copy[i].removed) listeners.push(copy[i]);\n        }\n      }\n      return !stopPropagationTable.get(event);\n    }\n    function Listener(type, handler, capture) {\n      this.type = type;\n      this.handler = handler;\n      this.capture = Boolean(capture);\n    }\n    Listener.prototype = {\n      equals: function(that) {\n        return this.handler === that.handler && this.type === that.type && this.capture === that.capture;\n      },\n      get removed() {\n        return this.handler === null;\n      },\n      remove: function() {\n        this.handler = null;\n      }\n    };\n    var OriginalEvent = window.Event;\n    OriginalEvent.prototype.polymerBlackList_ = {\n      returnValue: true,\n      keyLocation: true\n    };\n    function Event(type, options) {\n      if (type instanceof OriginalEvent) {\n        var impl = type;\n        if (!OriginalBeforeUnloadEvent && impl.type === \"beforeunload\" && !(this instanceof BeforeUnloadEvent)) {\n          return new BeforeUnloadEvent(impl);\n        }\n        setWrapper(impl, this);\n      } else {\n        return wrap(constructEvent(OriginalEvent, \"Event\", type, options));\n      }\n    }\n    Event.prototype = {\n      get target() {\n        return targetTable.get(this);\n      },\n      get currentTarget() {\n        return currentTargetTable.get(this);\n      },\n      get eventPhase() {\n        return eventPhaseTable.get(this);\n      },\n      get path() {\n        var eventPath = eventPathTable.get(this);\n        if (!eventPath) return [];\n        return eventPath.slice();\n      },\n      stopPropagation: function() {\n        stopPropagationTable.set(this, true);\n      },\n      stopImmediatePropagation: function() {\n        stopPropagationTable.set(this, true);\n        stopImmediatePropagationTable.set(this, true);\n      }\n    };\n    registerWrapper(OriginalEvent, Event, document.createEvent(\"Event\"));\n    function unwrapOptions(options) {\n      if (!options || !options.relatedTarget) return options;\n      return Object.create(options, {\n        relatedTarget: {\n          value: unwrap(options.relatedTarget)\n        }\n      });\n    }\n    function registerGenericEvent(name, SuperEvent, prototype) {\n      var OriginalEvent = window[name];\n      var GenericEvent = function(type, options) {\n        if (type instanceof OriginalEvent) setWrapper(type, this); else return wrap(constructEvent(OriginalEvent, name, type, options));\n      };\n      GenericEvent.prototype = Object.create(SuperEvent.prototype);\n      if (prototype) mixin(GenericEvent.prototype, prototype);\n      if (OriginalEvent) {\n        try {\n          registerWrapper(OriginalEvent, GenericEvent, new OriginalEvent(\"temp\"));\n        } catch (ex) {\n          registerWrapper(OriginalEvent, GenericEvent, document.createEvent(name));\n        }\n      }\n      return GenericEvent;\n    }\n    var UIEvent = registerGenericEvent(\"UIEvent\", Event);\n    var CustomEvent = registerGenericEvent(\"CustomEvent\", Event);\n    var relatedTargetProto = {\n      get relatedTarget() {\n        var relatedTarget = relatedTargetTable.get(this);\n        if (relatedTarget !== undefined) return relatedTarget;\n        return wrap(unwrap(this).relatedTarget);\n      }\n    };\n    function getInitFunction(name, relatedTargetIndex) {\n      return function() {\n        arguments[relatedTargetIndex] = unwrap(arguments[relatedTargetIndex]);\n        var impl = unwrap(this);\n        impl[name].apply(impl, arguments);\n      };\n    }\n    var mouseEventProto = mixin({\n      initMouseEvent: getInitFunction(\"initMouseEvent\", 14)\n    }, relatedTargetProto);\n    var focusEventProto = mixin({\n      initFocusEvent: getInitFunction(\"initFocusEvent\", 5)\n    }, relatedTargetProto);\n    var MouseEvent = registerGenericEvent(\"MouseEvent\", UIEvent, mouseEventProto);\n    var FocusEvent = registerGenericEvent(\"FocusEvent\", UIEvent, focusEventProto);\n    var defaultInitDicts = Object.create(null);\n    var supportsEventConstructors = function() {\n      try {\n        new window.FocusEvent(\"focus\");\n      } catch (ex) {\n        return false;\n      }\n      return true;\n    }();\n    function constructEvent(OriginalEvent, name, type, options) {\n      if (supportsEventConstructors) return new OriginalEvent(type, unwrapOptions(options));\n      var event = unwrap(document.createEvent(name));\n      var defaultDict = defaultInitDicts[name];\n      var args = [ type ];\n      Object.keys(defaultDict).forEach(function(key) {\n        var v = options != null && key in options ? options[key] : defaultDict[key];\n        if (key === \"relatedTarget\") v = unwrap(v);\n        args.push(v);\n      });\n      event[\"init\" + name].apply(event, args);\n      return event;\n    }\n    if (!supportsEventConstructors) {\n      var configureEventConstructor = function(name, initDict, superName) {\n        if (superName) {\n          var superDict = defaultInitDicts[superName];\n          initDict = mixin(mixin({}, superDict), initDict);\n        }\n        defaultInitDicts[name] = initDict;\n      };\n      configureEventConstructor(\"Event\", {\n        bubbles: false,\n        cancelable: false\n      });\n      configureEventConstructor(\"CustomEvent\", {\n        detail: null\n      }, \"Event\");\n      configureEventConstructor(\"UIEvent\", {\n        view: null,\n        detail: 0\n      }, \"Event\");\n      configureEventConstructor(\"MouseEvent\", {\n        screenX: 0,\n        screenY: 0,\n        clientX: 0,\n        clientY: 0,\n        ctrlKey: false,\n        altKey: false,\n        shiftKey: false,\n        metaKey: false,\n        button: 0,\n        relatedTarget: null\n      }, \"UIEvent\");\n      configureEventConstructor(\"FocusEvent\", {\n        relatedTarget: null\n      }, \"UIEvent\");\n    }\n    var OriginalBeforeUnloadEvent = window.BeforeUnloadEvent;\n    function BeforeUnloadEvent(impl) {\n      Event.call(this, impl);\n    }\n    BeforeUnloadEvent.prototype = Object.create(Event.prototype);\n    mixin(BeforeUnloadEvent.prototype, {\n      get returnValue() {\n        return unsafeUnwrap(this).returnValue;\n      },\n      set returnValue(v) {\n        unsafeUnwrap(this).returnValue = v;\n      }\n    });\n    if (OriginalBeforeUnloadEvent) registerWrapper(OriginalBeforeUnloadEvent, BeforeUnloadEvent);\n    function isValidListener(fun) {\n      if (typeof fun === \"function\") return true;\n      return fun && fun.handleEvent;\n    }\n    function isMutationEvent(type) {\n      switch (type) {\n       case \"DOMAttrModified\":\n       case \"DOMAttributeNameChanged\":\n       case \"DOMCharacterDataModified\":\n       case \"DOMElementNameChanged\":\n       case \"DOMNodeInserted\":\n       case \"DOMNodeInsertedIntoDocument\":\n       case \"DOMNodeRemoved\":\n       case \"DOMNodeRemovedFromDocument\":\n       case \"DOMSubtreeModified\":\n        return true;\n      }\n      return false;\n    }\n    var OriginalEventTarget = window.EventTarget;\n    function EventTarget(impl) {\n      setWrapper(impl, this);\n    }\n    var methodNames = [ \"addEventListener\", \"removeEventListener\", \"dispatchEvent\" ];\n    [ Node, Window ].forEach(function(constructor) {\n      var p = constructor.prototype;\n      methodNames.forEach(function(name) {\n        Object.defineProperty(p, name + \"_\", {\n          value: p[name]\n        });\n      });\n    });\n    function getTargetToListenAt(wrapper) {\n      if (wrapper instanceof wrappers.ShadowRoot) wrapper = wrapper.host;\n      return unwrap(wrapper);\n    }\n    EventTarget.prototype = {\n      addEventListener: function(type, fun, capture) {\n        if (!isValidListener(fun) || isMutationEvent(type)) return;\n        var listener = new Listener(type, fun, capture);\n        var listeners = listenersTable.get(this);\n        if (!listeners) {\n          listeners = [];\n          listeners.depth = 0;\n          listenersTable.set(this, listeners);\n        } else {\n          for (var i = 0; i < listeners.length; i++) {\n            if (listener.equals(listeners[i])) return;\n          }\n        }\n        listeners.push(listener);\n        var target = getTargetToListenAt(this);\n        target.addEventListener_(type, dispatchOriginalEvent, true);\n      },\n      removeEventListener: function(type, fun, capture) {\n        capture = Boolean(capture);\n        var listeners = listenersTable.get(this);\n        if (!listeners) return;\n        var count = 0, found = false;\n        for (var i = 0; i < listeners.length; i++) {\n          if (listeners[i].type === type && listeners[i].capture === capture) {\n            count++;\n            if (listeners[i].handler === fun) {\n              found = true;\n              listeners[i].remove();\n            }\n          }\n        }\n        if (found && count === 1) {\n          var target = getTargetToListenAt(this);\n          target.removeEventListener_(type, dispatchOriginalEvent, true);\n        }\n      },\n      dispatchEvent: function(event) {\n        var nativeEvent = unwrap(event);\n        var eventType = nativeEvent.type;\n        handledEventsTable.set(nativeEvent, false);\n        scope.renderAllPending();\n        var tempListener;\n        if (!hasListenerInAncestors(this, eventType)) {\n          tempListener = function() {};\n          this.addEventListener(eventType, tempListener, true);\n        }\n        try {\n          return unwrap(this).dispatchEvent_(nativeEvent);\n        } finally {\n          if (tempListener) this.removeEventListener(eventType, tempListener, true);\n        }\n      }\n    };\n    function hasListener(node, type) {\n      var listeners = listenersTable.get(node);\n      if (listeners) {\n        for (var i = 0; i < listeners.length; i++) {\n          if (!listeners[i].removed && listeners[i].type === type) return true;\n        }\n      }\n      return false;\n    }\n    function hasListenerInAncestors(target, type) {\n      for (var node = unwrap(target); node; node = node.parentNode) {\n        if (hasListener(wrap(node), type)) return true;\n      }\n      return false;\n    }\n    if (OriginalEventTarget) registerWrapper(OriginalEventTarget, EventTarget);\n    function wrapEventTargetMethods(constructors) {\n      forwardMethodsToWrapper(constructors, methodNames);\n    }\n    var originalElementFromPoint = document.elementFromPoint;\n    function elementFromPoint(self, document, x, y) {\n      scope.renderAllPending();\n      var element = wrap(originalElementFromPoint.call(unsafeUnwrap(document), x, y));\n      if (!element) return null;\n      var path = getEventPath(element, null);\n      var idx = path.lastIndexOf(self);\n      if (idx == -1) return null; else path = path.slice(0, idx);\n      return eventRetargetting(path, self);\n    }\n    function getEventHandlerGetter(name) {\n      return function() {\n        var inlineEventHandlers = eventHandlersTable.get(this);\n        return inlineEventHandlers && inlineEventHandlers[name] && inlineEventHandlers[name].value || null;\n      };\n    }\n    function getEventHandlerSetter(name) {\n      var eventType = name.slice(2);\n      return function(value) {\n        var inlineEventHandlers = eventHandlersTable.get(this);\n        if (!inlineEventHandlers) {\n          inlineEventHandlers = Object.create(null);\n          eventHandlersTable.set(this, inlineEventHandlers);\n        }\n        var old = inlineEventHandlers[name];\n        if (old) this.removeEventListener(eventType, old.wrapped, false);\n        if (typeof value === \"function\") {\n          var wrapped = function(e) {\n            var rv = value.call(this, e);\n            if (rv === false) e.preventDefault(); else if (name === \"onbeforeunload\" && typeof rv === \"string\") e.returnValue = rv;\n          };\n          this.addEventListener(eventType, wrapped, false);\n          inlineEventHandlers[name] = {\n            value: value,\n            wrapped: wrapped\n          };\n        }\n      };\n    }\n    scope.elementFromPoint = elementFromPoint;\n    scope.getEventHandlerGetter = getEventHandlerGetter;\n    scope.getEventHandlerSetter = getEventHandlerSetter;\n    scope.wrapEventTargetMethods = wrapEventTargetMethods;\n    scope.wrappers.BeforeUnloadEvent = BeforeUnloadEvent;\n    scope.wrappers.CustomEvent = CustomEvent;\n    scope.wrappers.Event = Event;\n    scope.wrappers.EventTarget = EventTarget;\n    scope.wrappers.FocusEvent = FocusEvent;\n    scope.wrappers.MouseEvent = MouseEvent;\n    scope.wrappers.UIEvent = UIEvent;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var UIEvent = scope.wrappers.UIEvent;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var setWrapper = scope.setWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var wrap = scope.wrap;\n    var OriginalTouchEvent = window.TouchEvent;\n    if (!OriginalTouchEvent) return;\n    var nativeEvent;\n    try {\n      nativeEvent = document.createEvent(\"TouchEvent\");\n    } catch (ex) {\n      return;\n    }\n    var nonEnumDescriptor = {\n      enumerable: false\n    };\n    function nonEnum(obj, prop) {\n      Object.defineProperty(obj, prop, nonEnumDescriptor);\n    }\n    function Touch(impl) {\n      setWrapper(impl, this);\n    }\n    Touch.prototype = {\n      get target() {\n        return wrap(unsafeUnwrap(this).target);\n      }\n    };\n    var descr = {\n      configurable: true,\n      enumerable: true,\n      get: null\n    };\n    [ \"clientX\", \"clientY\", \"screenX\", \"screenY\", \"pageX\", \"pageY\", \"identifier\", \"webkitRadiusX\", \"webkitRadiusY\", \"webkitRotationAngle\", \"webkitForce\" ].forEach(function(name) {\n      descr.get = function() {\n        return unsafeUnwrap(this)[name];\n      };\n      Object.defineProperty(Touch.prototype, name, descr);\n    });\n    function TouchList() {\n      this.length = 0;\n      nonEnum(this, \"length\");\n    }\n    TouchList.prototype = {\n      item: function(index) {\n        return this[index];\n      }\n    };\n    function wrapTouchList(nativeTouchList) {\n      var list = new TouchList();\n      for (var i = 0; i < nativeTouchList.length; i++) {\n        list[i] = new Touch(nativeTouchList[i]);\n      }\n      list.length = i;\n      return list;\n    }\n    function TouchEvent(impl) {\n      UIEvent.call(this, impl);\n    }\n    TouchEvent.prototype = Object.create(UIEvent.prototype);\n    mixin(TouchEvent.prototype, {\n      get touches() {\n        return wrapTouchList(unsafeUnwrap(this).touches);\n      },\n      get targetTouches() {\n        return wrapTouchList(unsafeUnwrap(this).targetTouches);\n      },\n      get changedTouches() {\n        return wrapTouchList(unsafeUnwrap(this).changedTouches);\n      },\n      initTouchEvent: function() {\n        throw new Error(\"Not implemented\");\n      }\n    });\n    registerWrapper(OriginalTouchEvent, TouchEvent, nativeEvent);\n    scope.wrappers.Touch = Touch;\n    scope.wrappers.TouchEvent = TouchEvent;\n    scope.wrappers.TouchList = TouchList;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var wrap = scope.wrap;\n    var nonEnumDescriptor = {\n      enumerable: false\n    };\n    function nonEnum(obj, prop) {\n      Object.defineProperty(obj, prop, nonEnumDescriptor);\n    }\n    function NodeList() {\n      this.length = 0;\n      nonEnum(this, \"length\");\n    }\n    NodeList.prototype = {\n      item: function(index) {\n        return this[index];\n      }\n    };\n    nonEnum(NodeList.prototype, \"item\");\n    function wrapNodeList(list) {\n      if (list == null) return list;\n      var wrapperList = new NodeList();\n      for (var i = 0, length = list.length; i < length; i++) {\n        wrapperList[i] = wrap(list[i]);\n      }\n      wrapperList.length = length;\n      return wrapperList;\n    }\n    function addWrapNodeListMethod(wrapperConstructor, name) {\n      wrapperConstructor.prototype[name] = function() {\n        return wrapNodeList(unsafeUnwrap(this)[name].apply(unsafeUnwrap(this), arguments));\n      };\n    }\n    scope.wrappers.NodeList = NodeList;\n    scope.addWrapNodeListMethod = addWrapNodeListMethod;\n    scope.wrapNodeList = wrapNodeList;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    scope.wrapHTMLCollection = scope.wrapNodeList;\n    scope.wrappers.HTMLCollection = scope.wrappers.NodeList;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var EventTarget = scope.wrappers.EventTarget;\n    var NodeList = scope.wrappers.NodeList;\n    var TreeScope = scope.TreeScope;\n    var assert = scope.assert;\n    var defineWrapGetter = scope.defineWrapGetter;\n    var enqueueMutation = scope.enqueueMutation;\n    var getTreeScope = scope.getTreeScope;\n    var isWrapper = scope.isWrapper;\n    var mixin = scope.mixin;\n    var registerTransientObservers = scope.registerTransientObservers;\n    var registerWrapper = scope.registerWrapper;\n    var setTreeScope = scope.setTreeScope;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var unwrap = scope.unwrap;\n    var unwrapIfNeeded = scope.unwrapIfNeeded;\n    var wrap = scope.wrap;\n    var wrapIfNeeded = scope.wrapIfNeeded;\n    var wrappers = scope.wrappers;\n    function assertIsNodeWrapper(node) {\n      assert(node instanceof Node);\n    }\n    function createOneElementNodeList(node) {\n      var nodes = new NodeList();\n      nodes[0] = node;\n      nodes.length = 1;\n      return nodes;\n    }\n    var surpressMutations = false;\n    function enqueueRemovalForInsertedNodes(node, parent, nodes) {\n      enqueueMutation(parent, \"childList\", {\n        removedNodes: nodes,\n        previousSibling: node.previousSibling,\n        nextSibling: node.nextSibling\n      });\n    }\n    function enqueueRemovalForInsertedDocumentFragment(df, nodes) {\n      enqueueMutation(df, \"childList\", {\n        removedNodes: nodes\n      });\n    }\n    function collectNodes(node, parentNode, previousNode, nextNode) {\n      if (node instanceof DocumentFragment) {\n        var nodes = collectNodesForDocumentFragment(node);\n        surpressMutations = true;\n        for (var i = nodes.length - 1; i >= 0; i--) {\n          node.removeChild(nodes[i]);\n          nodes[i].parentNode_ = parentNode;\n        }\n        surpressMutations = false;\n        for (var i = 0; i < nodes.length; i++) {\n          nodes[i].previousSibling_ = nodes[i - 1] || previousNode;\n          nodes[i].nextSibling_ = nodes[i + 1] || nextNode;\n        }\n        if (previousNode) previousNode.nextSibling_ = nodes[0];\n        if (nextNode) nextNode.previousSibling_ = nodes[nodes.length - 1];\n        return nodes;\n      }\n      var nodes = createOneElementNodeList(node);\n      var oldParent = node.parentNode;\n      if (oldParent) {\n        oldParent.removeChild(node);\n      }\n      node.parentNode_ = parentNode;\n      node.previousSibling_ = previousNode;\n      node.nextSibling_ = nextNode;\n      if (previousNode) previousNode.nextSibling_ = node;\n      if (nextNode) nextNode.previousSibling_ = node;\n      return nodes;\n    }\n    function collectNodesNative(node) {\n      if (node instanceof DocumentFragment) return collectNodesForDocumentFragment(node);\n      var nodes = createOneElementNodeList(node);\n      var oldParent = node.parentNode;\n      if (oldParent) enqueueRemovalForInsertedNodes(node, oldParent, nodes);\n      return nodes;\n    }\n    function collectNodesForDocumentFragment(node) {\n      var nodes = new NodeList();\n      var i = 0;\n      for (var child = node.firstChild; child; child = child.nextSibling) {\n        nodes[i++] = child;\n      }\n      nodes.length = i;\n      enqueueRemovalForInsertedDocumentFragment(node, nodes);\n      return nodes;\n    }\n    function snapshotNodeList(nodeList) {\n      return nodeList;\n    }\n    function nodeWasAdded(node, treeScope) {\n      setTreeScope(node, treeScope);\n      node.nodeIsInserted_();\n    }\n    function nodesWereAdded(nodes, parent) {\n      var treeScope = getTreeScope(parent);\n      for (var i = 0; i < nodes.length; i++) {\n        nodeWasAdded(nodes[i], treeScope);\n      }\n    }\n    function nodeWasRemoved(node) {\n      setTreeScope(node, new TreeScope(node, null));\n    }\n    function nodesWereRemoved(nodes) {\n      for (var i = 0; i < nodes.length; i++) {\n        nodeWasRemoved(nodes[i]);\n      }\n    }\n    function ensureSameOwnerDocument(parent, child) {\n      var ownerDoc = parent.nodeType === Node.DOCUMENT_NODE ? parent : parent.ownerDocument;\n      if (ownerDoc !== child.ownerDocument) ownerDoc.adoptNode(child);\n    }\n    function adoptNodesIfNeeded(owner, nodes) {\n      if (!nodes.length) return;\n      var ownerDoc = owner.ownerDocument;\n      if (ownerDoc === nodes[0].ownerDocument) return;\n      for (var i = 0; i < nodes.length; i++) {\n        scope.adoptNodeNoRemove(nodes[i], ownerDoc);\n      }\n    }\n    function unwrapNodesForInsertion(owner, nodes) {\n      adoptNodesIfNeeded(owner, nodes);\n      var length = nodes.length;\n      if (length === 1) return unwrap(nodes[0]);\n      var df = unwrap(owner.ownerDocument.createDocumentFragment());\n      for (var i = 0; i < length; i++) {\n        df.appendChild(unwrap(nodes[i]));\n      }\n      return df;\n    }\n    function clearChildNodes(wrapper) {\n      if (wrapper.firstChild_ !== undefined) {\n        var child = wrapper.firstChild_;\n        while (child) {\n          var tmp = child;\n          child = child.nextSibling_;\n          tmp.parentNode_ = tmp.previousSibling_ = tmp.nextSibling_ = undefined;\n        }\n      }\n      wrapper.firstChild_ = wrapper.lastChild_ = undefined;\n    }\n    function removeAllChildNodes(wrapper) {\n      if (wrapper.invalidateShadowRenderer()) {\n        var childWrapper = wrapper.firstChild;\n        while (childWrapper) {\n          assert(childWrapper.parentNode === wrapper);\n          var nextSibling = childWrapper.nextSibling;\n          var childNode = unwrap(childWrapper);\n          var parentNode = childNode.parentNode;\n          if (parentNode) originalRemoveChild.call(parentNode, childNode);\n          childWrapper.previousSibling_ = childWrapper.nextSibling_ = childWrapper.parentNode_ = null;\n          childWrapper = nextSibling;\n        }\n        wrapper.firstChild_ = wrapper.lastChild_ = null;\n      } else {\n        var node = unwrap(wrapper);\n        var child = node.firstChild;\n        var nextSibling;\n        while (child) {\n          nextSibling = child.nextSibling;\n          originalRemoveChild.call(node, child);\n          child = nextSibling;\n        }\n      }\n    }\n    function invalidateParent(node) {\n      var p = node.parentNode;\n      return p && p.invalidateShadowRenderer();\n    }\n    function cleanupNodes(nodes) {\n      for (var i = 0, n; i < nodes.length; i++) {\n        n = nodes[i];\n        n.parentNode.removeChild(n);\n      }\n    }\n    var originalImportNode = document.importNode;\n    var originalCloneNode = window.Node.prototype.cloneNode;\n    function cloneNode(node, deep, opt_doc) {\n      var clone;\n      if (opt_doc) clone = wrap(originalImportNode.call(opt_doc, unsafeUnwrap(node), false)); else clone = wrap(originalCloneNode.call(unsafeUnwrap(node), false));\n      if (deep) {\n        for (var child = node.firstChild; child; child = child.nextSibling) {\n          clone.appendChild(cloneNode(child, true, opt_doc));\n        }\n        if (node instanceof wrappers.HTMLTemplateElement) {\n          var cloneContent = clone.content;\n          for (var child = node.content.firstChild; child; child = child.nextSibling) {\n            cloneContent.appendChild(cloneNode(child, true, opt_doc));\n          }\n        }\n      }\n      return clone;\n    }\n    function contains(self, child) {\n      if (!child || getTreeScope(self) !== getTreeScope(child)) return false;\n      for (var node = child; node; node = node.parentNode) {\n        if (node === self) return true;\n      }\n      return false;\n    }\n    var OriginalNode = window.Node;\n    function Node(original) {\n      assert(original instanceof OriginalNode);\n      EventTarget.call(this, original);\n      this.parentNode_ = undefined;\n      this.firstChild_ = undefined;\n      this.lastChild_ = undefined;\n      this.nextSibling_ = undefined;\n      this.previousSibling_ = undefined;\n      this.treeScope_ = undefined;\n    }\n    var OriginalDocumentFragment = window.DocumentFragment;\n    var originalAppendChild = OriginalNode.prototype.appendChild;\n    var originalCompareDocumentPosition = OriginalNode.prototype.compareDocumentPosition;\n    var originalIsEqualNode = OriginalNode.prototype.isEqualNode;\n    var originalInsertBefore = OriginalNode.prototype.insertBefore;\n    var originalRemoveChild = OriginalNode.prototype.removeChild;\n    var originalReplaceChild = OriginalNode.prototype.replaceChild;\n    var isIe = /Trident|Edge/.test(navigator.userAgent);\n    var removeChildOriginalHelper = isIe ? function(parent, child) {\n      try {\n        originalRemoveChild.call(parent, child);\n      } catch (ex) {\n        if (!(parent instanceof OriginalDocumentFragment)) throw ex;\n      }\n    } : function(parent, child) {\n      originalRemoveChild.call(parent, child);\n    };\n    Node.prototype = Object.create(EventTarget.prototype);\n    mixin(Node.prototype, {\n      appendChild: function(childWrapper) {\n        return this.insertBefore(childWrapper, null);\n      },\n      insertBefore: function(childWrapper, refWrapper) {\n        assertIsNodeWrapper(childWrapper);\n        var refNode;\n        if (refWrapper) {\n          if (isWrapper(refWrapper)) {\n            refNode = unwrap(refWrapper);\n          } else {\n            refNode = refWrapper;\n            refWrapper = wrap(refNode);\n          }\n        } else {\n          refWrapper = null;\n          refNode = null;\n        }\n        refWrapper && assert(refWrapper.parentNode === this);\n        var nodes;\n        var previousNode = refWrapper ? refWrapper.previousSibling : this.lastChild;\n        var useNative = !this.invalidateShadowRenderer() && !invalidateParent(childWrapper);\n        if (useNative) nodes = collectNodesNative(childWrapper); else nodes = collectNodes(childWrapper, this, previousNode, refWrapper);\n        if (useNative) {\n          ensureSameOwnerDocument(this, childWrapper);\n          clearChildNodes(this);\n          originalInsertBefore.call(unsafeUnwrap(this), unwrap(childWrapper), refNode);\n        } else {\n          if (!previousNode) this.firstChild_ = nodes[0];\n          if (!refWrapper) {\n            this.lastChild_ = nodes[nodes.length - 1];\n            if (this.firstChild_ === undefined) this.firstChild_ = this.firstChild;\n          }\n          var parentNode = refNode ? refNode.parentNode : unsafeUnwrap(this);\n          if (parentNode) {\n            originalInsertBefore.call(parentNode, unwrapNodesForInsertion(this, nodes), refNode);\n          } else {\n            adoptNodesIfNeeded(this, nodes);\n          }\n        }\n        enqueueMutation(this, \"childList\", {\n          addedNodes: nodes,\n          nextSibling: refWrapper,\n          previousSibling: previousNode\n        });\n        nodesWereAdded(nodes, this);\n        return childWrapper;\n      },\n      removeChild: function(childWrapper) {\n        assertIsNodeWrapper(childWrapper);\n        if (childWrapper.parentNode !== this) {\n          var found = false;\n          var childNodes = this.childNodes;\n          for (var ieChild = this.firstChild; ieChild; ieChild = ieChild.nextSibling) {\n            if (ieChild === childWrapper) {\n              found = true;\n              break;\n            }\n          }\n          if (!found) {\n            throw new Error(\"NotFoundError\");\n          }\n        }\n        var childNode = unwrap(childWrapper);\n        var childWrapperNextSibling = childWrapper.nextSibling;\n        var childWrapperPreviousSibling = childWrapper.previousSibling;\n        if (this.invalidateShadowRenderer()) {\n          var thisFirstChild = this.firstChild;\n          var thisLastChild = this.lastChild;\n          var parentNode = childNode.parentNode;\n          if (parentNode) removeChildOriginalHelper(parentNode, childNode);\n          if (thisFirstChild === childWrapper) this.firstChild_ = childWrapperNextSibling;\n          if (thisLastChild === childWrapper) this.lastChild_ = childWrapperPreviousSibling;\n          if (childWrapperPreviousSibling) childWrapperPreviousSibling.nextSibling_ = childWrapperNextSibling;\n          if (childWrapperNextSibling) {\n            childWrapperNextSibling.previousSibling_ = childWrapperPreviousSibling;\n          }\n          childWrapper.previousSibling_ = childWrapper.nextSibling_ = childWrapper.parentNode_ = undefined;\n        } else {\n          clearChildNodes(this);\n          removeChildOriginalHelper(unsafeUnwrap(this), childNode);\n        }\n        if (!surpressMutations) {\n          enqueueMutation(this, \"childList\", {\n            removedNodes: createOneElementNodeList(childWrapper),\n            nextSibling: childWrapperNextSibling,\n            previousSibling: childWrapperPreviousSibling\n          });\n        }\n        registerTransientObservers(this, childWrapper);\n        return childWrapper;\n      },\n      replaceChild: function(newChildWrapper, oldChildWrapper) {\n        assertIsNodeWrapper(newChildWrapper);\n        var oldChildNode;\n        if (isWrapper(oldChildWrapper)) {\n          oldChildNode = unwrap(oldChildWrapper);\n        } else {\n          oldChildNode = oldChildWrapper;\n          oldChildWrapper = wrap(oldChildNode);\n        }\n        if (oldChildWrapper.parentNode !== this) {\n          throw new Error(\"NotFoundError\");\n        }\n        var nextNode = oldChildWrapper.nextSibling;\n        var previousNode = oldChildWrapper.previousSibling;\n        var nodes;\n        var useNative = !this.invalidateShadowRenderer() && !invalidateParent(newChildWrapper);\n        if (useNative) {\n          nodes = collectNodesNative(newChildWrapper);\n        } else {\n          if (nextNode === newChildWrapper) nextNode = newChildWrapper.nextSibling;\n          nodes = collectNodes(newChildWrapper, this, previousNode, nextNode);\n        }\n        if (!useNative) {\n          if (this.firstChild === oldChildWrapper) this.firstChild_ = nodes[0];\n          if (this.lastChild === oldChildWrapper) this.lastChild_ = nodes[nodes.length - 1];\n          oldChildWrapper.previousSibling_ = oldChildWrapper.nextSibling_ = oldChildWrapper.parentNode_ = undefined;\n          if (oldChildNode.parentNode) {\n            originalReplaceChild.call(oldChildNode.parentNode, unwrapNodesForInsertion(this, nodes), oldChildNode);\n          }\n        } else {\n          ensureSameOwnerDocument(this, newChildWrapper);\n          clearChildNodes(this);\n          originalReplaceChild.call(unsafeUnwrap(this), unwrap(newChildWrapper), oldChildNode);\n        }\n        enqueueMutation(this, \"childList\", {\n          addedNodes: nodes,\n          removedNodes: createOneElementNodeList(oldChildWrapper),\n          nextSibling: nextNode,\n          previousSibling: previousNode\n        });\n        nodeWasRemoved(oldChildWrapper);\n        nodesWereAdded(nodes, this);\n        return oldChildWrapper;\n      },\n      nodeIsInserted_: function() {\n        for (var child = this.firstChild; child; child = child.nextSibling) {\n          child.nodeIsInserted_();\n        }\n      },\n      hasChildNodes: function() {\n        return this.firstChild !== null;\n      },\n      get parentNode() {\n        return this.parentNode_ !== undefined ? this.parentNode_ : wrap(unsafeUnwrap(this).parentNode);\n      },\n      get firstChild() {\n        return this.firstChild_ !== undefined ? this.firstChild_ : wrap(unsafeUnwrap(this).firstChild);\n      },\n      get lastChild() {\n        return this.lastChild_ !== undefined ? this.lastChild_ : wrap(unsafeUnwrap(this).lastChild);\n      },\n      get nextSibling() {\n        return this.nextSibling_ !== undefined ? this.nextSibling_ : wrap(unsafeUnwrap(this).nextSibling);\n      },\n      get previousSibling() {\n        return this.previousSibling_ !== undefined ? this.previousSibling_ : wrap(unsafeUnwrap(this).previousSibling);\n      },\n      get parentElement() {\n        var p = this.parentNode;\n        while (p && p.nodeType !== Node.ELEMENT_NODE) {\n          p = p.parentNode;\n        }\n        return p;\n      },\n      get textContent() {\n        var s = \"\";\n        for (var child = this.firstChild; child; child = child.nextSibling) {\n          if (child.nodeType != Node.COMMENT_NODE) {\n            s += child.textContent;\n          }\n        }\n        return s;\n      },\n      set textContent(textContent) {\n        if (textContent == null) textContent = \"\";\n        var removedNodes = snapshotNodeList(this.childNodes);\n        if (this.invalidateShadowRenderer()) {\n          removeAllChildNodes(this);\n          if (textContent !== \"\") {\n            var textNode = unsafeUnwrap(this).ownerDocument.createTextNode(textContent);\n            this.appendChild(textNode);\n          }\n        } else {\n          clearChildNodes(this);\n          unsafeUnwrap(this).textContent = textContent;\n        }\n        var addedNodes = snapshotNodeList(this.childNodes);\n        enqueueMutation(this, \"childList\", {\n          addedNodes: addedNodes,\n          removedNodes: removedNodes\n        });\n        nodesWereRemoved(removedNodes);\n        nodesWereAdded(addedNodes, this);\n      },\n      get childNodes() {\n        var wrapperList = new NodeList();\n        var i = 0;\n        for (var child = this.firstChild; child; child = child.nextSibling) {\n          wrapperList[i++] = child;\n        }\n        wrapperList.length = i;\n        return wrapperList;\n      },\n      cloneNode: function(deep) {\n        return cloneNode(this, deep);\n      },\n      contains: function(child) {\n        return contains(this, wrapIfNeeded(child));\n      },\n      compareDocumentPosition: function(otherNode) {\n        return originalCompareDocumentPosition.call(unsafeUnwrap(this), unwrapIfNeeded(otherNode));\n      },\n      isEqualNode: function(otherNode) {\n        return originalIsEqualNode.call(unsafeUnwrap(this), unwrapIfNeeded(otherNode));\n      },\n      normalize: function() {\n        var nodes = snapshotNodeList(this.childNodes);\n        var remNodes = [];\n        var s = \"\";\n        var modNode;\n        for (var i = 0, n; i < nodes.length; i++) {\n          n = nodes[i];\n          if (n.nodeType === Node.TEXT_NODE) {\n            if (!modNode && !n.data.length) this.removeChild(n); else if (!modNode) modNode = n; else {\n              s += n.data;\n              remNodes.push(n);\n            }\n          } else {\n            if (modNode && remNodes.length) {\n              modNode.data += s;\n              cleanupNodes(remNodes);\n            }\n            remNodes = [];\n            s = \"\";\n            modNode = null;\n            if (n.childNodes.length) n.normalize();\n          }\n        }\n        if (modNode && remNodes.length) {\n          modNode.data += s;\n          cleanupNodes(remNodes);\n        }\n      }\n    });\n    defineWrapGetter(Node, \"ownerDocument\");\n    registerWrapper(OriginalNode, Node, document.createDocumentFragment());\n    delete Node.prototype.querySelector;\n    delete Node.prototype.querySelectorAll;\n    Node.prototype = mixin(Object.create(EventTarget.prototype), Node.prototype);\n    scope.cloneNode = cloneNode;\n    scope.nodeWasAdded = nodeWasAdded;\n    scope.nodeWasRemoved = nodeWasRemoved;\n    scope.nodesWereAdded = nodesWereAdded;\n    scope.nodesWereRemoved = nodesWereRemoved;\n    scope.originalInsertBefore = originalInsertBefore;\n    scope.originalRemoveChild = originalRemoveChild;\n    scope.snapshotNodeList = snapshotNodeList;\n    scope.wrappers.Node = Node;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var HTMLCollection = scope.wrappers.HTMLCollection;\n    var NodeList = scope.wrappers.NodeList;\n    var getTreeScope = scope.getTreeScope;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var wrap = scope.wrap;\n    var originalDocumentQuerySelector = document.querySelector;\n    var originalElementQuerySelector = document.documentElement.querySelector;\n    var originalDocumentQuerySelectorAll = document.querySelectorAll;\n    var originalElementQuerySelectorAll = document.documentElement.querySelectorAll;\n    var originalDocumentGetElementsByTagName = document.getElementsByTagName;\n    var originalElementGetElementsByTagName = document.documentElement.getElementsByTagName;\n    var originalDocumentGetElementsByTagNameNS = document.getElementsByTagNameNS;\n    var originalElementGetElementsByTagNameNS = document.documentElement.getElementsByTagNameNS;\n    var OriginalElement = window.Element;\n    var OriginalDocument = window.HTMLDocument || window.Document;\n    function filterNodeList(list, index, result, deep) {\n      var wrappedItem = null;\n      var root = null;\n      for (var i = 0, length = list.length; i < length; i++) {\n        wrappedItem = wrap(list[i]);\n        if (!deep && (root = getTreeScope(wrappedItem).root)) {\n          if (root instanceof scope.wrappers.ShadowRoot) {\n            continue;\n          }\n        }\n        result[index++] = wrappedItem;\n      }\n      return index;\n    }\n    function shimSelector(selector) {\n      return String(selector).replace(/\\/deep\\/|::shadow|>>>/g, \" \");\n    }\n    function shimMatchesSelector(selector) {\n      return String(selector).replace(/:host\\(([^\\s]+)\\)/g, \"$1\").replace(/([^\\s]):host/g, \"$1\").replace(\":host\", \"*\").replace(/\\^|\\/shadow\\/|\\/shadow-deep\\/|::shadow|\\/deep\\/|::content|>>>/g, \" \");\n    }\n    function findOne(node, selector) {\n      var m, el = node.firstElementChild;\n      while (el) {\n        if (el.matches(selector)) return el;\n        m = findOne(el, selector);\n        if (m) return m;\n        el = el.nextElementSibling;\n      }\n      return null;\n    }\n    function matchesSelector(el, selector) {\n      return el.matches(selector);\n    }\n    var XHTML_NS = \"http://www.w3.org/1999/xhtml\";\n    function matchesTagName(el, localName, localNameLowerCase) {\n      var ln = el.localName;\n      return ln === localName || ln === localNameLowerCase && el.namespaceURI === XHTML_NS;\n    }\n    function matchesEveryThing() {\n      return true;\n    }\n    function matchesLocalNameOnly(el, ns, localName) {\n      return el.localName === localName;\n    }\n    function matchesNameSpace(el, ns) {\n      return el.namespaceURI === ns;\n    }\n    function matchesLocalNameNS(el, ns, localName) {\n      return el.namespaceURI === ns && el.localName === localName;\n    }\n    function findElements(node, index, result, p, arg0, arg1) {\n      var el = node.firstElementChild;\n      while (el) {\n        if (p(el, arg0, arg1)) result[index++] = el;\n        index = findElements(el, index, result, p, arg0, arg1);\n        el = el.nextElementSibling;\n      }\n      return index;\n    }\n    function querySelectorAllFiltered(p, index, result, selector, deep) {\n      var target = unsafeUnwrap(this);\n      var list;\n      var root = getTreeScope(this).root;\n      if (root instanceof scope.wrappers.ShadowRoot) {\n        return findElements(this, index, result, p, selector, null);\n      } else if (target instanceof OriginalElement) {\n        list = originalElementQuerySelectorAll.call(target, selector);\n      } else if (target instanceof OriginalDocument) {\n        list = originalDocumentQuerySelectorAll.call(target, selector);\n      } else {\n        return findElements(this, index, result, p, selector, null);\n      }\n      return filterNodeList(list, index, result, deep);\n    }\n    var SelectorsInterface = {\n      querySelector: function(selector) {\n        var shimmed = shimSelector(selector);\n        var deep = shimmed !== selector;\n        selector = shimmed;\n        var target = unsafeUnwrap(this);\n        var wrappedItem;\n        var root = getTreeScope(this).root;\n        if (root instanceof scope.wrappers.ShadowRoot) {\n          return findOne(this, selector);\n        } else if (target instanceof OriginalElement) {\n          wrappedItem = wrap(originalElementQuerySelector.call(target, selector));\n        } else if (target instanceof OriginalDocument) {\n          wrappedItem = wrap(originalDocumentQuerySelector.call(target, selector));\n        } else {\n          return findOne(this, selector);\n        }\n        if (!wrappedItem) {\n          return wrappedItem;\n        } else if (!deep && (root = getTreeScope(wrappedItem).root)) {\n          if (root instanceof scope.wrappers.ShadowRoot) {\n            return findOne(this, selector);\n          }\n        }\n        return wrappedItem;\n      },\n      querySelectorAll: function(selector) {\n        var shimmed = shimSelector(selector);\n        var deep = shimmed !== selector;\n        selector = shimmed;\n        var result = new NodeList();\n        result.length = querySelectorAllFiltered.call(this, matchesSelector, 0, result, selector, deep);\n        return result;\n      }\n    };\n    var MatchesInterface = {\n      matches: function(selector) {\n        selector = shimMatchesSelector(selector);\n        return scope.originalMatches.call(unsafeUnwrap(this), selector);\n      }\n    };\n    function getElementsByTagNameFiltered(p, index, result, localName, lowercase) {\n      var target = unsafeUnwrap(this);\n      var list;\n      var root = getTreeScope(this).root;\n      if (root instanceof scope.wrappers.ShadowRoot) {\n        return findElements(this, index, result, p, localName, lowercase);\n      } else if (target instanceof OriginalElement) {\n        list = originalElementGetElementsByTagName.call(target, localName, lowercase);\n      } else if (target instanceof OriginalDocument) {\n        list = originalDocumentGetElementsByTagName.call(target, localName, lowercase);\n      } else {\n        return findElements(this, index, result, p, localName, lowercase);\n      }\n      return filterNodeList(list, index, result, false);\n    }\n    function getElementsByTagNameNSFiltered(p, index, result, ns, localName) {\n      var target = unsafeUnwrap(this);\n      var list;\n      var root = getTreeScope(this).root;\n      if (root instanceof scope.wrappers.ShadowRoot) {\n        return findElements(this, index, result, p, ns, localName);\n      } else if (target instanceof OriginalElement) {\n        list = originalElementGetElementsByTagNameNS.call(target, ns, localName);\n      } else if (target instanceof OriginalDocument) {\n        list = originalDocumentGetElementsByTagNameNS.call(target, ns, localName);\n      } else {\n        return findElements(this, index, result, p, ns, localName);\n      }\n      return filterNodeList(list, index, result, false);\n    }\n    var GetElementsByInterface = {\n      getElementsByTagName: function(localName) {\n        var result = new HTMLCollection();\n        var match = localName === \"*\" ? matchesEveryThing : matchesTagName;\n        result.length = getElementsByTagNameFiltered.call(this, match, 0, result, localName, localName.toLowerCase());\n        return result;\n      },\n      getElementsByClassName: function(className) {\n        return this.querySelectorAll(\".\" + className);\n      },\n      getElementsByTagNameNS: function(ns, localName) {\n        var result = new HTMLCollection();\n        var match = null;\n        if (ns === \"*\") {\n          match = localName === \"*\" ? matchesEveryThing : matchesLocalNameOnly;\n        } else {\n          match = localName === \"*\" ? matchesNameSpace : matchesLocalNameNS;\n        }\n        result.length = getElementsByTagNameNSFiltered.call(this, match, 0, result, ns || null, localName);\n        return result;\n      }\n    };\n    scope.GetElementsByInterface = GetElementsByInterface;\n    scope.SelectorsInterface = SelectorsInterface;\n    scope.MatchesInterface = MatchesInterface;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var NodeList = scope.wrappers.NodeList;\n    function forwardElement(node) {\n      while (node && node.nodeType !== Node.ELEMENT_NODE) {\n        node = node.nextSibling;\n      }\n      return node;\n    }\n    function backwardsElement(node) {\n      while (node && node.nodeType !== Node.ELEMENT_NODE) {\n        node = node.previousSibling;\n      }\n      return node;\n    }\n    var ParentNodeInterface = {\n      get firstElementChild() {\n        return forwardElement(this.firstChild);\n      },\n      get lastElementChild() {\n        return backwardsElement(this.lastChild);\n      },\n      get childElementCount() {\n        var count = 0;\n        for (var child = this.firstElementChild; child; child = child.nextElementSibling) {\n          count++;\n        }\n        return count;\n      },\n      get children() {\n        var wrapperList = new NodeList();\n        var i = 0;\n        for (var child = this.firstElementChild; child; child = child.nextElementSibling) {\n          wrapperList[i++] = child;\n        }\n        wrapperList.length = i;\n        return wrapperList;\n      },\n      remove: function() {\n        var p = this.parentNode;\n        if (p) p.removeChild(this);\n      }\n    };\n    var ChildNodeInterface = {\n      get nextElementSibling() {\n        return forwardElement(this.nextSibling);\n      },\n      get previousElementSibling() {\n        return backwardsElement(this.previousSibling);\n      }\n    };\n    var NonElementParentNodeInterface = {\n      getElementById: function(id) {\n        if (/[ \\t\\n\\r\\f]/.test(id)) return null;\n        return this.querySelector('[id=\"' + id + '\"]');\n      }\n    };\n    scope.ChildNodeInterface = ChildNodeInterface;\n    scope.NonElementParentNodeInterface = NonElementParentNodeInterface;\n    scope.ParentNodeInterface = ParentNodeInterface;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var ChildNodeInterface = scope.ChildNodeInterface;\n    var Node = scope.wrappers.Node;\n    var enqueueMutation = scope.enqueueMutation;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var OriginalCharacterData = window.CharacterData;\n    function CharacterData(node) {\n      Node.call(this, node);\n    }\n    CharacterData.prototype = Object.create(Node.prototype);\n    mixin(CharacterData.prototype, {\n      get nodeValue() {\n        return this.data;\n      },\n      set nodeValue(data) {\n        this.data = data;\n      },\n      get textContent() {\n        return this.data;\n      },\n      set textContent(value) {\n        this.data = value;\n      },\n      get data() {\n        return unsafeUnwrap(this).data;\n      },\n      set data(value) {\n        var oldValue = unsafeUnwrap(this).data;\n        enqueueMutation(this, \"characterData\", {\n          oldValue: oldValue\n        });\n        unsafeUnwrap(this).data = value;\n      }\n    });\n    mixin(CharacterData.prototype, ChildNodeInterface);\n    registerWrapper(OriginalCharacterData, CharacterData, document.createTextNode(\"\"));\n    scope.wrappers.CharacterData = CharacterData;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var CharacterData = scope.wrappers.CharacterData;\n    var enqueueMutation = scope.enqueueMutation;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    function toUInt32(x) {\n      return x >>> 0;\n    }\n    var OriginalText = window.Text;\n    function Text(node) {\n      CharacterData.call(this, node);\n    }\n    Text.prototype = Object.create(CharacterData.prototype);\n    mixin(Text.prototype, {\n      splitText: function(offset) {\n        offset = toUInt32(offset);\n        var s = this.data;\n        if (offset > s.length) throw new Error(\"IndexSizeError\");\n        var head = s.slice(0, offset);\n        var tail = s.slice(offset);\n        this.data = head;\n        var newTextNode = this.ownerDocument.createTextNode(tail);\n        if (this.parentNode) this.parentNode.insertBefore(newTextNode, this.nextSibling);\n        return newTextNode;\n      }\n    });\n    registerWrapper(OriginalText, Text, document.createTextNode(\"\"));\n    scope.wrappers.Text = Text;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    if (!window.DOMTokenList) {\n      console.warn(\"Missing DOMTokenList prototype, please include a \" + \"compatible classList polyfill such as http://goo.gl/uTcepH.\");\n      return;\n    }\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var enqueueMutation = scope.enqueueMutation;\n    function getClass(el) {\n      return unsafeUnwrap(el).getAttribute(\"class\");\n    }\n    function enqueueClassAttributeChange(el, oldValue) {\n      enqueueMutation(el, \"attributes\", {\n        name: \"class\",\n        namespace: null,\n        oldValue: oldValue\n      });\n    }\n    function invalidateClass(el) {\n      scope.invalidateRendererBasedOnAttribute(el, \"class\");\n    }\n    function changeClass(tokenList, method, args) {\n      var ownerElement = tokenList.ownerElement_;\n      if (ownerElement == null) {\n        return method.apply(tokenList, args);\n      }\n      var oldValue = getClass(ownerElement);\n      var retv = method.apply(tokenList, args);\n      if (getClass(ownerElement) !== oldValue) {\n        enqueueClassAttributeChange(ownerElement, oldValue);\n        invalidateClass(ownerElement);\n      }\n      return retv;\n    }\n    var oldAdd = DOMTokenList.prototype.add;\n    DOMTokenList.prototype.add = function() {\n      changeClass(this, oldAdd, arguments);\n    };\n    var oldRemove = DOMTokenList.prototype.remove;\n    DOMTokenList.prototype.remove = function() {\n      changeClass(this, oldRemove, arguments);\n    };\n    var oldToggle = DOMTokenList.prototype.toggle;\n    DOMTokenList.prototype.toggle = function() {\n      return changeClass(this, oldToggle, arguments);\n    };\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var ChildNodeInterface = scope.ChildNodeInterface;\n    var GetElementsByInterface = scope.GetElementsByInterface;\n    var Node = scope.wrappers.Node;\n    var ParentNodeInterface = scope.ParentNodeInterface;\n    var SelectorsInterface = scope.SelectorsInterface;\n    var MatchesInterface = scope.MatchesInterface;\n    var addWrapNodeListMethod = scope.addWrapNodeListMethod;\n    var enqueueMutation = scope.enqueueMutation;\n    var mixin = scope.mixin;\n    var oneOf = scope.oneOf;\n    var registerWrapper = scope.registerWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var wrappers = scope.wrappers;\n    var OriginalElement = window.Element;\n    var matchesNames = [ \"matches\", \"mozMatchesSelector\", \"msMatchesSelector\", \"webkitMatchesSelector\" ].filter(function(name) {\n      return OriginalElement.prototype[name];\n    });\n    var matchesName = matchesNames[0];\n    var originalMatches = OriginalElement.prototype[matchesName];\n    function invalidateRendererBasedOnAttribute(element, name) {\n      var p = element.parentNode;\n      if (!p || !p.shadowRoot) return;\n      var renderer = scope.getRendererForHost(p);\n      if (renderer.dependsOnAttribute(name)) renderer.invalidate();\n    }\n    function enqueAttributeChange(element, name, oldValue) {\n      enqueueMutation(element, \"attributes\", {\n        name: name,\n        namespace: null,\n        oldValue: oldValue\n      });\n    }\n    var classListTable = new WeakMap();\n    function Element(node) {\n      Node.call(this, node);\n    }\n    Element.prototype = Object.create(Node.prototype);\n    mixin(Element.prototype, {\n      createShadowRoot: function() {\n        var newShadowRoot = new wrappers.ShadowRoot(this);\n        unsafeUnwrap(this).polymerShadowRoot_ = newShadowRoot;\n        var renderer = scope.getRendererForHost(this);\n        renderer.invalidate();\n        return newShadowRoot;\n      },\n      get shadowRoot() {\n        return unsafeUnwrap(this).polymerShadowRoot_ || null;\n      },\n      setAttribute: function(name, value) {\n        var oldValue = unsafeUnwrap(this).getAttribute(name);\n        unsafeUnwrap(this).setAttribute(name, value);\n        enqueAttributeChange(this, name, oldValue);\n        invalidateRendererBasedOnAttribute(this, name);\n      },\n      removeAttribute: function(name) {\n        var oldValue = unsafeUnwrap(this).getAttribute(name);\n        unsafeUnwrap(this).removeAttribute(name);\n        enqueAttributeChange(this, name, oldValue);\n        invalidateRendererBasedOnAttribute(this, name);\n      },\n      get classList() {\n        var list = classListTable.get(this);\n        if (!list) {\n          list = unsafeUnwrap(this).classList;\n          if (!list) return;\n          list.ownerElement_ = this;\n          classListTable.set(this, list);\n        }\n        return list;\n      },\n      get className() {\n        return unsafeUnwrap(this).className;\n      },\n      set className(v) {\n        this.setAttribute(\"class\", v);\n      },\n      get id() {\n        return unsafeUnwrap(this).id;\n      },\n      set id(v) {\n        this.setAttribute(\"id\", v);\n      }\n    });\n    matchesNames.forEach(function(name) {\n      if (name !== \"matches\") {\n        Element.prototype[name] = function(selector) {\n          return this.matches(selector);\n        };\n      }\n    });\n    if (OriginalElement.prototype.webkitCreateShadowRoot) {\n      Element.prototype.webkitCreateShadowRoot = Element.prototype.createShadowRoot;\n    }\n    mixin(Element.prototype, ChildNodeInterface);\n    mixin(Element.prototype, GetElementsByInterface);\n    mixin(Element.prototype, ParentNodeInterface);\n    mixin(Element.prototype, SelectorsInterface);\n    mixin(Element.prototype, MatchesInterface);\n    registerWrapper(OriginalElement, Element, document.createElementNS(null, \"x\"));\n    scope.invalidateRendererBasedOnAttribute = invalidateRendererBasedOnAttribute;\n    scope.matchesNames = matchesNames;\n    scope.originalMatches = originalMatches;\n    scope.wrappers.Element = Element;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var Element = scope.wrappers.Element;\n    var defineGetter = scope.defineGetter;\n    var enqueueMutation = scope.enqueueMutation;\n    var mixin = scope.mixin;\n    var nodesWereAdded = scope.nodesWereAdded;\n    var nodesWereRemoved = scope.nodesWereRemoved;\n    var registerWrapper = scope.registerWrapper;\n    var snapshotNodeList = scope.snapshotNodeList;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var unwrap = scope.unwrap;\n    var wrap = scope.wrap;\n    var wrappers = scope.wrappers;\n    var escapeAttrRegExp = /[&\\u00A0\"]/g;\n    var escapeDataRegExp = /[&\\u00A0<>]/g;\n    function escapeReplace(c) {\n      switch (c) {\n       case \"&\":\n        return \"&amp;\";\n\n       case \"<\":\n        return \"&lt;\";\n\n       case \">\":\n        return \"&gt;\";\n\n       case '\"':\n        return \"&quot;\";\n\n       case \" \":\n        return \"&nbsp;\";\n      }\n    }\n    function escapeAttr(s) {\n      return s.replace(escapeAttrRegExp, escapeReplace);\n    }\n    function escapeData(s) {\n      return s.replace(escapeDataRegExp, escapeReplace);\n    }\n    function makeSet(arr) {\n      var set = {};\n      for (var i = 0; i < arr.length; i++) {\n        set[arr[i]] = true;\n      }\n      return set;\n    }\n    var voidElements = makeSet([ \"area\", \"base\", \"br\", \"col\", \"command\", \"embed\", \"hr\", \"img\", \"input\", \"keygen\", \"link\", \"meta\", \"param\", \"source\", \"track\", \"wbr\" ]);\n    var plaintextParents = makeSet([ \"style\", \"script\", \"xmp\", \"iframe\", \"noembed\", \"noframes\", \"plaintext\", \"noscript\" ]);\n    var XHTML_NS = \"http://www.w3.org/1999/xhtml\";\n    function needsSelfClosingSlash(node) {\n      if (node.namespaceURI !== XHTML_NS) return true;\n      var doctype = node.ownerDocument.doctype;\n      return doctype && doctype.publicId && doctype.systemId;\n    }\n    function getOuterHTML(node, parentNode) {\n      switch (node.nodeType) {\n       case Node.ELEMENT_NODE:\n        var tagName = node.tagName.toLowerCase();\n        var s = \"<\" + tagName;\n        var attrs = node.attributes;\n        for (var i = 0, attr; attr = attrs[i]; i++) {\n          s += \" \" + attr.name + '=\"' + escapeAttr(attr.value) + '\"';\n        }\n        if (voidElements[tagName]) {\n          if (needsSelfClosingSlash(node)) s += \"/\";\n          return s + \">\";\n        }\n        return s + \">\" + getInnerHTML(node) + \"</\" + tagName + \">\";\n\n       case Node.TEXT_NODE:\n        var data = node.data;\n        if (parentNode && plaintextParents[parentNode.localName]) return data;\n        return escapeData(data);\n\n       case Node.COMMENT_NODE:\n        return \"<!--\" + node.data + \"-->\";\n\n       default:\n        console.error(node);\n        throw new Error(\"not implemented\");\n      }\n    }\n    function getInnerHTML(node) {\n      if (node instanceof wrappers.HTMLTemplateElement) node = node.content;\n      var s = \"\";\n      for (var child = node.firstChild; child; child = child.nextSibling) {\n        s += getOuterHTML(child, node);\n      }\n      return s;\n    }\n    function setInnerHTML(node, value, opt_tagName) {\n      var tagName = opt_tagName || \"div\";\n      node.textContent = \"\";\n      var tempElement = unwrap(node.ownerDocument.createElement(tagName));\n      tempElement.innerHTML = value;\n      var firstChild;\n      while (firstChild = tempElement.firstChild) {\n        node.appendChild(wrap(firstChild));\n      }\n    }\n    var oldIe = /MSIE/.test(navigator.userAgent);\n    var OriginalHTMLElement = window.HTMLElement;\n    var OriginalHTMLTemplateElement = window.HTMLTemplateElement;\n    function HTMLElement(node) {\n      Element.call(this, node);\n    }\n    HTMLElement.prototype = Object.create(Element.prototype);\n    mixin(HTMLElement.prototype, {\n      get innerHTML() {\n        return getInnerHTML(this);\n      },\n      set innerHTML(value) {\n        if (oldIe && plaintextParents[this.localName]) {\n          this.textContent = value;\n          return;\n        }\n        var removedNodes = snapshotNodeList(this.childNodes);\n        if (this.invalidateShadowRenderer()) {\n          if (this instanceof wrappers.HTMLTemplateElement) setInnerHTML(this.content, value); else setInnerHTML(this, value, this.tagName);\n        } else if (!OriginalHTMLTemplateElement && this instanceof wrappers.HTMLTemplateElement) {\n          setInnerHTML(this.content, value);\n        } else {\n          unsafeUnwrap(this).innerHTML = value;\n        }\n        var addedNodes = snapshotNodeList(this.childNodes);\n        enqueueMutation(this, \"childList\", {\n          addedNodes: addedNodes,\n          removedNodes: removedNodes\n        });\n        nodesWereRemoved(removedNodes);\n        nodesWereAdded(addedNodes, this);\n      },\n      get outerHTML() {\n        return getOuterHTML(this, this.parentNode);\n      },\n      set outerHTML(value) {\n        var p = this.parentNode;\n        if (p) {\n          p.invalidateShadowRenderer();\n          var df = frag(p, value);\n          p.replaceChild(df, this);\n        }\n      },\n      insertAdjacentHTML: function(position, text) {\n        var contextElement, refNode;\n        switch (String(position).toLowerCase()) {\n         case \"beforebegin\":\n          contextElement = this.parentNode;\n          refNode = this;\n          break;\n\n         case \"afterend\":\n          contextElement = this.parentNode;\n          refNode = this.nextSibling;\n          break;\n\n         case \"afterbegin\":\n          contextElement = this;\n          refNode = this.firstChild;\n          break;\n\n         case \"beforeend\":\n          contextElement = this;\n          refNode = null;\n          break;\n\n         default:\n          return;\n        }\n        var df = frag(contextElement, text);\n        contextElement.insertBefore(df, refNode);\n      },\n      get hidden() {\n        return this.hasAttribute(\"hidden\");\n      },\n      set hidden(v) {\n        if (v) {\n          this.setAttribute(\"hidden\", \"\");\n        } else {\n          this.removeAttribute(\"hidden\");\n        }\n      }\n    });\n    function frag(contextElement, html) {\n      var p = unwrap(contextElement.cloneNode(false));\n      p.innerHTML = html;\n      var df = unwrap(document.createDocumentFragment());\n      var c;\n      while (c = p.firstChild) {\n        df.appendChild(c);\n      }\n      return wrap(df);\n    }\n    function getter(name) {\n      return function() {\n        scope.renderAllPending();\n        return unsafeUnwrap(this)[name];\n      };\n    }\n    function getterRequiresRendering(name) {\n      defineGetter(HTMLElement, name, getter(name));\n    }\n    [ \"clientHeight\", \"clientLeft\", \"clientTop\", \"clientWidth\", \"offsetHeight\", \"offsetLeft\", \"offsetTop\", \"offsetWidth\", \"scrollHeight\", \"scrollWidth\" ].forEach(getterRequiresRendering);\n    function getterAndSetterRequiresRendering(name) {\n      Object.defineProperty(HTMLElement.prototype, name, {\n        get: getter(name),\n        set: function(v) {\n          scope.renderAllPending();\n          unsafeUnwrap(this)[name] = v;\n        },\n        configurable: true,\n        enumerable: true\n      });\n    }\n    [ \"scrollLeft\", \"scrollTop\" ].forEach(getterAndSetterRequiresRendering);\n    function methodRequiresRendering(name) {\n      Object.defineProperty(HTMLElement.prototype, name, {\n        value: function() {\n          scope.renderAllPending();\n          return unsafeUnwrap(this)[name].apply(unsafeUnwrap(this), arguments);\n        },\n        configurable: true,\n        enumerable: true\n      });\n    }\n    [ \"getBoundingClientRect\", \"getClientRects\", \"scrollIntoView\" ].forEach(methodRequiresRendering);\n    registerWrapper(OriginalHTMLElement, HTMLElement, document.createElement(\"b\"));\n    scope.wrappers.HTMLElement = HTMLElement;\n    scope.getInnerHTML = getInnerHTML;\n    scope.setInnerHTML = setInnerHTML;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var wrap = scope.wrap;\n    var OriginalHTMLCanvasElement = window.HTMLCanvasElement;\n    function HTMLCanvasElement(node) {\n      HTMLElement.call(this, node);\n    }\n    HTMLCanvasElement.prototype = Object.create(HTMLElement.prototype);\n    mixin(HTMLCanvasElement.prototype, {\n      getContext: function() {\n        var context = unsafeUnwrap(this).getContext.apply(unsafeUnwrap(this), arguments);\n        return context && wrap(context);\n      }\n    });\n    registerWrapper(OriginalHTMLCanvasElement, HTMLCanvasElement, document.createElement(\"canvas\"));\n    scope.wrappers.HTMLCanvasElement = HTMLCanvasElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var OriginalHTMLContentElement = window.HTMLContentElement;\n    function HTMLContentElement(node) {\n      HTMLElement.call(this, node);\n    }\n    HTMLContentElement.prototype = Object.create(HTMLElement.prototype);\n    mixin(HTMLContentElement.prototype, {\n      constructor: HTMLContentElement,\n      get select() {\n        return this.getAttribute(\"select\");\n      },\n      set select(value) {\n        this.setAttribute(\"select\", value);\n      },\n      setAttribute: function(n, v) {\n        HTMLElement.prototype.setAttribute.call(this, n, v);\n        if (String(n).toLowerCase() === \"select\") this.invalidateShadowRenderer(true);\n      }\n    });\n    if (OriginalHTMLContentElement) registerWrapper(OriginalHTMLContentElement, HTMLContentElement);\n    scope.wrappers.HTMLContentElement = HTMLContentElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var wrapHTMLCollection = scope.wrapHTMLCollection;\n    var unwrap = scope.unwrap;\n    var OriginalHTMLFormElement = window.HTMLFormElement;\n    function HTMLFormElement(node) {\n      HTMLElement.call(this, node);\n    }\n    HTMLFormElement.prototype = Object.create(HTMLElement.prototype);\n    mixin(HTMLFormElement.prototype, {\n      get elements() {\n        return wrapHTMLCollection(unwrap(this).elements);\n      }\n    });\n    registerWrapper(OriginalHTMLFormElement, HTMLFormElement, document.createElement(\"form\"));\n    scope.wrappers.HTMLFormElement = HTMLFormElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var registerWrapper = scope.registerWrapper;\n    var unwrap = scope.unwrap;\n    var rewrap = scope.rewrap;\n    var OriginalHTMLImageElement = window.HTMLImageElement;\n    function HTMLImageElement(node) {\n      HTMLElement.call(this, node);\n    }\n    HTMLImageElement.prototype = Object.create(HTMLElement.prototype);\n    registerWrapper(OriginalHTMLImageElement, HTMLImageElement, document.createElement(\"img\"));\n    function Image(width, height) {\n      if (!(this instanceof Image)) {\n        throw new TypeError(\"DOM object constructor cannot be called as a function.\");\n      }\n      var node = unwrap(document.createElement(\"img\"));\n      HTMLElement.call(this, node);\n      rewrap(node, this);\n      if (width !== undefined) node.width = width;\n      if (height !== undefined) node.height = height;\n    }\n    Image.prototype = HTMLImageElement.prototype;\n    scope.wrappers.HTMLImageElement = HTMLImageElement;\n    scope.wrappers.Image = Image;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var mixin = scope.mixin;\n    var NodeList = scope.wrappers.NodeList;\n    var registerWrapper = scope.registerWrapper;\n    var OriginalHTMLShadowElement = window.HTMLShadowElement;\n    function HTMLShadowElement(node) {\n      HTMLElement.call(this, node);\n    }\n    HTMLShadowElement.prototype = Object.create(HTMLElement.prototype);\n    HTMLShadowElement.prototype.constructor = HTMLShadowElement;\n    if (OriginalHTMLShadowElement) registerWrapper(OriginalHTMLShadowElement, HTMLShadowElement);\n    scope.wrappers.HTMLShadowElement = HTMLShadowElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var unwrap = scope.unwrap;\n    var wrap = scope.wrap;\n    var contentTable = new WeakMap();\n    var templateContentsOwnerTable = new WeakMap();\n    function getTemplateContentsOwner(doc) {\n      if (!doc.defaultView) return doc;\n      var d = templateContentsOwnerTable.get(doc);\n      if (!d) {\n        d = doc.implementation.createHTMLDocument(\"\");\n        while (d.lastChild) {\n          d.removeChild(d.lastChild);\n        }\n        templateContentsOwnerTable.set(doc, d);\n      }\n      return d;\n    }\n    function extractContent(templateElement) {\n      var doc = getTemplateContentsOwner(templateElement.ownerDocument);\n      var df = unwrap(doc.createDocumentFragment());\n      var child;\n      while (child = templateElement.firstChild) {\n        df.appendChild(child);\n      }\n      return df;\n    }\n    var OriginalHTMLTemplateElement = window.HTMLTemplateElement;\n    function HTMLTemplateElement(node) {\n      HTMLElement.call(this, node);\n      if (!OriginalHTMLTemplateElement) {\n        var content = extractContent(node);\n        contentTable.set(this, wrap(content));\n      }\n    }\n    HTMLTemplateElement.prototype = Object.create(HTMLElement.prototype);\n    mixin(HTMLTemplateElement.prototype, {\n      constructor: HTMLTemplateElement,\n      get content() {\n        if (OriginalHTMLTemplateElement) return wrap(unsafeUnwrap(this).content);\n        return contentTable.get(this);\n      }\n    });\n    if (OriginalHTMLTemplateElement) registerWrapper(OriginalHTMLTemplateElement, HTMLTemplateElement);\n    scope.wrappers.HTMLTemplateElement = HTMLTemplateElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var registerWrapper = scope.registerWrapper;\n    var OriginalHTMLMediaElement = window.HTMLMediaElement;\n    if (!OriginalHTMLMediaElement) return;\n    function HTMLMediaElement(node) {\n      HTMLElement.call(this, node);\n    }\n    HTMLMediaElement.prototype = Object.create(HTMLElement.prototype);\n    registerWrapper(OriginalHTMLMediaElement, HTMLMediaElement, document.createElement(\"audio\"));\n    scope.wrappers.HTMLMediaElement = HTMLMediaElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var HTMLMediaElement = scope.wrappers.HTMLMediaElement;\n    var registerWrapper = scope.registerWrapper;\n    var unwrap = scope.unwrap;\n    var rewrap = scope.rewrap;\n    var OriginalHTMLAudioElement = window.HTMLAudioElement;\n    if (!OriginalHTMLAudioElement) return;\n    function HTMLAudioElement(node) {\n      HTMLMediaElement.call(this, node);\n    }\n    HTMLAudioElement.prototype = Object.create(HTMLMediaElement.prototype);\n    registerWrapper(OriginalHTMLAudioElement, HTMLAudioElement, document.createElement(\"audio\"));\n    function Audio(src) {\n      if (!(this instanceof Audio)) {\n        throw new TypeError(\"DOM object constructor cannot be called as a function.\");\n      }\n      var node = unwrap(document.createElement(\"audio\"));\n      HTMLMediaElement.call(this, node);\n      rewrap(node, this);\n      node.setAttribute(\"preload\", \"auto\");\n      if (src !== undefined) node.setAttribute(\"src\", src);\n    }\n    Audio.prototype = HTMLAudioElement.prototype;\n    scope.wrappers.HTMLAudioElement = HTMLAudioElement;\n    scope.wrappers.Audio = Audio;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var rewrap = scope.rewrap;\n    var unwrap = scope.unwrap;\n    var wrap = scope.wrap;\n    var OriginalHTMLOptionElement = window.HTMLOptionElement;\n    function trimText(s) {\n      return s.replace(/\\s+/g, \" \").trim();\n    }\n    function HTMLOptionElement(node) {\n      HTMLElement.call(this, node);\n    }\n    HTMLOptionElement.prototype = Object.create(HTMLElement.prototype);\n    mixin(HTMLOptionElement.prototype, {\n      get text() {\n        return trimText(this.textContent);\n      },\n      set text(value) {\n        this.textContent = trimText(String(value));\n      },\n      get form() {\n        return wrap(unwrap(this).form);\n      }\n    });\n    registerWrapper(OriginalHTMLOptionElement, HTMLOptionElement, document.createElement(\"option\"));\n    function Option(text, value, defaultSelected, selected) {\n      if (!(this instanceof Option)) {\n        throw new TypeError(\"DOM object constructor cannot be called as a function.\");\n      }\n      var node = unwrap(document.createElement(\"option\"));\n      HTMLElement.call(this, node);\n      rewrap(node, this);\n      if (text !== undefined) node.text = text;\n      if (value !== undefined) node.setAttribute(\"value\", value);\n      if (defaultSelected === true) node.setAttribute(\"selected\", \"\");\n      node.selected = selected === true;\n    }\n    Option.prototype = HTMLOptionElement.prototype;\n    scope.wrappers.HTMLOptionElement = HTMLOptionElement;\n    scope.wrappers.Option = Option;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var unwrap = scope.unwrap;\n    var wrap = scope.wrap;\n    var OriginalHTMLSelectElement = window.HTMLSelectElement;\n    function HTMLSelectElement(node) {\n      HTMLElement.call(this, node);\n    }\n    HTMLSelectElement.prototype = Object.create(HTMLElement.prototype);\n    mixin(HTMLSelectElement.prototype, {\n      add: function(element, before) {\n        if (typeof before === \"object\") before = unwrap(before);\n        unwrap(this).add(unwrap(element), before);\n      },\n      remove: function(indexOrNode) {\n        if (indexOrNode === undefined) {\n          HTMLElement.prototype.remove.call(this);\n          return;\n        }\n        if (typeof indexOrNode === \"object\") indexOrNode = unwrap(indexOrNode);\n        unwrap(this).remove(indexOrNode);\n      },\n      get form() {\n        return wrap(unwrap(this).form);\n      }\n    });\n    registerWrapper(OriginalHTMLSelectElement, HTMLSelectElement, document.createElement(\"select\"));\n    scope.wrappers.HTMLSelectElement = HTMLSelectElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var unwrap = scope.unwrap;\n    var wrap = scope.wrap;\n    var wrapHTMLCollection = scope.wrapHTMLCollection;\n    var OriginalHTMLTableElement = window.HTMLTableElement;\n    function HTMLTableElement(node) {\n      HTMLElement.call(this, node);\n    }\n    HTMLTableElement.prototype = Object.create(HTMLElement.prototype);\n    mixin(HTMLTableElement.prototype, {\n      get caption() {\n        return wrap(unwrap(this).caption);\n      },\n      createCaption: function() {\n        return wrap(unwrap(this).createCaption());\n      },\n      get tHead() {\n        return wrap(unwrap(this).tHead);\n      },\n      createTHead: function() {\n        return wrap(unwrap(this).createTHead());\n      },\n      createTFoot: function() {\n        return wrap(unwrap(this).createTFoot());\n      },\n      get tFoot() {\n        return wrap(unwrap(this).tFoot);\n      },\n      get tBodies() {\n        return wrapHTMLCollection(unwrap(this).tBodies);\n      },\n      createTBody: function() {\n        return wrap(unwrap(this).createTBody());\n      },\n      get rows() {\n        return wrapHTMLCollection(unwrap(this).rows);\n      },\n      insertRow: function(index) {\n        return wrap(unwrap(this).insertRow(index));\n      }\n    });\n    registerWrapper(OriginalHTMLTableElement, HTMLTableElement, document.createElement(\"table\"));\n    scope.wrappers.HTMLTableElement = HTMLTableElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var wrapHTMLCollection = scope.wrapHTMLCollection;\n    var unwrap = scope.unwrap;\n    var wrap = scope.wrap;\n    var OriginalHTMLTableSectionElement = window.HTMLTableSectionElement;\n    function HTMLTableSectionElement(node) {\n      HTMLElement.call(this, node);\n    }\n    HTMLTableSectionElement.prototype = Object.create(HTMLElement.prototype);\n    mixin(HTMLTableSectionElement.prototype, {\n      constructor: HTMLTableSectionElement,\n      get rows() {\n        return wrapHTMLCollection(unwrap(this).rows);\n      },\n      insertRow: function(index) {\n        return wrap(unwrap(this).insertRow(index));\n      }\n    });\n    registerWrapper(OriginalHTMLTableSectionElement, HTMLTableSectionElement, document.createElement(\"thead\"));\n    scope.wrappers.HTMLTableSectionElement = HTMLTableSectionElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var wrapHTMLCollection = scope.wrapHTMLCollection;\n    var unwrap = scope.unwrap;\n    var wrap = scope.wrap;\n    var OriginalHTMLTableRowElement = window.HTMLTableRowElement;\n    function HTMLTableRowElement(node) {\n      HTMLElement.call(this, node);\n    }\n    HTMLTableRowElement.prototype = Object.create(HTMLElement.prototype);\n    mixin(HTMLTableRowElement.prototype, {\n      get cells() {\n        return wrapHTMLCollection(unwrap(this).cells);\n      },\n      insertCell: function(index) {\n        return wrap(unwrap(this).insertCell(index));\n      }\n    });\n    registerWrapper(OriginalHTMLTableRowElement, HTMLTableRowElement, document.createElement(\"tr\"));\n    scope.wrappers.HTMLTableRowElement = HTMLTableRowElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var HTMLContentElement = scope.wrappers.HTMLContentElement;\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var HTMLShadowElement = scope.wrappers.HTMLShadowElement;\n    var HTMLTemplateElement = scope.wrappers.HTMLTemplateElement;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var OriginalHTMLUnknownElement = window.HTMLUnknownElement;\n    function HTMLUnknownElement(node) {\n      switch (node.localName) {\n       case \"content\":\n        return new HTMLContentElement(node);\n\n       case \"shadow\":\n        return new HTMLShadowElement(node);\n\n       case \"template\":\n        return new HTMLTemplateElement(node);\n      }\n      HTMLElement.call(this, node);\n    }\n    HTMLUnknownElement.prototype = Object.create(HTMLElement.prototype);\n    registerWrapper(OriginalHTMLUnknownElement, HTMLUnknownElement);\n    scope.wrappers.HTMLUnknownElement = HTMLUnknownElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var Element = scope.wrappers.Element;\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var registerObject = scope.registerObject;\n    var defineWrapGetter = scope.defineWrapGetter;\n    var SVG_NS = \"http://www.w3.org/2000/svg\";\n    var svgTitleElement = document.createElementNS(SVG_NS, \"title\");\n    var SVGTitleElement = registerObject(svgTitleElement);\n    var SVGElement = Object.getPrototypeOf(SVGTitleElement.prototype).constructor;\n    if (!(\"classList\" in svgTitleElement)) {\n      var descr = Object.getOwnPropertyDescriptor(Element.prototype, \"classList\");\n      Object.defineProperty(HTMLElement.prototype, \"classList\", descr);\n      delete Element.prototype.classList;\n    }\n    defineWrapGetter(SVGElement, \"ownerSVGElement\");\n    scope.wrappers.SVGElement = SVGElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var unwrap = scope.unwrap;\n    var wrap = scope.wrap;\n    var OriginalSVGUseElement = window.SVGUseElement;\n    var SVG_NS = \"http://www.w3.org/2000/svg\";\n    var gWrapper = wrap(document.createElementNS(SVG_NS, \"g\"));\n    var useElement = document.createElementNS(SVG_NS, \"use\");\n    var SVGGElement = gWrapper.constructor;\n    var parentInterfacePrototype = Object.getPrototypeOf(SVGGElement.prototype);\n    var parentInterface = parentInterfacePrototype.constructor;\n    function SVGUseElement(impl) {\n      parentInterface.call(this, impl);\n    }\n    SVGUseElement.prototype = Object.create(parentInterfacePrototype);\n    if (\"instanceRoot\" in useElement) {\n      mixin(SVGUseElement.prototype, {\n        get instanceRoot() {\n          return wrap(unwrap(this).instanceRoot);\n        },\n        get animatedInstanceRoot() {\n          return wrap(unwrap(this).animatedInstanceRoot);\n        }\n      });\n    }\n    registerWrapper(OriginalSVGUseElement, SVGUseElement, useElement);\n    scope.wrappers.SVGUseElement = SVGUseElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var EventTarget = scope.wrappers.EventTarget;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var wrap = scope.wrap;\n    var OriginalSVGElementInstance = window.SVGElementInstance;\n    if (!OriginalSVGElementInstance) return;\n    function SVGElementInstance(impl) {\n      EventTarget.call(this, impl);\n    }\n    SVGElementInstance.prototype = Object.create(EventTarget.prototype);\n    mixin(SVGElementInstance.prototype, {\n      get correspondingElement() {\n        return wrap(unsafeUnwrap(this).correspondingElement);\n      },\n      get correspondingUseElement() {\n        return wrap(unsafeUnwrap(this).correspondingUseElement);\n      },\n      get parentNode() {\n        return wrap(unsafeUnwrap(this).parentNode);\n      },\n      get childNodes() {\n        throw new Error(\"Not implemented\");\n      },\n      get firstChild() {\n        return wrap(unsafeUnwrap(this).firstChild);\n      },\n      get lastChild() {\n        return wrap(unsafeUnwrap(this).lastChild);\n      },\n      get previousSibling() {\n        return wrap(unsafeUnwrap(this).previousSibling);\n      },\n      get nextSibling() {\n        return wrap(unsafeUnwrap(this).nextSibling);\n      }\n    });\n    registerWrapper(OriginalSVGElementInstance, SVGElementInstance);\n    scope.wrappers.SVGElementInstance = SVGElementInstance;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var setWrapper = scope.setWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var unwrap = scope.unwrap;\n    var unwrapIfNeeded = scope.unwrapIfNeeded;\n    var wrap = scope.wrap;\n    var OriginalCanvasRenderingContext2D = window.CanvasRenderingContext2D;\n    function CanvasRenderingContext2D(impl) {\n      setWrapper(impl, this);\n    }\n    mixin(CanvasRenderingContext2D.prototype, {\n      get canvas() {\n        return wrap(unsafeUnwrap(this).canvas);\n      },\n      drawImage: function() {\n        arguments[0] = unwrapIfNeeded(arguments[0]);\n        unsafeUnwrap(this).drawImage.apply(unsafeUnwrap(this), arguments);\n      },\n      createPattern: function() {\n        arguments[0] = unwrap(arguments[0]);\n        return unsafeUnwrap(this).createPattern.apply(unsafeUnwrap(this), arguments);\n      }\n    });\n    registerWrapper(OriginalCanvasRenderingContext2D, CanvasRenderingContext2D, document.createElement(\"canvas\").getContext(\"2d\"));\n    scope.wrappers.CanvasRenderingContext2D = CanvasRenderingContext2D;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var setWrapper = scope.setWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var unwrapIfNeeded = scope.unwrapIfNeeded;\n    var wrap = scope.wrap;\n    var OriginalWebGLRenderingContext = window.WebGLRenderingContext;\n    if (!OriginalWebGLRenderingContext) return;\n    function WebGLRenderingContext(impl) {\n      setWrapper(impl, this);\n    }\n    mixin(WebGLRenderingContext.prototype, {\n      get canvas() {\n        return wrap(unsafeUnwrap(this).canvas);\n      },\n      texImage2D: function() {\n        arguments[5] = unwrapIfNeeded(arguments[5]);\n        unsafeUnwrap(this).texImage2D.apply(unsafeUnwrap(this), arguments);\n      },\n      texSubImage2D: function() {\n        arguments[6] = unwrapIfNeeded(arguments[6]);\n        unsafeUnwrap(this).texSubImage2D.apply(unsafeUnwrap(this), arguments);\n      }\n    });\n    var instanceProperties = /WebKit/.test(navigator.userAgent) ? {\n      drawingBufferHeight: null,\n      drawingBufferWidth: null\n    } : {};\n    registerWrapper(OriginalWebGLRenderingContext, WebGLRenderingContext, instanceProperties);\n    scope.wrappers.WebGLRenderingContext = WebGLRenderingContext;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var GetElementsByInterface = scope.GetElementsByInterface;\n    var NonElementParentNodeInterface = scope.NonElementParentNodeInterface;\n    var ParentNodeInterface = scope.ParentNodeInterface;\n    var SelectorsInterface = scope.SelectorsInterface;\n    var mixin = scope.mixin;\n    var registerObject = scope.registerObject;\n    var DocumentFragment = registerObject(document.createDocumentFragment());\n    mixin(DocumentFragment.prototype, ParentNodeInterface);\n    mixin(DocumentFragment.prototype, SelectorsInterface);\n    mixin(DocumentFragment.prototype, GetElementsByInterface);\n    mixin(DocumentFragment.prototype, NonElementParentNodeInterface);\n    var Comment = registerObject(document.createComment(\"\"));\n    scope.wrappers.Comment = Comment;\n    scope.wrappers.DocumentFragment = DocumentFragment;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var DocumentFragment = scope.wrappers.DocumentFragment;\n    var TreeScope = scope.TreeScope;\n    var elementFromPoint = scope.elementFromPoint;\n    var getInnerHTML = scope.getInnerHTML;\n    var getTreeScope = scope.getTreeScope;\n    var mixin = scope.mixin;\n    var rewrap = scope.rewrap;\n    var setInnerHTML = scope.setInnerHTML;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var unwrap = scope.unwrap;\n    var shadowHostTable = new WeakMap();\n    var nextOlderShadowTreeTable = new WeakMap();\n    function ShadowRoot(hostWrapper) {\n      var node = unwrap(unsafeUnwrap(hostWrapper).ownerDocument.createDocumentFragment());\n      DocumentFragment.call(this, node);\n      rewrap(node, this);\n      var oldShadowRoot = hostWrapper.shadowRoot;\n      nextOlderShadowTreeTable.set(this, oldShadowRoot);\n      this.treeScope_ = new TreeScope(this, getTreeScope(oldShadowRoot || hostWrapper));\n      shadowHostTable.set(this, hostWrapper);\n    }\n    ShadowRoot.prototype = Object.create(DocumentFragment.prototype);\n    mixin(ShadowRoot.prototype, {\n      constructor: ShadowRoot,\n      get innerHTML() {\n        return getInnerHTML(this);\n      },\n      set innerHTML(value) {\n        setInnerHTML(this, value);\n        this.invalidateShadowRenderer();\n      },\n      get olderShadowRoot() {\n        return nextOlderShadowTreeTable.get(this) || null;\n      },\n      get host() {\n        return shadowHostTable.get(this) || null;\n      },\n      invalidateShadowRenderer: function() {\n        return shadowHostTable.get(this).invalidateShadowRenderer();\n      },\n      elementFromPoint: function(x, y) {\n        return elementFromPoint(this, this.ownerDocument, x, y);\n      }\n    });\n    scope.wrappers.ShadowRoot = ShadowRoot;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var registerWrapper = scope.registerWrapper;\n    var setWrapper = scope.setWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var unwrap = scope.unwrap;\n    var unwrapIfNeeded = scope.unwrapIfNeeded;\n    var wrap = scope.wrap;\n    var getTreeScope = scope.getTreeScope;\n    var OriginalRange = window.Range;\n    var ShadowRoot = scope.wrappers.ShadowRoot;\n    function getHost(node) {\n      var root = getTreeScope(node).root;\n      if (root instanceof ShadowRoot) {\n        return root.host;\n      }\n      return null;\n    }\n    function hostNodeToShadowNode(refNode, offset) {\n      if (refNode.shadowRoot) {\n        offset = Math.min(refNode.childNodes.length - 1, offset);\n        var child = refNode.childNodes[offset];\n        if (child) {\n          var insertionPoint = scope.getDestinationInsertionPoints(child);\n          if (insertionPoint.length > 0) {\n            var parentNode = insertionPoint[0].parentNode;\n            if (parentNode.nodeType == Node.ELEMENT_NODE) {\n              refNode = parentNode;\n            }\n          }\n        }\n      }\n      return refNode;\n    }\n    function shadowNodeToHostNode(node) {\n      node = wrap(node);\n      return getHost(node) || node;\n    }\n    function Range(impl) {\n      setWrapper(impl, this);\n    }\n    Range.prototype = {\n      get startContainer() {\n        return shadowNodeToHostNode(unsafeUnwrap(this).startContainer);\n      },\n      get endContainer() {\n        return shadowNodeToHostNode(unsafeUnwrap(this).endContainer);\n      },\n      get commonAncestorContainer() {\n        return shadowNodeToHostNode(unsafeUnwrap(this).commonAncestorContainer);\n      },\n      setStart: function(refNode, offset) {\n        refNode = hostNodeToShadowNode(refNode, offset);\n        unsafeUnwrap(this).setStart(unwrapIfNeeded(refNode), offset);\n      },\n      setEnd: function(refNode, offset) {\n        refNode = hostNodeToShadowNode(refNode, offset);\n        unsafeUnwrap(this).setEnd(unwrapIfNeeded(refNode), offset);\n      },\n      setStartBefore: function(refNode) {\n        unsafeUnwrap(this).setStartBefore(unwrapIfNeeded(refNode));\n      },\n      setStartAfter: function(refNode) {\n        unsafeUnwrap(this).setStartAfter(unwrapIfNeeded(refNode));\n      },\n      setEndBefore: function(refNode) {\n        unsafeUnwrap(this).setEndBefore(unwrapIfNeeded(refNode));\n      },\n      setEndAfter: function(refNode) {\n        unsafeUnwrap(this).setEndAfter(unwrapIfNeeded(refNode));\n      },\n      selectNode: function(refNode) {\n        unsafeUnwrap(this).selectNode(unwrapIfNeeded(refNode));\n      },\n      selectNodeContents: function(refNode) {\n        unsafeUnwrap(this).selectNodeContents(unwrapIfNeeded(refNode));\n      },\n      compareBoundaryPoints: function(how, sourceRange) {\n        return unsafeUnwrap(this).compareBoundaryPoints(how, unwrap(sourceRange));\n      },\n      extractContents: function() {\n        return wrap(unsafeUnwrap(this).extractContents());\n      },\n      cloneContents: function() {\n        return wrap(unsafeUnwrap(this).cloneContents());\n      },\n      insertNode: function(node) {\n        unsafeUnwrap(this).insertNode(unwrapIfNeeded(node));\n      },\n      surroundContents: function(newParent) {\n        unsafeUnwrap(this).surroundContents(unwrapIfNeeded(newParent));\n      },\n      cloneRange: function() {\n        return wrap(unsafeUnwrap(this).cloneRange());\n      },\n      isPointInRange: function(node, offset) {\n        return unsafeUnwrap(this).isPointInRange(unwrapIfNeeded(node), offset);\n      },\n      comparePoint: function(node, offset) {\n        return unsafeUnwrap(this).comparePoint(unwrapIfNeeded(node), offset);\n      },\n      intersectsNode: function(node) {\n        return unsafeUnwrap(this).intersectsNode(unwrapIfNeeded(node));\n      },\n      toString: function() {\n        return unsafeUnwrap(this).toString();\n      }\n    };\n    if (OriginalRange.prototype.createContextualFragment) {\n      Range.prototype.createContextualFragment = function(html) {\n        return wrap(unsafeUnwrap(this).createContextualFragment(html));\n      };\n    }\n    registerWrapper(window.Range, Range, document.createRange());\n    scope.wrappers.Range = Range;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var Element = scope.wrappers.Element;\n    var HTMLContentElement = scope.wrappers.HTMLContentElement;\n    var HTMLShadowElement = scope.wrappers.HTMLShadowElement;\n    var Node = scope.wrappers.Node;\n    var ShadowRoot = scope.wrappers.ShadowRoot;\n    var assert = scope.assert;\n    var getTreeScope = scope.getTreeScope;\n    var mixin = scope.mixin;\n    var oneOf = scope.oneOf;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var unwrap = scope.unwrap;\n    var wrap = scope.wrap;\n    var ArraySplice = scope.ArraySplice;\n    function updateWrapperUpAndSideways(wrapper) {\n      wrapper.previousSibling_ = wrapper.previousSibling;\n      wrapper.nextSibling_ = wrapper.nextSibling;\n      wrapper.parentNode_ = wrapper.parentNode;\n    }\n    function updateWrapperDown(wrapper) {\n      wrapper.firstChild_ = wrapper.firstChild;\n      wrapper.lastChild_ = wrapper.lastChild;\n    }\n    function updateAllChildNodes(parentNodeWrapper) {\n      assert(parentNodeWrapper instanceof Node);\n      for (var childWrapper = parentNodeWrapper.firstChild; childWrapper; childWrapper = childWrapper.nextSibling) {\n        updateWrapperUpAndSideways(childWrapper);\n      }\n      updateWrapperDown(parentNodeWrapper);\n    }\n    function insertBefore(parentNodeWrapper, newChildWrapper, refChildWrapper) {\n      var parentNode = unwrap(parentNodeWrapper);\n      var newChild = unwrap(newChildWrapper);\n      var refChild = refChildWrapper ? unwrap(refChildWrapper) : null;\n      remove(newChildWrapper);\n      updateWrapperUpAndSideways(newChildWrapper);\n      if (!refChildWrapper) {\n        parentNodeWrapper.lastChild_ = parentNodeWrapper.lastChild;\n        if (parentNodeWrapper.lastChild === parentNodeWrapper.firstChild) parentNodeWrapper.firstChild_ = parentNodeWrapper.firstChild;\n        var lastChildWrapper = wrap(parentNode.lastChild);\n        if (lastChildWrapper) lastChildWrapper.nextSibling_ = lastChildWrapper.nextSibling;\n      } else {\n        if (parentNodeWrapper.firstChild === refChildWrapper) parentNodeWrapper.firstChild_ = refChildWrapper;\n        refChildWrapper.previousSibling_ = refChildWrapper.previousSibling;\n      }\n      scope.originalInsertBefore.call(parentNode, newChild, refChild);\n    }\n    function remove(nodeWrapper) {\n      var node = unwrap(nodeWrapper);\n      var parentNode = node.parentNode;\n      if (!parentNode) return;\n      var parentNodeWrapper = wrap(parentNode);\n      updateWrapperUpAndSideways(nodeWrapper);\n      if (nodeWrapper.previousSibling) nodeWrapper.previousSibling.nextSibling_ = nodeWrapper;\n      if (nodeWrapper.nextSibling) nodeWrapper.nextSibling.previousSibling_ = nodeWrapper;\n      if (parentNodeWrapper.lastChild === nodeWrapper) parentNodeWrapper.lastChild_ = nodeWrapper;\n      if (parentNodeWrapper.firstChild === nodeWrapper) parentNodeWrapper.firstChild_ = nodeWrapper;\n      scope.originalRemoveChild.call(parentNode, node);\n    }\n    var distributedNodesTable = new WeakMap();\n    var destinationInsertionPointsTable = new WeakMap();\n    var rendererForHostTable = new WeakMap();\n    function resetDistributedNodes(insertionPoint) {\n      distributedNodesTable.set(insertionPoint, []);\n    }\n    function getDistributedNodes(insertionPoint) {\n      var rv = distributedNodesTable.get(insertionPoint);\n      if (!rv) distributedNodesTable.set(insertionPoint, rv = []);\n      return rv;\n    }\n    function getChildNodesSnapshot(node) {\n      var result = [], i = 0;\n      for (var child = node.firstChild; child; child = child.nextSibling) {\n        result[i++] = child;\n      }\n      return result;\n    }\n    var request = oneOf(window, [ \"requestAnimationFrame\", \"mozRequestAnimationFrame\", \"webkitRequestAnimationFrame\", \"setTimeout\" ]);\n    var pendingDirtyRenderers = [];\n    var renderTimer;\n    function renderAllPending() {\n      for (var i = 0; i < pendingDirtyRenderers.length; i++) {\n        var renderer = pendingDirtyRenderers[i];\n        var parentRenderer = renderer.parentRenderer;\n        if (parentRenderer && parentRenderer.dirty) continue;\n        renderer.render();\n      }\n      pendingDirtyRenderers = [];\n    }\n    function handleRequestAnimationFrame() {\n      renderTimer = null;\n      renderAllPending();\n    }\n    function getRendererForHost(host) {\n      var renderer = rendererForHostTable.get(host);\n      if (!renderer) {\n        renderer = new ShadowRenderer(host);\n        rendererForHostTable.set(host, renderer);\n      }\n      return renderer;\n    }\n    function getShadowRootAncestor(node) {\n      var root = getTreeScope(node).root;\n      if (root instanceof ShadowRoot) return root;\n      return null;\n    }\n    function getRendererForShadowRoot(shadowRoot) {\n      return getRendererForHost(shadowRoot.host);\n    }\n    var spliceDiff = new ArraySplice();\n    spliceDiff.equals = function(renderNode, rawNode) {\n      return unwrap(renderNode.node) === rawNode;\n    };\n    function RenderNode(node) {\n      this.skip = false;\n      this.node = node;\n      this.childNodes = [];\n    }\n    RenderNode.prototype = {\n      append: function(node) {\n        var rv = new RenderNode(node);\n        this.childNodes.push(rv);\n        return rv;\n      },\n      sync: function(opt_added) {\n        if (this.skip) return;\n        var nodeWrapper = this.node;\n        var newChildren = this.childNodes;\n        var oldChildren = getChildNodesSnapshot(unwrap(nodeWrapper));\n        var added = opt_added || new WeakMap();\n        var splices = spliceDiff.calculateSplices(newChildren, oldChildren);\n        var newIndex = 0, oldIndex = 0;\n        var lastIndex = 0;\n        for (var i = 0; i < splices.length; i++) {\n          var splice = splices[i];\n          for (;lastIndex < splice.index; lastIndex++) {\n            oldIndex++;\n            newChildren[newIndex++].sync(added);\n          }\n          var removedCount = splice.removed.length;\n          for (var j = 0; j < removedCount; j++) {\n            var wrapper = wrap(oldChildren[oldIndex++]);\n            if (!added.get(wrapper)) remove(wrapper);\n          }\n          var addedCount = splice.addedCount;\n          var refNode = oldChildren[oldIndex] && wrap(oldChildren[oldIndex]);\n          for (var j = 0; j < addedCount; j++) {\n            var newChildRenderNode = newChildren[newIndex++];\n            var newChildWrapper = newChildRenderNode.node;\n            insertBefore(nodeWrapper, newChildWrapper, refNode);\n            added.set(newChildWrapper, true);\n            newChildRenderNode.sync(added);\n          }\n          lastIndex += addedCount;\n        }\n        for (var i = lastIndex; i < newChildren.length; i++) {\n          newChildren[i].sync(added);\n        }\n      }\n    };\n    function ShadowRenderer(host) {\n      this.host = host;\n      this.dirty = false;\n      this.invalidateAttributes();\n      this.associateNode(host);\n    }\n    ShadowRenderer.prototype = {\n      render: function(opt_renderNode) {\n        if (!this.dirty) return;\n        this.invalidateAttributes();\n        var host = this.host;\n        this.distribution(host);\n        var renderNode = opt_renderNode || new RenderNode(host);\n        this.buildRenderTree(renderNode, host);\n        var topMostRenderer = !opt_renderNode;\n        if (topMostRenderer) renderNode.sync();\n        this.dirty = false;\n      },\n      get parentRenderer() {\n        return getTreeScope(this.host).renderer;\n      },\n      invalidate: function() {\n        if (!this.dirty) {\n          this.dirty = true;\n          var parentRenderer = this.parentRenderer;\n          if (parentRenderer) parentRenderer.invalidate();\n          pendingDirtyRenderers.push(this);\n          if (renderTimer) return;\n          renderTimer = window[request](handleRequestAnimationFrame, 0);\n        }\n      },\n      distribution: function(root) {\n        this.resetAllSubtrees(root);\n        this.distributionResolution(root);\n      },\n      resetAll: function(node) {\n        if (isInsertionPoint(node)) resetDistributedNodes(node); else resetDestinationInsertionPoints(node);\n        this.resetAllSubtrees(node);\n      },\n      resetAllSubtrees: function(node) {\n        for (var child = node.firstChild; child; child = child.nextSibling) {\n          this.resetAll(child);\n        }\n        if (node.shadowRoot) this.resetAll(node.shadowRoot);\n        if (node.olderShadowRoot) this.resetAll(node.olderShadowRoot);\n      },\n      distributionResolution: function(node) {\n        if (isShadowHost(node)) {\n          var shadowHost = node;\n          var pool = poolPopulation(shadowHost);\n          var shadowTrees = getShadowTrees(shadowHost);\n          for (var i = 0; i < shadowTrees.length; i++) {\n            this.poolDistribution(shadowTrees[i], pool);\n          }\n          for (var i = shadowTrees.length - 1; i >= 0; i--) {\n            var shadowTree = shadowTrees[i];\n            var shadow = getShadowInsertionPoint(shadowTree);\n            if (shadow) {\n              var olderShadowRoot = shadowTree.olderShadowRoot;\n              if (olderShadowRoot) {\n                pool = poolPopulation(olderShadowRoot);\n              }\n              for (var j = 0; j < pool.length; j++) {\n                destributeNodeInto(pool[j], shadow);\n              }\n            }\n            this.distributionResolution(shadowTree);\n          }\n        }\n        for (var child = node.firstChild; child; child = child.nextSibling) {\n          this.distributionResolution(child);\n        }\n      },\n      poolDistribution: function(node, pool) {\n        if (node instanceof HTMLShadowElement) return;\n        if (node instanceof HTMLContentElement) {\n          var content = node;\n          this.updateDependentAttributes(content.getAttribute(\"select\"));\n          var anyDistributed = false;\n          for (var i = 0; i < pool.length; i++) {\n            var node = pool[i];\n            if (!node) continue;\n            if (matches(node, content)) {\n              destributeNodeInto(node, content);\n              pool[i] = undefined;\n              anyDistributed = true;\n            }\n          }\n          if (!anyDistributed) {\n            for (var child = content.firstChild; child; child = child.nextSibling) {\n              destributeNodeInto(child, content);\n            }\n          }\n          return;\n        }\n        for (var child = node.firstChild; child; child = child.nextSibling) {\n          this.poolDistribution(child, pool);\n        }\n      },\n      buildRenderTree: function(renderNode, node) {\n        var children = this.compose(node);\n        for (var i = 0; i < children.length; i++) {\n          var child = children[i];\n          var childRenderNode = renderNode.append(child);\n          this.buildRenderTree(childRenderNode, child);\n        }\n        if (isShadowHost(node)) {\n          var renderer = getRendererForHost(node);\n          renderer.dirty = false;\n        }\n      },\n      compose: function(node) {\n        var children = [];\n        var p = node.shadowRoot || node;\n        for (var child = p.firstChild; child; child = child.nextSibling) {\n          if (isInsertionPoint(child)) {\n            this.associateNode(p);\n            var distributedNodes = getDistributedNodes(child);\n            for (var j = 0; j < distributedNodes.length; j++) {\n              var distributedNode = distributedNodes[j];\n              if (isFinalDestination(child, distributedNode)) children.push(distributedNode);\n            }\n          } else {\n            children.push(child);\n          }\n        }\n        return children;\n      },\n      invalidateAttributes: function() {\n        this.attributes = Object.create(null);\n      },\n      updateDependentAttributes: function(selector) {\n        if (!selector) return;\n        var attributes = this.attributes;\n        if (/\\.\\w+/.test(selector)) attributes[\"class\"] = true;\n        if (/#\\w+/.test(selector)) attributes[\"id\"] = true;\n        selector.replace(/\\[\\s*([^\\s=\\|~\\]]+)/g, function(_, name) {\n          attributes[name] = true;\n        });\n      },\n      dependsOnAttribute: function(name) {\n        return this.attributes[name];\n      },\n      associateNode: function(node) {\n        unsafeUnwrap(node).polymerShadowRenderer_ = this;\n      }\n    };\n    function poolPopulation(node) {\n      var pool = [];\n      for (var child = node.firstChild; child; child = child.nextSibling) {\n        if (isInsertionPoint(child)) {\n          pool.push.apply(pool, getDistributedNodes(child));\n        } else {\n          pool.push(child);\n        }\n      }\n      return pool;\n    }\n    function getShadowInsertionPoint(node) {\n      if (node instanceof HTMLShadowElement) return node;\n      if (node instanceof HTMLContentElement) return null;\n      for (var child = node.firstChild; child; child = child.nextSibling) {\n        var res = getShadowInsertionPoint(child);\n        if (res) return res;\n      }\n      return null;\n    }\n    function destributeNodeInto(child, insertionPoint) {\n      getDistributedNodes(insertionPoint).push(child);\n      var points = destinationInsertionPointsTable.get(child);\n      if (!points) destinationInsertionPointsTable.set(child, [ insertionPoint ]); else points.push(insertionPoint);\n    }\n    function getDestinationInsertionPoints(node) {\n      return destinationInsertionPointsTable.get(node);\n    }\n    function resetDestinationInsertionPoints(node) {\n      destinationInsertionPointsTable.set(node, undefined);\n    }\n    var selectorStartCharRe = /^(:not\\()?[*.#[a-zA-Z_|]/;\n    function matches(node, contentElement) {\n      var select = contentElement.getAttribute(\"select\");\n      if (!select) return true;\n      select = select.trim();\n      if (!select) return true;\n      if (!(node instanceof Element)) return false;\n      if (!selectorStartCharRe.test(select)) return false;\n      try {\n        return node.matches(select);\n      } catch (ex) {\n        return false;\n      }\n    }\n    function isFinalDestination(insertionPoint, node) {\n      var points = getDestinationInsertionPoints(node);\n      return points && points[points.length - 1] === insertionPoint;\n    }\n    function isInsertionPoint(node) {\n      return node instanceof HTMLContentElement || node instanceof HTMLShadowElement;\n    }\n    function isShadowHost(shadowHost) {\n      return shadowHost.shadowRoot;\n    }\n    function getShadowTrees(host) {\n      var trees = [];\n      for (var tree = host.shadowRoot; tree; tree = tree.olderShadowRoot) {\n        trees.push(tree);\n      }\n      return trees;\n    }\n    function render(host) {\n      new ShadowRenderer(host).render();\n    }\n    Node.prototype.invalidateShadowRenderer = function(force) {\n      var renderer = unsafeUnwrap(this).polymerShadowRenderer_;\n      if (renderer) {\n        renderer.invalidate();\n        return true;\n      }\n      return false;\n    };\n    HTMLContentElement.prototype.getDistributedNodes = HTMLShadowElement.prototype.getDistributedNodes = function() {\n      renderAllPending();\n      return getDistributedNodes(this);\n    };\n    Element.prototype.getDestinationInsertionPoints = function() {\n      renderAllPending();\n      return getDestinationInsertionPoints(this) || [];\n    };\n    HTMLContentElement.prototype.nodeIsInserted_ = HTMLShadowElement.prototype.nodeIsInserted_ = function() {\n      this.invalidateShadowRenderer();\n      var shadowRoot = getShadowRootAncestor(this);\n      var renderer;\n      if (shadowRoot) renderer = getRendererForShadowRoot(shadowRoot);\n      unsafeUnwrap(this).polymerShadowRenderer_ = renderer;\n      if (renderer) renderer.invalidate();\n    };\n    scope.getRendererForHost = getRendererForHost;\n    scope.getShadowTrees = getShadowTrees;\n    scope.renderAllPending = renderAllPending;\n    scope.getDestinationInsertionPoints = getDestinationInsertionPoints;\n    scope.visual = {\n      insertBefore: insertBefore,\n      remove: remove\n    };\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var assert = scope.assert;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var unwrap = scope.unwrap;\n    var wrap = scope.wrap;\n    var elementsWithFormProperty = [ \"HTMLButtonElement\", \"HTMLFieldSetElement\", \"HTMLInputElement\", \"HTMLKeygenElement\", \"HTMLLabelElement\", \"HTMLLegendElement\", \"HTMLObjectElement\", \"HTMLOutputElement\", \"HTMLTextAreaElement\" ];\n    function createWrapperConstructor(name) {\n      if (!window[name]) return;\n      assert(!scope.wrappers[name]);\n      var GeneratedWrapper = function(node) {\n        HTMLElement.call(this, node);\n      };\n      GeneratedWrapper.prototype = Object.create(HTMLElement.prototype);\n      mixin(GeneratedWrapper.prototype, {\n        get form() {\n          return wrap(unwrap(this).form);\n        }\n      });\n      registerWrapper(window[name], GeneratedWrapper, document.createElement(name.slice(4, -7)));\n      scope.wrappers[name] = GeneratedWrapper;\n    }\n    elementsWithFormProperty.forEach(createWrapperConstructor);\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var registerWrapper = scope.registerWrapper;\n    var setWrapper = scope.setWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var unwrap = scope.unwrap;\n    var unwrapIfNeeded = scope.unwrapIfNeeded;\n    var wrap = scope.wrap;\n    var OriginalSelection = window.Selection;\n    function Selection(impl) {\n      setWrapper(impl, this);\n    }\n    Selection.prototype = {\n      get anchorNode() {\n        return wrap(unsafeUnwrap(this).anchorNode);\n      },\n      get focusNode() {\n        return wrap(unsafeUnwrap(this).focusNode);\n      },\n      addRange: function(range) {\n        unsafeUnwrap(this).addRange(unwrapIfNeeded(range));\n      },\n      collapse: function(node, index) {\n        unsafeUnwrap(this).collapse(unwrapIfNeeded(node), index);\n      },\n      containsNode: function(node, allowPartial) {\n        return unsafeUnwrap(this).containsNode(unwrapIfNeeded(node), allowPartial);\n      },\n      getRangeAt: function(index) {\n        return wrap(unsafeUnwrap(this).getRangeAt(index));\n      },\n      removeRange: function(range) {\n        unsafeUnwrap(this).removeRange(unwrap(range));\n      },\n      selectAllChildren: function(node) {\n        unsafeUnwrap(this).selectAllChildren(unwrapIfNeeded(node));\n      },\n      toString: function() {\n        return unsafeUnwrap(this).toString();\n      }\n    };\n    if (OriginalSelection.prototype.extend) {\n      Selection.prototype.extend = function(node, offset) {\n        unsafeUnwrap(this).extend(unwrapIfNeeded(node), offset);\n      };\n    }\n    registerWrapper(window.Selection, Selection, window.getSelection());\n    scope.wrappers.Selection = Selection;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var registerWrapper = scope.registerWrapper;\n    var setWrapper = scope.setWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var unwrapIfNeeded = scope.unwrapIfNeeded;\n    var wrap = scope.wrap;\n    var OriginalTreeWalker = window.TreeWalker;\n    function TreeWalker(impl) {\n      setWrapper(impl, this);\n    }\n    TreeWalker.prototype = {\n      get root() {\n        return wrap(unsafeUnwrap(this).root);\n      },\n      get currentNode() {\n        return wrap(unsafeUnwrap(this).currentNode);\n      },\n      set currentNode(node) {\n        unsafeUnwrap(this).currentNode = unwrapIfNeeded(node);\n      },\n      get filter() {\n        return unsafeUnwrap(this).filter;\n      },\n      parentNode: function() {\n        return wrap(unsafeUnwrap(this).parentNode());\n      },\n      firstChild: function() {\n        return wrap(unsafeUnwrap(this).firstChild());\n      },\n      lastChild: function() {\n        return wrap(unsafeUnwrap(this).lastChild());\n      },\n      previousSibling: function() {\n        return wrap(unsafeUnwrap(this).previousSibling());\n      },\n      previousNode: function() {\n        return wrap(unsafeUnwrap(this).previousNode());\n      },\n      nextNode: function() {\n        return wrap(unsafeUnwrap(this).nextNode());\n      }\n    };\n    registerWrapper(OriginalTreeWalker, TreeWalker);\n    scope.wrappers.TreeWalker = TreeWalker;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var GetElementsByInterface = scope.GetElementsByInterface;\n    var Node = scope.wrappers.Node;\n    var ParentNodeInterface = scope.ParentNodeInterface;\n    var NonElementParentNodeInterface = scope.NonElementParentNodeInterface;\n    var Selection = scope.wrappers.Selection;\n    var SelectorsInterface = scope.SelectorsInterface;\n    var ShadowRoot = scope.wrappers.ShadowRoot;\n    var TreeScope = scope.TreeScope;\n    var cloneNode = scope.cloneNode;\n    var defineWrapGetter = scope.defineWrapGetter;\n    var elementFromPoint = scope.elementFromPoint;\n    var forwardMethodsToWrapper = scope.forwardMethodsToWrapper;\n    var matchesNames = scope.matchesNames;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var renderAllPending = scope.renderAllPending;\n    var rewrap = scope.rewrap;\n    var setWrapper = scope.setWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var unwrap = scope.unwrap;\n    var wrap = scope.wrap;\n    var wrapEventTargetMethods = scope.wrapEventTargetMethods;\n    var wrapNodeList = scope.wrapNodeList;\n    var implementationTable = new WeakMap();\n    function Document(node) {\n      Node.call(this, node);\n      this.treeScope_ = new TreeScope(this, null);\n    }\n    Document.prototype = Object.create(Node.prototype);\n    defineWrapGetter(Document, \"documentElement\");\n    defineWrapGetter(Document, \"body\");\n    defineWrapGetter(Document, \"head\");\n    function wrapMethod(name) {\n      var original = document[name];\n      Document.prototype[name] = function() {\n        return wrap(original.apply(unsafeUnwrap(this), arguments));\n      };\n    }\n    [ \"createComment\", \"createDocumentFragment\", \"createElement\", \"createElementNS\", \"createEvent\", \"createEventNS\", \"createRange\", \"createTextNode\" ].forEach(wrapMethod);\n    var originalAdoptNode = document.adoptNode;\n    function adoptNodeNoRemove(node, doc) {\n      originalAdoptNode.call(unsafeUnwrap(doc), unwrap(node));\n      adoptSubtree(node, doc);\n    }\n    function adoptSubtree(node, doc) {\n      if (node.shadowRoot) doc.adoptNode(node.shadowRoot);\n      if (node instanceof ShadowRoot) adoptOlderShadowRoots(node, doc);\n      for (var child = node.firstChild; child; child = child.nextSibling) {\n        adoptSubtree(child, doc);\n      }\n    }\n    function adoptOlderShadowRoots(shadowRoot, doc) {\n      var oldShadowRoot = shadowRoot.olderShadowRoot;\n      if (oldShadowRoot) doc.adoptNode(oldShadowRoot);\n    }\n    var originalGetSelection = document.getSelection;\n    mixin(Document.prototype, {\n      adoptNode: function(node) {\n        if (node.parentNode) node.parentNode.removeChild(node);\n        adoptNodeNoRemove(node, this);\n        return node;\n      },\n      elementFromPoint: function(x, y) {\n        return elementFromPoint(this, this, x, y);\n      },\n      importNode: function(node, deep) {\n        return cloneNode(node, deep, unsafeUnwrap(this));\n      },\n      getSelection: function() {\n        renderAllPending();\n        return new Selection(originalGetSelection.call(unwrap(this)));\n      },\n      getElementsByName: function(name) {\n        return SelectorsInterface.querySelectorAll.call(this, \"[name=\" + JSON.stringify(String(name)) + \"]\");\n      }\n    });\n    var originalCreateTreeWalker = document.createTreeWalker;\n    var TreeWalkerWrapper = scope.wrappers.TreeWalker;\n    Document.prototype.createTreeWalker = function(root, whatToShow, filter, expandEntityReferences) {\n      var newFilter = null;\n      if (filter) {\n        if (filter.acceptNode && typeof filter.acceptNode === \"function\") {\n          newFilter = {\n            acceptNode: function(node) {\n              return filter.acceptNode(wrap(node));\n            }\n          };\n        } else if (typeof filter === \"function\") {\n          newFilter = function(node) {\n            return filter(wrap(node));\n          };\n        }\n      }\n      return new TreeWalkerWrapper(originalCreateTreeWalker.call(unwrap(this), unwrap(root), whatToShow, newFilter, expandEntityReferences));\n    };\n    if (document.registerElement) {\n      var originalRegisterElement = document.registerElement;\n      Document.prototype.registerElement = function(tagName, object) {\n        var prototype, extendsOption;\n        if (object !== undefined) {\n          prototype = object.prototype;\n          extendsOption = object.extends;\n        }\n        if (!prototype) prototype = Object.create(HTMLElement.prototype);\n        if (scope.nativePrototypeTable.get(prototype)) {\n          throw new Error(\"NotSupportedError\");\n        }\n        var proto = Object.getPrototypeOf(prototype);\n        var nativePrototype;\n        var prototypes = [];\n        while (proto) {\n          nativePrototype = scope.nativePrototypeTable.get(proto);\n          if (nativePrototype) break;\n          prototypes.push(proto);\n          proto = Object.getPrototypeOf(proto);\n        }\n        if (!nativePrototype) {\n          throw new Error(\"NotSupportedError\");\n        }\n        var newPrototype = Object.create(nativePrototype);\n        for (var i = prototypes.length - 1; i >= 0; i--) {\n          newPrototype = Object.create(newPrototype);\n        }\n        [ \"createdCallback\", \"attachedCallback\", \"detachedCallback\", \"attributeChangedCallback\" ].forEach(function(name) {\n          var f = prototype[name];\n          if (!f) return;\n          newPrototype[name] = function() {\n            if (!(wrap(this) instanceof CustomElementConstructor)) {\n              rewrap(this);\n            }\n            f.apply(wrap(this), arguments);\n          };\n        });\n        var p = {\n          prototype: newPrototype\n        };\n        if (extendsOption) p.extends = extendsOption;\n        function CustomElementConstructor(node) {\n          if (!node) {\n            if (extendsOption) {\n              return document.createElement(extendsOption, tagName);\n            } else {\n              return document.createElement(tagName);\n            }\n          }\n          setWrapper(node, this);\n        }\n        CustomElementConstructor.prototype = prototype;\n        CustomElementConstructor.prototype.constructor = CustomElementConstructor;\n        scope.constructorTable.set(newPrototype, CustomElementConstructor);\n        scope.nativePrototypeTable.set(prototype, newPrototype);\n        var nativeConstructor = originalRegisterElement.call(unwrap(this), tagName, p);\n        return CustomElementConstructor;\n      };\n      forwardMethodsToWrapper([ window.HTMLDocument || window.Document ], [ \"registerElement\" ]);\n    }\n    forwardMethodsToWrapper([ window.HTMLBodyElement, window.HTMLDocument || window.Document, window.HTMLHeadElement, window.HTMLHtmlElement ], [ \"appendChild\", \"compareDocumentPosition\", \"contains\", \"getElementsByClassName\", \"getElementsByTagName\", \"getElementsByTagNameNS\", \"insertBefore\", \"querySelector\", \"querySelectorAll\", \"removeChild\", \"replaceChild\" ]);\n    forwardMethodsToWrapper([ window.HTMLBodyElement, window.HTMLHeadElement, window.HTMLHtmlElement ], matchesNames);\n    forwardMethodsToWrapper([ window.HTMLDocument || window.Document ], [ \"adoptNode\", \"importNode\", \"contains\", \"createComment\", \"createDocumentFragment\", \"createElement\", \"createElementNS\", \"createEvent\", \"createEventNS\", \"createRange\", \"createTextNode\", \"createTreeWalker\", \"elementFromPoint\", \"getElementById\", \"getElementsByName\", \"getSelection\" ]);\n    mixin(Document.prototype, GetElementsByInterface);\n    mixin(Document.prototype, ParentNodeInterface);\n    mixin(Document.prototype, SelectorsInterface);\n    mixin(Document.prototype, NonElementParentNodeInterface);\n    mixin(Document.prototype, {\n      get implementation() {\n        var implementation = implementationTable.get(this);\n        if (implementation) return implementation;\n        implementation = new DOMImplementation(unwrap(this).implementation);\n        implementationTable.set(this, implementation);\n        return implementation;\n      },\n      get defaultView() {\n        return wrap(unwrap(this).defaultView);\n      }\n    });\n    registerWrapper(window.Document, Document, document.implementation.createHTMLDocument(\"\"));\n    if (window.HTMLDocument) registerWrapper(window.HTMLDocument, Document);\n    wrapEventTargetMethods([ window.HTMLBodyElement, window.HTMLDocument || window.Document, window.HTMLHeadElement ]);\n    function DOMImplementation(impl) {\n      setWrapper(impl, this);\n    }\n    var originalCreateDocument = document.implementation.createDocument;\n    DOMImplementation.prototype.createDocument = function() {\n      arguments[2] = unwrap(arguments[2]);\n      return wrap(originalCreateDocument.apply(unsafeUnwrap(this), arguments));\n    };\n    function wrapImplMethod(constructor, name) {\n      var original = document.implementation[name];\n      constructor.prototype[name] = function() {\n        return wrap(original.apply(unsafeUnwrap(this), arguments));\n      };\n    }\n    function forwardImplMethod(constructor, name) {\n      var original = document.implementation[name];\n      constructor.prototype[name] = function() {\n        return original.apply(unsafeUnwrap(this), arguments);\n      };\n    }\n    wrapImplMethod(DOMImplementation, \"createDocumentType\");\n    wrapImplMethod(DOMImplementation, \"createHTMLDocument\");\n    forwardImplMethod(DOMImplementation, \"hasFeature\");\n    registerWrapper(window.DOMImplementation, DOMImplementation);\n    forwardMethodsToWrapper([ window.DOMImplementation ], [ \"createDocument\", \"createDocumentType\", \"createHTMLDocument\", \"hasFeature\" ]);\n    scope.adoptNodeNoRemove = adoptNodeNoRemove;\n    scope.wrappers.DOMImplementation = DOMImplementation;\n    scope.wrappers.Document = Document;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var EventTarget = scope.wrappers.EventTarget;\n    var Selection = scope.wrappers.Selection;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var renderAllPending = scope.renderAllPending;\n    var unwrap = scope.unwrap;\n    var unwrapIfNeeded = scope.unwrapIfNeeded;\n    var wrap = scope.wrap;\n    var OriginalWindow = window.Window;\n    var originalGetComputedStyle = window.getComputedStyle;\n    var originalGetDefaultComputedStyle = window.getDefaultComputedStyle;\n    var originalGetSelection = window.getSelection;\n    function Window(impl) {\n      EventTarget.call(this, impl);\n    }\n    Window.prototype = Object.create(EventTarget.prototype);\n    OriginalWindow.prototype.getComputedStyle = function(el, pseudo) {\n      return wrap(this || window).getComputedStyle(unwrapIfNeeded(el), pseudo);\n    };\n    if (originalGetDefaultComputedStyle) {\n      OriginalWindow.prototype.getDefaultComputedStyle = function(el, pseudo) {\n        return wrap(this || window).getDefaultComputedStyle(unwrapIfNeeded(el), pseudo);\n      };\n    }\n    OriginalWindow.prototype.getSelection = function() {\n      return wrap(this || window).getSelection();\n    };\n    delete window.getComputedStyle;\n    delete window.getDefaultComputedStyle;\n    delete window.getSelection;\n    [ \"addEventListener\", \"removeEventListener\", \"dispatchEvent\" ].forEach(function(name) {\n      OriginalWindow.prototype[name] = function() {\n        var w = wrap(this || window);\n        return w[name].apply(w, arguments);\n      };\n      delete window[name];\n    });\n    mixin(Window.prototype, {\n      getComputedStyle: function(el, pseudo) {\n        renderAllPending();\n        return originalGetComputedStyle.call(unwrap(this), unwrapIfNeeded(el), pseudo);\n      },\n      getSelection: function() {\n        renderAllPending();\n        return new Selection(originalGetSelection.call(unwrap(this)));\n      },\n      get document() {\n        return wrap(unwrap(this).document);\n      }\n    });\n    if (originalGetDefaultComputedStyle) {\n      Window.prototype.getDefaultComputedStyle = function(el, pseudo) {\n        renderAllPending();\n        return originalGetDefaultComputedStyle.call(unwrap(this), unwrapIfNeeded(el), pseudo);\n      };\n    }\n    registerWrapper(OriginalWindow, Window, window);\n    scope.wrappers.Window = Window;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var unwrap = scope.unwrap;\n    var OriginalDataTransfer = window.DataTransfer || window.Clipboard;\n    var OriginalDataTransferSetDragImage = OriginalDataTransfer.prototype.setDragImage;\n    if (OriginalDataTransferSetDragImage) {\n      OriginalDataTransfer.prototype.setDragImage = function(image, x, y) {\n        OriginalDataTransferSetDragImage.call(this, unwrap(image), x, y);\n      };\n    }\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var registerWrapper = scope.registerWrapper;\n    var setWrapper = scope.setWrapper;\n    var unwrap = scope.unwrap;\n    var OriginalFormData = window.FormData;\n    if (!OriginalFormData) return;\n    function FormData(formElement) {\n      var impl;\n      if (formElement instanceof OriginalFormData) {\n        impl = formElement;\n      } else {\n        impl = new OriginalFormData(formElement && unwrap(formElement));\n      }\n      setWrapper(impl, this);\n    }\n    registerWrapper(OriginalFormData, FormData, new OriginalFormData());\n    scope.wrappers.FormData = FormData;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var unwrapIfNeeded = scope.unwrapIfNeeded;\n    var originalSend = XMLHttpRequest.prototype.send;\n    XMLHttpRequest.prototype.send = function(obj) {\n      return originalSend.call(this, unwrapIfNeeded(obj));\n    };\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var isWrapperFor = scope.isWrapperFor;\n    var elements = {\n      a: \"HTMLAnchorElement\",\n      area: \"HTMLAreaElement\",\n      audio: \"HTMLAudioElement\",\n      base: \"HTMLBaseElement\",\n      body: \"HTMLBodyElement\",\n      br: \"HTMLBRElement\",\n      button: \"HTMLButtonElement\",\n      canvas: \"HTMLCanvasElement\",\n      caption: \"HTMLTableCaptionElement\",\n      col: \"HTMLTableColElement\",\n      content: \"HTMLContentElement\",\n      data: \"HTMLDataElement\",\n      datalist: \"HTMLDataListElement\",\n      del: \"HTMLModElement\",\n      dir: \"HTMLDirectoryElement\",\n      div: \"HTMLDivElement\",\n      dl: \"HTMLDListElement\",\n      embed: \"HTMLEmbedElement\",\n      fieldset: \"HTMLFieldSetElement\",\n      font: \"HTMLFontElement\",\n      form: \"HTMLFormElement\",\n      frame: \"HTMLFrameElement\",\n      frameset: \"HTMLFrameSetElement\",\n      h1: \"HTMLHeadingElement\",\n      head: \"HTMLHeadElement\",\n      hr: \"HTMLHRElement\",\n      html: \"HTMLHtmlElement\",\n      iframe: \"HTMLIFrameElement\",\n      img: \"HTMLImageElement\",\n      input: \"HTMLInputElement\",\n      keygen: \"HTMLKeygenElement\",\n      label: \"HTMLLabelElement\",\n      legend: \"HTMLLegendElement\",\n      li: \"HTMLLIElement\",\n      link: \"HTMLLinkElement\",\n      map: \"HTMLMapElement\",\n      marquee: \"HTMLMarqueeElement\",\n      menu: \"HTMLMenuElement\",\n      menuitem: \"HTMLMenuItemElement\",\n      meta: \"HTMLMetaElement\",\n      meter: \"HTMLMeterElement\",\n      object: \"HTMLObjectElement\",\n      ol: \"HTMLOListElement\",\n      optgroup: \"HTMLOptGroupElement\",\n      option: \"HTMLOptionElement\",\n      output: \"HTMLOutputElement\",\n      p: \"HTMLParagraphElement\",\n      param: \"HTMLParamElement\",\n      pre: \"HTMLPreElement\",\n      progress: \"HTMLProgressElement\",\n      q: \"HTMLQuoteElement\",\n      script: \"HTMLScriptElement\",\n      select: \"HTMLSelectElement\",\n      shadow: \"HTMLShadowElement\",\n      source: \"HTMLSourceElement\",\n      span: \"HTMLSpanElement\",\n      style: \"HTMLStyleElement\",\n      table: \"HTMLTableElement\",\n      tbody: \"HTMLTableSectionElement\",\n      template: \"HTMLTemplateElement\",\n      textarea: \"HTMLTextAreaElement\",\n      thead: \"HTMLTableSectionElement\",\n      time: \"HTMLTimeElement\",\n      title: \"HTMLTitleElement\",\n      tr: \"HTMLTableRowElement\",\n      track: \"HTMLTrackElement\",\n      ul: \"HTMLUListElement\",\n      video: \"HTMLVideoElement\"\n    };\n    function overrideConstructor(tagName) {\n      var nativeConstructorName = elements[tagName];\n      var nativeConstructor = window[nativeConstructorName];\n      if (!nativeConstructor) return;\n      var element = document.createElement(tagName);\n      var wrapperConstructor = element.constructor;\n      window[nativeConstructorName] = wrapperConstructor;\n    }\n    Object.keys(elements).forEach(overrideConstructor);\n    Object.getOwnPropertyNames(scope.wrappers).forEach(function(name) {\n      window[name] = scope.wrappers[name];\n    });\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    var ShadowCSS = {\n      strictStyling: false,\n      registry: {},\n      shimStyling: function(root, name, extendsName) {\n        var scopeStyles = this.prepareRoot(root, name, extendsName);\n        var typeExtension = this.isTypeExtension(extendsName);\n        var scopeSelector = this.makeScopeSelector(name, typeExtension);\n        var cssText = stylesToCssText(scopeStyles, true);\n        cssText = this.scopeCssText(cssText, scopeSelector);\n        if (root) {\n          root.shimmedStyle = cssText;\n        }\n        this.addCssToDocument(cssText, name);\n      },\n      shimStyle: function(style, selector) {\n        return this.shimCssText(style.textContent, selector);\n      },\n      shimCssText: function(cssText, selector) {\n        cssText = this.insertDirectives(cssText);\n        return this.scopeCssText(cssText, selector);\n      },\n      makeScopeSelector: function(name, typeExtension) {\n        if (name) {\n          return typeExtension ? \"[is=\" + name + \"]\" : name;\n        }\n        return \"\";\n      },\n      isTypeExtension: function(extendsName) {\n        return extendsName && extendsName.indexOf(\"-\") < 0;\n      },\n      prepareRoot: function(root, name, extendsName) {\n        var def = this.registerRoot(root, name, extendsName);\n        this.replaceTextInStyles(def.rootStyles, this.insertDirectives);\n        this.removeStyles(root, def.rootStyles);\n        if (this.strictStyling) {\n          this.applyScopeToContent(root, name);\n        }\n        return def.scopeStyles;\n      },\n      removeStyles: function(root, styles) {\n        for (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++) {\n          s.parentNode.removeChild(s);\n        }\n      },\n      registerRoot: function(root, name, extendsName) {\n        var def = this.registry[name] = {\n          root: root,\n          name: name,\n          extendsName: extendsName\n        };\n        var styles = this.findStyles(root);\n        def.rootStyles = styles;\n        def.scopeStyles = def.rootStyles;\n        var extendee = this.registry[def.extendsName];\n        if (extendee) {\n          def.scopeStyles = extendee.scopeStyles.concat(def.scopeStyles);\n        }\n        return def;\n      },\n      findStyles: function(root) {\n        if (!root) {\n          return [];\n        }\n        var styles = root.querySelectorAll(\"style\");\n        return Array.prototype.filter.call(styles, function(s) {\n          return !s.hasAttribute(NO_SHIM_ATTRIBUTE);\n        });\n      },\n      applyScopeToContent: function(root, name) {\n        if (root) {\n          Array.prototype.forEach.call(root.querySelectorAll(\"*\"), function(node) {\n            node.setAttribute(name, \"\");\n          });\n          Array.prototype.forEach.call(root.querySelectorAll(\"template\"), function(template) {\n            this.applyScopeToContent(template.content, name);\n          }, this);\n        }\n      },\n      insertDirectives: function(cssText) {\n        cssText = this.insertPolyfillDirectivesInCssText(cssText);\n        return this.insertPolyfillRulesInCssText(cssText);\n      },\n      insertPolyfillDirectivesInCssText: function(cssText) {\n        cssText = cssText.replace(cssCommentNextSelectorRe, function(match, p1) {\n          return p1.slice(0, -2) + \"{\";\n        });\n        return cssText.replace(cssContentNextSelectorRe, function(match, p1) {\n          return p1 + \" {\";\n        });\n      },\n      insertPolyfillRulesInCssText: function(cssText) {\n        cssText = cssText.replace(cssCommentRuleRe, function(match, p1) {\n          return p1.slice(0, -1);\n        });\n        return cssText.replace(cssContentRuleRe, function(match, p1, p2, p3) {\n          var rule = match.replace(p1, \"\").replace(p2, \"\");\n          return p3 + rule;\n        });\n      },\n      scopeCssText: function(cssText, scopeSelector) {\n        var unscoped = this.extractUnscopedRulesFromCssText(cssText);\n        cssText = this.insertPolyfillHostInCssText(cssText);\n        cssText = this.convertColonHost(cssText);\n        cssText = this.convertColonHostContext(cssText);\n        cssText = this.convertShadowDOMSelectors(cssText);\n        if (scopeSelector) {\n          var self = this, cssText;\n          withCssRules(cssText, function(rules) {\n            cssText = self.scopeRules(rules, scopeSelector);\n          });\n        }\n        cssText = cssText + \"\\n\" + unscoped;\n        return cssText.trim();\n      },\n      extractUnscopedRulesFromCssText: function(cssText) {\n        var r = \"\", m;\n        while (m = cssCommentUnscopedRuleRe.exec(cssText)) {\n          r += m[1].slice(0, -1) + \"\\n\\n\";\n        }\n        while (m = cssContentUnscopedRuleRe.exec(cssText)) {\n          r += m[0].replace(m[2], \"\").replace(m[1], m[3]) + \"\\n\\n\";\n        }\n        return r;\n      },\n      convertColonHost: function(cssText) {\n        return this.convertColonRule(cssText, cssColonHostRe, this.colonHostPartReplacer);\n      },\n      convertColonHostContext: function(cssText) {\n        return this.convertColonRule(cssText, cssColonHostContextRe, this.colonHostContextPartReplacer);\n      },\n      convertColonRule: function(cssText, regExp, partReplacer) {\n        return cssText.replace(regExp, function(m, p1, p2, p3) {\n          p1 = polyfillHostNoCombinator;\n          if (p2) {\n            var parts = p2.split(\",\"), r = [];\n            for (var i = 0, l = parts.length, p; i < l && (p = parts[i]); i++) {\n              p = p.trim();\n              r.push(partReplacer(p1, p, p3));\n            }\n            return r.join(\",\");\n          } else {\n            return p1 + p3;\n          }\n        });\n      },\n      colonHostContextPartReplacer: function(host, part, suffix) {\n        if (part.match(polyfillHost)) {\n          return this.colonHostPartReplacer(host, part, suffix);\n        } else {\n          return host + part + suffix + \", \" + part + \" \" + host + suffix;\n        }\n      },\n      colonHostPartReplacer: function(host, part, suffix) {\n        return host + part.replace(polyfillHost, \"\") + suffix;\n      },\n      convertShadowDOMSelectors: function(cssText) {\n        for (var i = 0; i < shadowDOMSelectorsRe.length; i++) {\n          cssText = cssText.replace(shadowDOMSelectorsRe[i], \" \");\n        }\n        return cssText;\n      },\n      scopeRules: function(cssRules, scopeSelector) {\n        var cssText = \"\";\n        if (cssRules) {\n          Array.prototype.forEach.call(cssRules, function(rule) {\n            if (rule.selectorText && (rule.style && rule.style.cssText !== undefined)) {\n              cssText += this.scopeSelector(rule.selectorText, scopeSelector, this.strictStyling) + \" {\\n\t\";\n              cssText += this.propertiesFromRule(rule) + \"\\n}\\n\\n\";\n            } else if (rule.type === CSSRule.MEDIA_RULE) {\n              cssText += \"@media \" + rule.media.mediaText + \" {\\n\";\n              cssText += this.scopeRules(rule.cssRules, scopeSelector);\n              cssText += \"\\n}\\n\\n\";\n            } else {\n              try {\n                if (rule.cssText) {\n                  cssText += rule.cssText + \"\\n\\n\";\n                }\n              } catch (x) {\n                if (rule.type === CSSRule.KEYFRAMES_RULE && rule.cssRules) {\n                  cssText += this.ieSafeCssTextFromKeyFrameRule(rule);\n                }\n              }\n            }\n          }, this);\n        }\n        return cssText;\n      },\n      ieSafeCssTextFromKeyFrameRule: function(rule) {\n        var cssText = \"@keyframes \" + rule.name + \" {\";\n        Array.prototype.forEach.call(rule.cssRules, function(rule) {\n          cssText += \" \" + rule.keyText + \" {\" + rule.style.cssText + \"}\";\n        });\n        cssText += \" }\";\n        return cssText;\n      },\n      scopeSelector: function(selector, scopeSelector, strict) {\n        var r = [], parts = selector.split(\",\");\n        parts.forEach(function(p) {\n          p = p.trim();\n          if (this.selectorNeedsScoping(p, scopeSelector)) {\n            p = strict && !p.match(polyfillHostNoCombinator) ? this.applyStrictSelectorScope(p, scopeSelector) : this.applySelectorScope(p, scopeSelector);\n          }\n          r.push(p);\n        }, this);\n        return r.join(\", \");\n      },\n      selectorNeedsScoping: function(selector, scopeSelector) {\n        if (Array.isArray(scopeSelector)) {\n          return true;\n        }\n        var re = this.makeScopeMatcher(scopeSelector);\n        return !selector.match(re);\n      },\n      makeScopeMatcher: function(scopeSelector) {\n        scopeSelector = scopeSelector.replace(/\\[/g, \"\\\\[\").replace(/\\]/g, \"\\\\]\");\n        return new RegExp(\"^(\" + scopeSelector + \")\" + selectorReSuffix, \"m\");\n      },\n      applySelectorScope: function(selector, selectorScope) {\n        return Array.isArray(selectorScope) ? this.applySelectorScopeList(selector, selectorScope) : this.applySimpleSelectorScope(selector, selectorScope);\n      },\n      applySelectorScopeList: function(selector, scopeSelectorList) {\n        var r = [];\n        for (var i = 0, s; s = scopeSelectorList[i]; i++) {\n          r.push(this.applySimpleSelectorScope(selector, s));\n        }\n        return r.join(\", \");\n      },\n      applySimpleSelectorScope: function(selector, scopeSelector) {\n        if (selector.match(polyfillHostRe)) {\n          selector = selector.replace(polyfillHostNoCombinator, scopeSelector);\n          return selector.replace(polyfillHostRe, scopeSelector + \" \");\n        } else {\n          return scopeSelector + \" \" + selector;\n        }\n      },\n      applyStrictSelectorScope: function(selector, scopeSelector) {\n        scopeSelector = scopeSelector.replace(/\\[is=([^\\]]*)\\]/g, \"$1\");\n        var splits = [ \" \", \">\", \"+\", \"~\" ], scoped = selector, attrName = \"[\" + scopeSelector + \"]\";\n        splits.forEach(function(sep) {\n          var parts = scoped.split(sep);\n          scoped = parts.map(function(p) {\n            var t = p.trim().replace(polyfillHostRe, \"\");\n            if (t && splits.indexOf(t) < 0 && t.indexOf(attrName) < 0) {\n              p = t.replace(/([^:]*)(:*)(.*)/, \"$1\" + attrName + \"$2$3\");\n            }\n            return p;\n          }).join(sep);\n        });\n        return scoped;\n      },\n      insertPolyfillHostInCssText: function(selector) {\n        return selector.replace(colonHostContextRe, polyfillHostContext).replace(colonHostRe, polyfillHost);\n      },\n      propertiesFromRule: function(rule) {\n        var cssText = rule.style.cssText;\n        if (rule.style.content && !rule.style.content.match(/['\"]+|attr/)) {\n          cssText = cssText.replace(/content:[^;]*;/g, \"content: '\" + rule.style.content + \"';\");\n        }\n        var style = rule.style;\n        for (var i in style) {\n          if (style[i] === \"initial\") {\n            cssText += i + \": initial; \";\n          }\n        }\n        return cssText;\n      },\n      replaceTextInStyles: function(styles, action) {\n        if (styles && action) {\n          if (!(styles instanceof Array)) {\n            styles = [ styles ];\n          }\n          Array.prototype.forEach.call(styles, function(s) {\n            s.textContent = action.call(this, s.textContent);\n          }, this);\n        }\n      },\n      addCssToDocument: function(cssText, name) {\n        if (cssText.match(\"@import\")) {\n          addOwnSheet(cssText, name);\n        } else {\n          addCssToDocument(cssText);\n        }\n      }\n    };\n    var selectorRe = /([^{]*)({[\\s\\S]*?})/gim, cssCommentRe = /\\/\\*[^*]*\\*+([^\\/*][^*]*\\*+)*\\//gim, cssCommentNextSelectorRe = /\\/\\*\\s*@polyfill ([^*]*\\*+([^\\/*][^*]*\\*+)*\\/)([^{]*?){/gim, cssContentNextSelectorRe = /polyfill-next-selector[^}]*content\\:[\\s]*?['\"](.*?)['\"][;\\s]*}([^{]*?){/gim, cssCommentRuleRe = /\\/\\*\\s@polyfill-rule([^*]*\\*+([^\\/*][^*]*\\*+)*)\\//gim, cssContentRuleRe = /(polyfill-rule)[^}]*(content\\:[\\s]*['\"](.*?)['\"])[;\\s]*[^}]*}/gim, cssCommentUnscopedRuleRe = /\\/\\*\\s@polyfill-unscoped-rule([^*]*\\*+([^\\/*][^*]*\\*+)*)\\//gim, cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content\\:[\\s]*['\"](.*?)['\"])[;\\s]*[^}]*}/gim, cssPseudoRe = /::(x-[^\\s{,(]*)/gim, cssPartRe = /::part\\(([^)]*)\\)/gim, polyfillHost = \"-shadowcsshost\", polyfillHostContext = \"-shadowcsscontext\", parenSuffix = \")(?:\\\\((\" + \"(?:\\\\([^)(]*\\\\)|[^)(]*)+?\" + \")\\\\))?([^,{]*)\";\n    var cssColonHostRe = new RegExp(\"(\" + polyfillHost + parenSuffix, \"gim\"), cssColonHostContextRe = new RegExp(\"(\" + polyfillHostContext + parenSuffix, \"gim\"), selectorReSuffix = \"([>\\\\s~+[.,{:][\\\\s\\\\S]*)?$\", colonHostRe = /\\:host/gim, colonHostContextRe = /\\:host-context/gim, polyfillHostNoCombinator = polyfillHost + \"-no-combinator\", polyfillHostRe = new RegExp(polyfillHost, \"gim\"), polyfillHostContextRe = new RegExp(polyfillHostContext, \"gim\"), shadowDOMSelectorsRe = [ />>>/g, /::shadow/g, /::content/g, /\\/deep\\//g, /\\/shadow\\//g, /\\/shadow-deep\\//g, /\\^\\^/g, /\\^/g ];\n    function stylesToCssText(styles, preserveComments) {\n      var cssText = \"\";\n      Array.prototype.forEach.call(styles, function(s) {\n        cssText += s.textContent + \"\\n\\n\";\n      });\n      if (!preserveComments) {\n        cssText = cssText.replace(cssCommentRe, \"\");\n      }\n      return cssText;\n    }\n    function cssTextToStyle(cssText) {\n      var style = document.createElement(\"style\");\n      style.textContent = cssText;\n      return style;\n    }\n    function cssToRules(cssText) {\n      var style = cssTextToStyle(cssText);\n      document.head.appendChild(style);\n      var rules = [];\n      if (style.sheet) {\n        try {\n          rules = style.sheet.cssRules;\n        } catch (e) {}\n      } else {\n        console.warn(\"sheet not found\", style);\n      }\n      style.parentNode.removeChild(style);\n      return rules;\n    }\n    var frame = document.createElement(\"iframe\");\n    frame.style.display = \"none\";\n    function initFrame() {\n      frame.initialized = true;\n      document.body.appendChild(frame);\n      var doc = frame.contentDocument;\n      var base = doc.createElement(\"base\");\n      base.href = document.baseURI;\n      doc.head.appendChild(base);\n    }\n    function inFrame(fn) {\n      if (!frame.initialized) {\n        initFrame();\n      }\n      document.body.appendChild(frame);\n      fn(frame.contentDocument);\n      document.body.removeChild(frame);\n    }\n    var isChrome = navigator.userAgent.match(\"Chrome\");\n    function withCssRules(cssText, callback) {\n      if (!callback) {\n        return;\n      }\n      var rules;\n      if (cssText.match(\"@import\") && isChrome) {\n        var style = cssTextToStyle(cssText);\n        inFrame(function(doc) {\n          doc.head.appendChild(style.impl);\n          rules = Array.prototype.slice.call(style.sheet.cssRules, 0);\n          callback(rules);\n        });\n      } else {\n        rules = cssToRules(cssText);\n        callback(rules);\n      }\n    }\n    function rulesToCss(cssRules) {\n      for (var i = 0, css = []; i < cssRules.length; i++) {\n        css.push(cssRules[i].cssText);\n      }\n      return css.join(\"\\n\\n\");\n    }\n    function addCssToDocument(cssText) {\n      if (cssText) {\n        getSheet().appendChild(document.createTextNode(cssText));\n      }\n    }\n    function addOwnSheet(cssText, name) {\n      var style = cssTextToStyle(cssText);\n      style.setAttribute(name, \"\");\n      style.setAttribute(SHIMMED_ATTRIBUTE, \"\");\n      document.head.appendChild(style);\n    }\n    var SHIM_ATTRIBUTE = \"shim-shadowdom\";\n    var SHIMMED_ATTRIBUTE = \"shim-shadowdom-css\";\n    var NO_SHIM_ATTRIBUTE = \"no-shim\";\n    var sheet;\n    function getSheet() {\n      if (!sheet) {\n        sheet = document.createElement(\"style\");\n        sheet.setAttribute(SHIMMED_ATTRIBUTE, \"\");\n        sheet[SHIMMED_ATTRIBUTE] = true;\n      }\n      return sheet;\n    }\n    if (window.ShadowDOMPolyfill) {\n      addCssToDocument(\"style { display: none !important; }\\n\");\n      var doc = ShadowDOMPolyfill.wrap(document);\n      var head = doc.querySelector(\"head\");\n      head.insertBefore(getSheet(), head.childNodes[0]);\n      document.addEventListener(\"DOMContentLoaded\", function() {\n        var urlResolver = scope.urlResolver;\n        if (window.HTMLImports && !HTMLImports.useNative) {\n          var SHIM_SHEET_SELECTOR = \"link[rel=stylesheet]\" + \"[\" + SHIM_ATTRIBUTE + \"]\";\n          var SHIM_STYLE_SELECTOR = \"style[\" + SHIM_ATTRIBUTE + \"]\";\n          HTMLImports.importer.documentPreloadSelectors += \",\" + SHIM_SHEET_SELECTOR;\n          HTMLImports.importer.importsPreloadSelectors += \",\" + SHIM_SHEET_SELECTOR;\n          HTMLImports.parser.documentSelectors = [ HTMLImports.parser.documentSelectors, SHIM_SHEET_SELECTOR, SHIM_STYLE_SELECTOR ].join(\",\");\n          var originalParseGeneric = HTMLImports.parser.parseGeneric;\n          HTMLImports.parser.parseGeneric = function(elt) {\n            if (elt[SHIMMED_ATTRIBUTE]) {\n              return;\n            }\n            var style = elt.__importElement || elt;\n            if (!style.hasAttribute(SHIM_ATTRIBUTE)) {\n              originalParseGeneric.call(this, elt);\n              return;\n            }\n            if (elt.__resource) {\n              style = elt.ownerDocument.createElement(\"style\");\n              style.textContent = elt.__resource;\n            }\n            HTMLImports.path.resolveUrlsInStyle(style, elt.href);\n            style.textContent = ShadowCSS.shimStyle(style);\n            style.removeAttribute(SHIM_ATTRIBUTE, \"\");\n            style.setAttribute(SHIMMED_ATTRIBUTE, \"\");\n            style[SHIMMED_ATTRIBUTE] = true;\n            if (style.parentNode !== head) {\n              if (elt.parentNode === head) {\n                head.replaceChild(style, elt);\n              } else {\n                this.addElementToDocument(style);\n              }\n            }\n            style.__importParsed = true;\n            this.markParsingComplete(elt);\n            this.parseNext();\n          };\n          var hasResource = HTMLImports.parser.hasResource;\n          HTMLImports.parser.hasResource = function(node) {\n            if (node.localName === \"link\" && node.rel === \"stylesheet\" && node.hasAttribute(SHIM_ATTRIBUTE)) {\n              return node.__resource;\n            } else {\n              return hasResource.call(this, node);\n            }\n          };\n        }\n      });\n    }\n    scope.ShadowCSS = ShadowCSS;\n  })(window.WebComponents);\n}\n\n(function(scope) {\n  if (window.ShadowDOMPolyfill) {\n    window.wrap = ShadowDOMPolyfill.wrapIfNeeded;\n    window.unwrap = ShadowDOMPolyfill.unwrapIfNeeded;\n  } else {\n    window.wrap = window.unwrap = function(n) {\n      return n;\n    };\n  }\n})(window.WebComponents);\n\n(function(scope) {\n  \"use strict\";\n  var hasWorkingUrl = false;\n  if (!scope.forceJURL) {\n    try {\n      var u = new URL(\"b\", \"http://a\");\n      u.pathname = \"c%20d\";\n      hasWorkingUrl = u.href === \"http://a/c%20d\";\n    } catch (e) {}\n  }\n  if (hasWorkingUrl) return;\n  var relative = Object.create(null);\n  relative[\"ftp\"] = 21;\n  relative[\"file\"] = 0;\n  relative[\"gopher\"] = 70;\n  relative[\"http\"] = 80;\n  relative[\"https\"] = 443;\n  relative[\"ws\"] = 80;\n  relative[\"wss\"] = 443;\n  var relativePathDotMapping = Object.create(null);\n  relativePathDotMapping[\"%2e\"] = \".\";\n  relativePathDotMapping[\".%2e\"] = \"..\";\n  relativePathDotMapping[\"%2e.\"] = \"..\";\n  relativePathDotMapping[\"%2e%2e\"] = \"..\";\n  function isRelativeScheme(scheme) {\n    return relative[scheme] !== undefined;\n  }\n  function invalid() {\n    clear.call(this);\n    this._isInvalid = true;\n  }\n  function IDNAToASCII(h) {\n    if (\"\" == h) {\n      invalid.call(this);\n    }\n    return h.toLowerCase();\n  }\n  function percentEscape(c) {\n    var unicode = c.charCodeAt(0);\n    if (unicode > 32 && unicode < 127 && [ 34, 35, 60, 62, 63, 96 ].indexOf(unicode) == -1) {\n      return c;\n    }\n    return encodeURIComponent(c);\n  }\n  function percentEscapeQuery(c) {\n    var unicode = c.charCodeAt(0);\n    if (unicode > 32 && unicode < 127 && [ 34, 35, 60, 62, 96 ].indexOf(unicode) == -1) {\n      return c;\n    }\n    return encodeURIComponent(c);\n  }\n  var EOF = undefined, ALPHA = /[a-zA-Z]/, ALPHANUMERIC = /[a-zA-Z0-9\\+\\-\\.]/;\n  function parse(input, stateOverride, base) {\n    function err(message) {\n      errors.push(message);\n    }\n    var state = stateOverride || \"scheme start\", cursor = 0, buffer = \"\", seenAt = false, seenBracket = false, errors = [];\n    loop: while ((input[cursor - 1] != EOF || cursor == 0) && !this._isInvalid) {\n      var c = input[cursor];\n      switch (state) {\n       case \"scheme start\":\n        if (c && ALPHA.test(c)) {\n          buffer += c.toLowerCase();\n          state = \"scheme\";\n        } else if (!stateOverride) {\n          buffer = \"\";\n          state = \"no scheme\";\n          continue;\n        } else {\n          err(\"Invalid scheme.\");\n          break loop;\n        }\n        break;\n\n       case \"scheme\":\n        if (c && ALPHANUMERIC.test(c)) {\n          buffer += c.toLowerCase();\n        } else if (\":\" == c) {\n          this._scheme = buffer;\n          buffer = \"\";\n          if (stateOverride) {\n            break loop;\n          }\n          if (isRelativeScheme(this._scheme)) {\n            this._isRelative = true;\n          }\n          if (\"file\" == this._scheme) {\n            state = \"relative\";\n          } else if (this._isRelative && base && base._scheme == this._scheme) {\n            state = \"relative or authority\";\n          } else if (this._isRelative) {\n            state = \"authority first slash\";\n          } else {\n            state = \"scheme data\";\n          }\n        } else if (!stateOverride) {\n          buffer = \"\";\n          cursor = 0;\n          state = \"no scheme\";\n          continue;\n        } else if (EOF == c) {\n          break loop;\n        } else {\n          err(\"Code point not allowed in scheme: \" + c);\n          break loop;\n        }\n        break;\n\n       case \"scheme data\":\n        if (\"?\" == c) {\n          query = \"?\";\n          state = \"query\";\n        } else if (\"#\" == c) {\n          this._fragment = \"#\";\n          state = \"fragment\";\n        } else {\n          if (EOF != c && \"\t\" != c && \"\\n\" != c && \"\\r\" != c) {\n            this._schemeData += percentEscape(c);\n          }\n        }\n        break;\n\n       case \"no scheme\":\n        if (!base || !isRelativeScheme(base._scheme)) {\n          err(\"Missing scheme.\");\n          invalid.call(this);\n        } else {\n          state = \"relative\";\n          continue;\n        }\n        break;\n\n       case \"relative or authority\":\n        if (\"/\" == c && \"/\" == input[cursor + 1]) {\n          state = \"authority ignore slashes\";\n        } else {\n          err(\"Expected /, got: \" + c);\n          state = \"relative\";\n          continue;\n        }\n        break;\n\n       case \"relative\":\n        this._isRelative = true;\n        if (\"file\" != this._scheme) this._scheme = base._scheme;\n        if (EOF == c) {\n          this._host = base._host;\n          this._port = base._port;\n          this._path = base._path.slice();\n          this._query = base._query;\n          this._username = base._username;\n          this._password = base._password;\n          break loop;\n        } else if (\"/\" == c || \"\\\\\" == c) {\n          if (\"\\\\\" == c) err(\"\\\\ is an invalid code point.\");\n          state = \"relative slash\";\n        } else if (\"?\" == c) {\n          this._host = base._host;\n          this._port = base._port;\n          this._path = base._path.slice();\n          this._query = \"?\";\n          this._username = base._username;\n          this._password = base._password;\n          state = \"query\";\n        } else if (\"#\" == c) {\n          this._host = base._host;\n          this._port = base._port;\n          this._path = base._path.slice();\n          this._query = base._query;\n          this._fragment = \"#\";\n          this._username = base._username;\n          this._password = base._password;\n          state = \"fragment\";\n        } else {\n          var nextC = input[cursor + 1];\n          var nextNextC = input[cursor + 2];\n          if (\"file\" != this._scheme || !ALPHA.test(c) || nextC != \":\" && nextC != \"|\" || EOF != nextNextC && \"/\" != nextNextC && \"\\\\\" != nextNextC && \"?\" != nextNextC && \"#\" != nextNextC) {\n            this._host = base._host;\n            this._port = base._port;\n            this._username = base._username;\n            this._password = base._password;\n            this._path = base._path.slice();\n            this._path.pop();\n          }\n          state = \"relative path\";\n          continue;\n        }\n        break;\n\n       case \"relative slash\":\n        if (\"/\" == c || \"\\\\\" == c) {\n          if (\"\\\\\" == c) {\n            err(\"\\\\ is an invalid code point.\");\n          }\n          if (\"file\" == this._scheme) {\n            state = \"file host\";\n          } else {\n            state = \"authority ignore slashes\";\n          }\n        } else {\n          if (\"file\" != this._scheme) {\n            this._host = base._host;\n            this._port = base._port;\n            this._username = base._username;\n            this._password = base._password;\n          }\n          state = \"relative path\";\n          continue;\n        }\n        break;\n\n       case \"authority first slash\":\n        if (\"/\" == c) {\n          state = \"authority second slash\";\n        } else {\n          err(\"Expected '/', got: \" + c);\n          state = \"authority ignore slashes\";\n          continue;\n        }\n        break;\n\n       case \"authority second slash\":\n        state = \"authority ignore slashes\";\n        if (\"/\" != c) {\n          err(\"Expected '/', got: \" + c);\n          continue;\n        }\n        break;\n\n       case \"authority ignore slashes\":\n        if (\"/\" != c && \"\\\\\" != c) {\n          state = \"authority\";\n          continue;\n        } else {\n          err(\"Expected authority, got: \" + c);\n        }\n        break;\n\n       case \"authority\":\n        if (\"@\" == c) {\n          if (seenAt) {\n            err(\"@ already seen.\");\n            buffer += \"%40\";\n          }\n          seenAt = true;\n          for (var i = 0; i < buffer.length; i++) {\n            var cp = buffer[i];\n            if (\"\t\" == cp || \"\\n\" == cp || \"\\r\" == cp) {\n              err(\"Invalid whitespace in authority.\");\n              continue;\n            }\n            if (\":\" == cp && null === this._password) {\n              this._password = \"\";\n              continue;\n            }\n            var tempC = percentEscape(cp);\n            null !== this._password ? this._password += tempC : this._username += tempC;\n          }\n          buffer = \"\";\n        } else if (EOF == c || \"/\" == c || \"\\\\\" == c || \"?\" == c || \"#\" == c) {\n          cursor -= buffer.length;\n          buffer = \"\";\n          state = \"host\";\n          continue;\n        } else {\n          buffer += c;\n        }\n        break;\n\n       case \"file host\":\n        if (EOF == c || \"/\" == c || \"\\\\\" == c || \"?\" == c || \"#\" == c) {\n          if (buffer.length == 2 && ALPHA.test(buffer[0]) && (buffer[1] == \":\" || buffer[1] == \"|\")) {\n            state = \"relative path\";\n          } else if (buffer.length == 0) {\n            state = \"relative path start\";\n          } else {\n            this._host = IDNAToASCII.call(this, buffer);\n            buffer = \"\";\n            state = \"relative path start\";\n          }\n          continue;\n        } else if (\"\t\" == c || \"\\n\" == c || \"\\r\" == c) {\n          err(\"Invalid whitespace in file host.\");\n        } else {\n          buffer += c;\n        }\n        break;\n\n       case \"host\":\n       case \"hostname\":\n        if (\":\" == c && !seenBracket) {\n          this._host = IDNAToASCII.call(this, buffer);\n          buffer = \"\";\n          state = \"port\";\n          if (\"hostname\" == stateOverride) {\n            break loop;\n          }\n        } else if (EOF == c || \"/\" == c || \"\\\\\" == c || \"?\" == c || \"#\" == c) {\n          this._host = IDNAToASCII.call(this, buffer);\n          buffer = \"\";\n          state = \"relative path start\";\n          if (stateOverride) {\n            break loop;\n          }\n          continue;\n        } else if (\"\t\" != c && \"\\n\" != c && \"\\r\" != c) {\n          if (\"[\" == c) {\n            seenBracket = true;\n          } else if (\"]\" == c) {\n            seenBracket = false;\n          }\n          buffer += c;\n        } else {\n          err(\"Invalid code point in host/hostname: \" + c);\n        }\n        break;\n\n       case \"port\":\n        if (/[0-9]/.test(c)) {\n          buffer += c;\n        } else if (EOF == c || \"/\" == c || \"\\\\\" == c || \"?\" == c || \"#\" == c || stateOverride) {\n          if (\"\" != buffer) {\n            var temp = parseInt(buffer, 10);\n            if (temp != relative[this._scheme]) {\n              this._port = temp + \"\";\n            }\n            buffer = \"\";\n          }\n          if (stateOverride) {\n            break loop;\n          }\n          state = \"relative path start\";\n          continue;\n        } else if (\"\t\" == c || \"\\n\" == c || \"\\r\" == c) {\n          err(\"Invalid code point in port: \" + c);\n        } else {\n          invalid.call(this);\n        }\n        break;\n\n       case \"relative path start\":\n        if (\"\\\\\" == c) err(\"'\\\\' not allowed in path.\");\n        state = \"relative path\";\n        if (\"/\" != c && \"\\\\\" != c) {\n          continue;\n        }\n        break;\n\n       case \"relative path\":\n        if (EOF == c || \"/\" == c || \"\\\\\" == c || !stateOverride && (\"?\" == c || \"#\" == c)) {\n          if (\"\\\\\" == c) {\n            err(\"\\\\ not allowed in relative path.\");\n          }\n          var tmp;\n          if (tmp = relativePathDotMapping[buffer.toLowerCase()]) {\n            buffer = tmp;\n          }\n          if (\"..\" == buffer) {\n            this._path.pop();\n            if (\"/\" != c && \"\\\\\" != c) {\n              this._path.push(\"\");\n            }\n          } else if (\".\" == buffer && \"/\" != c && \"\\\\\" != c) {\n            this._path.push(\"\");\n          } else if (\".\" != buffer) {\n            if (\"file\" == this._scheme && this._path.length == 0 && buffer.length == 2 && ALPHA.test(buffer[0]) && buffer[1] == \"|\") {\n              buffer = buffer[0] + \":\";\n            }\n            this._path.push(buffer);\n          }\n          buffer = \"\";\n          if (\"?\" == c) {\n            this._query = \"?\";\n            state = \"query\";\n          } else if (\"#\" == c) {\n            this._fragment = \"#\";\n            state = \"fragment\";\n          }\n        } else if (\"\t\" != c && \"\\n\" != c && \"\\r\" != c) {\n          buffer += percentEscape(c);\n        }\n        break;\n\n       case \"query\":\n        if (!stateOverride && \"#\" == c) {\n          this._fragment = \"#\";\n          state = \"fragment\";\n        } else if (EOF != c && \"\t\" != c && \"\\n\" != c && \"\\r\" != c) {\n          this._query += percentEscapeQuery(c);\n        }\n        break;\n\n       case \"fragment\":\n        if (EOF != c && \"\t\" != c && \"\\n\" != c && \"\\r\" != c) {\n          this._fragment += c;\n        }\n        break;\n      }\n      cursor++;\n    }\n  }\n  function clear() {\n    this._scheme = \"\";\n    this._schemeData = \"\";\n    this._username = \"\";\n    this._password = null;\n    this._host = \"\";\n    this._port = \"\";\n    this._path = [];\n    this._query = \"\";\n    this._fragment = \"\";\n    this._isInvalid = false;\n    this._isRelative = false;\n  }\n  function jURL(url, base) {\n    if (base !== undefined && !(base instanceof jURL)) base = new jURL(String(base));\n    this._url = url;\n    clear.call(this);\n    var input = url.replace(/^[ \\t\\r\\n\\f]+|[ \\t\\r\\n\\f]+$/g, \"\");\n    parse.call(this, input, null, base);\n  }\n  jURL.prototype = {\n    toString: function() {\n      return this.href;\n    },\n    get href() {\n      if (this._isInvalid) return this._url;\n      var authority = \"\";\n      if (\"\" != this._username || null != this._password) {\n        authority = this._username + (null != this._password ? \":\" + this._password : \"\") + \"@\";\n      }\n      return this.protocol + (this._isRelative ? \"//\" + authority + this.host : \"\") + this.pathname + this._query + this._fragment;\n    },\n    set href(href) {\n      clear.call(this);\n      parse.call(this, href);\n    },\n    get protocol() {\n      return this._scheme + \":\";\n    },\n    set protocol(protocol) {\n      if (this._isInvalid) return;\n      parse.call(this, protocol + \":\", \"scheme start\");\n    },\n    get host() {\n      return this._isInvalid ? \"\" : this._port ? this._host + \":\" + this._port : this._host;\n    },\n    set host(host) {\n      if (this._isInvalid || !this._isRelative) return;\n      parse.call(this, host, \"host\");\n    },\n    get hostname() {\n      return this._host;\n    },\n    set hostname(hostname) {\n      if (this._isInvalid || !this._isRelative) return;\n      parse.call(this, hostname, \"hostname\");\n    },\n    get port() {\n      return this._port;\n    },\n    set port(port) {\n      if (this._isInvalid || !this._isRelative) return;\n      parse.call(this, port, \"port\");\n    },\n    get pathname() {\n      return this._isInvalid ? \"\" : this._isRelative ? \"/\" + this._path.join(\"/\") : this._schemeData;\n    },\n    set pathname(pathname) {\n      if (this._isInvalid || !this._isRelative) return;\n      this._path = [];\n      parse.call(this, pathname, \"relative path start\");\n    },\n    get search() {\n      return this._isInvalid || !this._query || \"?\" == this._query ? \"\" : this._query;\n    },\n    set search(search) {\n      if (this._isInvalid || !this._isRelative) return;\n      this._query = \"?\";\n      if (\"?\" == search[0]) search = search.slice(1);\n      parse.call(this, search, \"query\");\n    },\n    get hash() {\n      return this._isInvalid || !this._fragment || \"#\" == this._fragment ? \"\" : this._fragment;\n    },\n    set hash(hash) {\n      if (this._isInvalid) return;\n      this._fragment = \"#\";\n      if (\"#\" == hash[0]) hash = hash.slice(1);\n      parse.call(this, hash, \"fragment\");\n    },\n    get origin() {\n      var host;\n      if (this._isInvalid || !this._scheme) {\n        return \"\";\n      }\n      switch (this._scheme) {\n       case \"data\":\n       case \"file\":\n       case \"javascript\":\n       case \"mailto\":\n        return \"null\";\n      }\n      host = this.host;\n      if (!host) {\n        return \"\";\n      }\n      return this._scheme + \"://\" + host;\n    }\n  };\n  var OriginalURL = scope.URL;\n  if (OriginalURL) {\n    jURL.createObjectURL = function(blob) {\n      return OriginalURL.createObjectURL.apply(OriginalURL, arguments);\n    };\n    jURL.revokeObjectURL = function(url) {\n      OriginalURL.revokeObjectURL(url);\n    };\n  }\n  scope.URL = jURL;\n})(this);\n\n(function(global) {\n  var registrationsTable = new WeakMap();\n  var setImmediate;\n  if (/Trident|Edge/.test(navigator.userAgent)) {\n    setImmediate = setTimeout;\n  } else if (window.setImmediate) {\n    setImmediate = window.setImmediate;\n  } else {\n    var setImmediateQueue = [];\n    var sentinel = String(Math.random());\n    window.addEventListener(\"message\", function(e) {\n      if (e.data === sentinel) {\n        var queue = setImmediateQueue;\n        setImmediateQueue = [];\n        queue.forEach(function(func) {\n          func();\n        });\n      }\n    });\n    setImmediate = function(func) {\n      setImmediateQueue.push(func);\n      window.postMessage(sentinel, \"*\");\n    };\n  }\n  var isScheduled = false;\n  var scheduledObservers = [];\n  function scheduleCallback(observer) {\n    scheduledObservers.push(observer);\n    if (!isScheduled) {\n      isScheduled = true;\n      setImmediate(dispatchCallbacks);\n    }\n  }\n  function wrapIfNeeded(node) {\n    return window.ShadowDOMPolyfill && window.ShadowDOMPolyfill.wrapIfNeeded(node) || node;\n  }\n  function dispatchCallbacks() {\n    isScheduled = false;\n    var observers = scheduledObservers;\n    scheduledObservers = [];\n    observers.sort(function(o1, o2) {\n      return o1.uid_ - o2.uid_;\n    });\n    var anyNonEmpty = false;\n    observers.forEach(function(observer) {\n      var queue = observer.takeRecords();\n      removeTransientObserversFor(observer);\n      if (queue.length) {\n        observer.callback_(queue, observer);\n        anyNonEmpty = true;\n      }\n    });\n    if (anyNonEmpty) dispatchCallbacks();\n  }\n  function removeTransientObserversFor(observer) {\n    observer.nodes_.forEach(function(node) {\n      var registrations = registrationsTable.get(node);\n      if (!registrations) return;\n      registrations.forEach(function(registration) {\n        if (registration.observer === observer) registration.removeTransientObservers();\n      });\n    });\n  }\n  function forEachAncestorAndObserverEnqueueRecord(target, callback) {\n    for (var node = target; node; node = node.parentNode) {\n      var registrations = registrationsTable.get(node);\n      if (registrations) {\n        for (var j = 0; j < registrations.length; j++) {\n          var registration = registrations[j];\n          var options = registration.options;\n          if (node !== target && !options.subtree) continue;\n          var record = callback(options);\n          if (record) registration.enqueue(record);\n        }\n      }\n    }\n  }\n  var uidCounter = 0;\n  function JsMutationObserver(callback) {\n    this.callback_ = callback;\n    this.nodes_ = [];\n    this.records_ = [];\n    this.uid_ = ++uidCounter;\n  }\n  JsMutationObserver.prototype = {\n    observe: function(target, options) {\n      target = wrapIfNeeded(target);\n      if (!options.childList && !options.attributes && !options.characterData || options.attributeOldValue && !options.attributes || options.attributeFilter && options.attributeFilter.length && !options.attributes || options.characterDataOldValue && !options.characterData) {\n        throw new SyntaxError();\n      }\n      var registrations = registrationsTable.get(target);\n      if (!registrations) registrationsTable.set(target, registrations = []);\n      var registration;\n      for (var i = 0; i < registrations.length; i++) {\n        if (registrations[i].observer === this) {\n          registration = registrations[i];\n          registration.removeListeners();\n          registration.options = options;\n          break;\n        }\n      }\n      if (!registration) {\n        registration = new Registration(this, target, options);\n        registrations.push(registration);\n        this.nodes_.push(target);\n      }\n      registration.addListeners();\n    },\n    disconnect: function() {\n      this.nodes_.forEach(function(node) {\n        var registrations = registrationsTable.get(node);\n        for (var i = 0; i < registrations.length; i++) {\n          var registration = registrations[i];\n          if (registration.observer === this) {\n            registration.removeListeners();\n            registrations.splice(i, 1);\n            break;\n          }\n        }\n      }, this);\n      this.records_ = [];\n    },\n    takeRecords: function() {\n      var copyOfRecords = this.records_;\n      this.records_ = [];\n      return copyOfRecords;\n    }\n  };\n  function MutationRecord(type, target) {\n    this.type = type;\n    this.target = target;\n    this.addedNodes = [];\n    this.removedNodes = [];\n    this.previousSibling = null;\n    this.nextSibling = null;\n    this.attributeName = null;\n    this.attributeNamespace = null;\n    this.oldValue = null;\n  }\n  function copyMutationRecord(original) {\n    var record = new MutationRecord(original.type, original.target);\n    record.addedNodes = original.addedNodes.slice();\n    record.removedNodes = original.removedNodes.slice();\n    record.previousSibling = original.previousSibling;\n    record.nextSibling = original.nextSibling;\n    record.attributeName = original.attributeName;\n    record.attributeNamespace = original.attributeNamespace;\n    record.oldValue = original.oldValue;\n    return record;\n  }\n  var currentRecord, recordWithOldValue;\n  function getRecord(type, target) {\n    return currentRecord = new MutationRecord(type, target);\n  }\n  function getRecordWithOldValue(oldValue) {\n    if (recordWithOldValue) return recordWithOldValue;\n    recordWithOldValue = copyMutationRecord(currentRecord);\n    recordWithOldValue.oldValue = oldValue;\n    return recordWithOldValue;\n  }\n  function clearRecords() {\n    currentRecord = recordWithOldValue = undefined;\n  }\n  function recordRepresentsCurrentMutation(record) {\n    return record === recordWithOldValue || record === currentRecord;\n  }\n  function selectRecord(lastRecord, newRecord) {\n    if (lastRecord === newRecord) return lastRecord;\n    if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord)) return recordWithOldValue;\n    return null;\n  }\n  function Registration(observer, target, options) {\n    this.observer = observer;\n    this.target = target;\n    this.options = options;\n    this.transientObservedNodes = [];\n  }\n  Registration.prototype = {\n    enqueue: function(record) {\n      var records = this.observer.records_;\n      var length = records.length;\n      if (records.length > 0) {\n        var lastRecord = records[length - 1];\n        var recordToReplaceLast = selectRecord(lastRecord, record);\n        if (recordToReplaceLast) {\n          records[length - 1] = recordToReplaceLast;\n          return;\n        }\n      } else {\n        scheduleCallback(this.observer);\n      }\n      records[length] = record;\n    },\n    addListeners: function() {\n      this.addListeners_(this.target);\n    },\n    addListeners_: function(node) {\n      var options = this.options;\n      if (options.attributes) node.addEventListener(\"DOMAttrModified\", this, true);\n      if (options.characterData) node.addEventListener(\"DOMCharacterDataModified\", this, true);\n      if (options.childList) node.addEventListener(\"DOMNodeInserted\", this, true);\n      if (options.childList || options.subtree) node.addEventListener(\"DOMNodeRemoved\", this, true);\n    },\n    removeListeners: function() {\n      this.removeListeners_(this.target);\n    },\n    removeListeners_: function(node) {\n      var options = this.options;\n      if (options.attributes) node.removeEventListener(\"DOMAttrModified\", this, true);\n      if (options.characterData) node.removeEventListener(\"DOMCharacterDataModified\", this, true);\n      if (options.childList) node.removeEventListener(\"DOMNodeInserted\", this, true);\n      if (options.childList || options.subtree) node.removeEventListener(\"DOMNodeRemoved\", this, true);\n    },\n    addTransientObserver: function(node) {\n      if (node === this.target) return;\n      this.addListeners_(node);\n      this.transientObservedNodes.push(node);\n      var registrations = registrationsTable.get(node);\n      if (!registrations) registrationsTable.set(node, registrations = []);\n      registrations.push(this);\n    },\n    removeTransientObservers: function() {\n      var transientObservedNodes = this.transientObservedNodes;\n      this.transientObservedNodes = [];\n      transientObservedNodes.forEach(function(node) {\n        this.removeListeners_(node);\n        var registrations = registrationsTable.get(node);\n        for (var i = 0; i < registrations.length; i++) {\n          if (registrations[i] === this) {\n            registrations.splice(i, 1);\n            break;\n          }\n        }\n      }, this);\n    },\n    handleEvent: function(e) {\n      e.stopImmediatePropagation();\n      switch (e.type) {\n       case \"DOMAttrModified\":\n        var name = e.attrName;\n        var namespace = e.relatedNode.namespaceURI;\n        var target = e.target;\n        var record = new getRecord(\"attributes\", target);\n        record.attributeName = name;\n        record.attributeNamespace = namespace;\n        var oldValue = e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;\n        forEachAncestorAndObserverEnqueueRecord(target, function(options) {\n          if (!options.attributes) return;\n          if (options.attributeFilter && options.attributeFilter.length && options.attributeFilter.indexOf(name) === -1 && options.attributeFilter.indexOf(namespace) === -1) {\n            return;\n          }\n          if (options.attributeOldValue) return getRecordWithOldValue(oldValue);\n          return record;\n        });\n        break;\n\n       case \"DOMCharacterDataModified\":\n        var target = e.target;\n        var record = getRecord(\"characterData\", target);\n        var oldValue = e.prevValue;\n        forEachAncestorAndObserverEnqueueRecord(target, function(options) {\n          if (!options.characterData) return;\n          if (options.characterDataOldValue) return getRecordWithOldValue(oldValue);\n          return record;\n        });\n        break;\n\n       case \"DOMNodeRemoved\":\n        this.addTransientObserver(e.target);\n\n       case \"DOMNodeInserted\":\n        var changedNode = e.target;\n        var addedNodes, removedNodes;\n        if (e.type === \"DOMNodeInserted\") {\n          addedNodes = [ changedNode ];\n          removedNodes = [];\n        } else {\n          addedNodes = [];\n          removedNodes = [ changedNode ];\n        }\n        var previousSibling = changedNode.previousSibling;\n        var nextSibling = changedNode.nextSibling;\n        var record = getRecord(\"childList\", e.target.parentNode);\n        record.addedNodes = addedNodes;\n        record.removedNodes = removedNodes;\n        record.previousSibling = previousSibling;\n        record.nextSibling = nextSibling;\n        forEachAncestorAndObserverEnqueueRecord(e.relatedNode, function(options) {\n          if (!options.childList) return;\n          return record;\n        });\n      }\n      clearRecords();\n    }\n  };\n  global.JsMutationObserver = JsMutationObserver;\n  if (!global.MutationObserver) global.MutationObserver = JsMutationObserver;\n})(this);\n\nwindow.HTMLImports = window.HTMLImports || {\n  flags: {}\n};\n\n(function(scope) {\n  var IMPORT_LINK_TYPE = \"import\";\n  var useNative = Boolean(IMPORT_LINK_TYPE in document.createElement(\"link\"));\n  var hasShadowDOMPolyfill = Boolean(window.ShadowDOMPolyfill);\n  var wrap = function(node) {\n    return hasShadowDOMPolyfill ? ShadowDOMPolyfill.wrapIfNeeded(node) : node;\n  };\n  var rootDocument = wrap(document);\n  var currentScriptDescriptor = {\n    get: function() {\n      var script = HTMLImports.currentScript || document.currentScript || (document.readyState !== \"complete\" ? document.scripts[document.scripts.length - 1] : null);\n      return wrap(script);\n    },\n    configurable: true\n  };\n  Object.defineProperty(document, \"_currentScript\", currentScriptDescriptor);\n  Object.defineProperty(rootDocument, \"_currentScript\", currentScriptDescriptor);\n  var isIE = /Trident|Edge/.test(navigator.userAgent);\n  function whenReady(callback, doc) {\n    doc = doc || rootDocument;\n    whenDocumentReady(function() {\n      watchImportsLoad(callback, doc);\n    }, doc);\n  }\n  var requiredReadyState = isIE ? \"complete\" : \"interactive\";\n  var READY_EVENT = \"readystatechange\";\n  function isDocumentReady(doc) {\n    return doc.readyState === \"complete\" || doc.readyState === requiredReadyState;\n  }\n  function whenDocumentReady(callback, doc) {\n    if (!isDocumentReady(doc)) {\n      var checkReady = function() {\n        if (doc.readyState === \"complete\" || doc.readyState === requiredReadyState) {\n          doc.removeEventListener(READY_EVENT, checkReady);\n          whenDocumentReady(callback, doc);\n        }\n      };\n      doc.addEventListener(READY_EVENT, checkReady);\n    } else if (callback) {\n      callback();\n    }\n  }\n  function markTargetLoaded(event) {\n    event.target.__loaded = true;\n  }\n  function watchImportsLoad(callback, doc) {\n    var imports = doc.querySelectorAll(\"link[rel=import]\");\n    var parsedCount = 0, importCount = imports.length, newImports = [], errorImports = [];\n    function checkDone() {\n      if (parsedCount == importCount && callback) {\n        callback({\n          allImports: imports,\n          loadedImports: newImports,\n          errorImports: errorImports\n        });\n      }\n    }\n    function loadedImport(e) {\n      markTargetLoaded(e);\n      newImports.push(this);\n      parsedCount++;\n      checkDone();\n    }\n    function errorLoadingImport(e) {\n      errorImports.push(this);\n      parsedCount++;\n      checkDone();\n    }\n    if (importCount) {\n      for (var i = 0, imp; i < importCount && (imp = imports[i]); i++) {\n        if (isImportLoaded(imp)) {\n          parsedCount++;\n          checkDone();\n        } else {\n          imp.addEventListener(\"load\", loadedImport);\n          imp.addEventListener(\"error\", errorLoadingImport);\n        }\n      }\n    } else {\n      checkDone();\n    }\n  }\n  function isImportLoaded(link) {\n    return useNative ? link.__loaded || link.import && link.import.readyState !== \"loading\" : link.__importParsed;\n  }\n  if (useNative) {\n    new MutationObserver(function(mxns) {\n      for (var i = 0, l = mxns.length, m; i < l && (m = mxns[i]); i++) {\n        if (m.addedNodes) {\n          handleImports(m.addedNodes);\n        }\n      }\n    }).observe(document.head, {\n      childList: true\n    });\n    function handleImports(nodes) {\n      for (var i = 0, l = nodes.length, n; i < l && (n = nodes[i]); i++) {\n        if (isImport(n)) {\n          handleImport(n);\n        }\n      }\n    }\n    function isImport(element) {\n      return element.localName === \"link\" && element.rel === \"import\";\n    }\n    function handleImport(element) {\n      var loaded = element.import;\n      if (loaded) {\n        markTargetLoaded({\n          target: element\n        });\n      } else {\n        element.addEventListener(\"load\", markTargetLoaded);\n        element.addEventListener(\"error\", markTargetLoaded);\n      }\n    }\n    (function() {\n      if (document.readyState === \"loading\") {\n        var imports = document.querySelectorAll(\"link[rel=import]\");\n        for (var i = 0, l = imports.length, imp; i < l && (imp = imports[i]); i++) {\n          handleImport(imp);\n        }\n      }\n    })();\n  }\n  whenReady(function(detail) {\n    HTMLImports.ready = true;\n    HTMLImports.readyTime = new Date().getTime();\n    var evt = rootDocument.createEvent(\"CustomEvent\");\n    evt.initCustomEvent(\"HTMLImportsLoaded\", true, true, detail);\n    rootDocument.dispatchEvent(evt);\n  });\n  scope.IMPORT_LINK_TYPE = IMPORT_LINK_TYPE;\n  scope.useNative = useNative;\n  scope.rootDocument = rootDocument;\n  scope.whenReady = whenReady;\n  scope.isIE = isIE;\n})(HTMLImports);\n\n(function(scope) {\n  var modules = [];\n  var addModule = function(module) {\n    modules.push(module);\n  };\n  var initializeModules = function() {\n    modules.forEach(function(module) {\n      module(scope);\n    });\n  };\n  scope.addModule = addModule;\n  scope.initializeModules = initializeModules;\n})(HTMLImports);\n\nHTMLImports.addModule(function(scope) {\n  var CSS_URL_REGEXP = /(url\\()([^)]*)(\\))/g;\n  var CSS_IMPORT_REGEXP = /(@import[\\s]+(?!url\\())([^;]*)(;)/g;\n  var path = {\n    resolveUrlsInStyle: function(style, linkUrl) {\n      var doc = style.ownerDocument;\n      var resolver = doc.createElement(\"a\");\n      style.textContent = this.resolveUrlsInCssText(style.textContent, linkUrl, resolver);\n      return style;\n    },\n    resolveUrlsInCssText: function(cssText, linkUrl, urlObj) {\n      var r = this.replaceUrls(cssText, urlObj, linkUrl, CSS_URL_REGEXP);\n      r = this.replaceUrls(r, urlObj, linkUrl, CSS_IMPORT_REGEXP);\n      return r;\n    },\n    replaceUrls: function(text, urlObj, linkUrl, regexp) {\n      return text.replace(regexp, function(m, pre, url, post) {\n        var urlPath = url.replace(/[\"']/g, \"\");\n        if (linkUrl) {\n          urlPath = new URL(urlPath, linkUrl).href;\n        }\n        urlObj.href = urlPath;\n        urlPath = urlObj.href;\n        return pre + \"'\" + urlPath + \"'\" + post;\n      });\n    }\n  };\n  scope.path = path;\n});\n\nHTMLImports.addModule(function(scope) {\n  var xhr = {\n    async: true,\n    ok: function(request) {\n      return request.status >= 200 && request.status < 300 || request.status === 304 || request.status === 0;\n    },\n    load: function(url, next, nextContext) {\n      var request = new XMLHttpRequest();\n      if (scope.flags.debug || scope.flags.bust) {\n        url += \"?\" + Math.random();\n      }\n      request.open(\"GET\", url, xhr.async);\n      request.addEventListener(\"readystatechange\", function(e) {\n        if (request.readyState === 4) {\n          var locationHeader = request.getResponseHeader(\"Location\");\n          var redirectedUrl = null;\n          if (locationHeader) {\n            var redirectedUrl = locationHeader.substr(0, 1) === \"/\" ? location.origin + locationHeader : locationHeader;\n          }\n          next.call(nextContext, !xhr.ok(request) && request, request.response || request.responseText, redirectedUrl);\n        }\n      });\n      request.send();\n      return request;\n    },\n    loadDocument: function(url, next, nextContext) {\n      this.load(url, next, nextContext).responseType = \"document\";\n    }\n  };\n  scope.xhr = xhr;\n});\n\nHTMLImports.addModule(function(scope) {\n  var xhr = scope.xhr;\n  var flags = scope.flags;\n  var Loader = function(onLoad, onComplete) {\n    this.cache = {};\n    this.onload = onLoad;\n    this.oncomplete = onComplete;\n    this.inflight = 0;\n    this.pending = {};\n  };\n  Loader.prototype = {\n    addNodes: function(nodes) {\n      this.inflight += nodes.length;\n      for (var i = 0, l = nodes.length, n; i < l && (n = nodes[i]); i++) {\n        this.require(n);\n      }\n      this.checkDone();\n    },\n    addNode: function(node) {\n      this.inflight++;\n      this.require(node);\n      this.checkDone();\n    },\n    require: function(elt) {\n      var url = elt.src || elt.href;\n      elt.__nodeUrl = url;\n      if (!this.dedupe(url, elt)) {\n        this.fetch(url, elt);\n      }\n    },\n    dedupe: function(url, elt) {\n      if (this.pending[url]) {\n        this.pending[url].push(elt);\n        return true;\n      }\n      var resource;\n      if (this.cache[url]) {\n        this.onload(url, elt, this.cache[url]);\n        this.tail();\n        return true;\n      }\n      this.pending[url] = [ elt ];\n      return false;\n    },\n    fetch: function(url, elt) {\n      flags.load && console.log(\"fetch\", url, elt);\n      if (!url) {\n        setTimeout(function() {\n          this.receive(url, elt, {\n            error: \"href must be specified\"\n          }, null);\n        }.bind(this), 0);\n      } else if (url.match(/^data:/)) {\n        var pieces = url.split(\",\");\n        var header = pieces[0];\n        var body = pieces[1];\n        if (header.indexOf(\";base64\") > -1) {\n          body = atob(body);\n        } else {\n          body = decodeURIComponent(body);\n        }\n        setTimeout(function() {\n          this.receive(url, elt, null, body);\n        }.bind(this), 0);\n      } else {\n        var receiveXhr = function(err, resource, redirectedUrl) {\n          this.receive(url, elt, err, resource, redirectedUrl);\n        }.bind(this);\n        xhr.load(url, receiveXhr);\n      }\n    },\n    receive: function(url, elt, err, resource, redirectedUrl) {\n      this.cache[url] = resource;\n      var $p = this.pending[url];\n      for (var i = 0, l = $p.length, p; i < l && (p = $p[i]); i++) {\n        this.onload(url, p, resource, err, redirectedUrl);\n        this.tail();\n      }\n      this.pending[url] = null;\n    },\n    tail: function() {\n      --this.inflight;\n      this.checkDone();\n    },\n    checkDone: function() {\n      if (!this.inflight) {\n        this.oncomplete();\n      }\n    }\n  };\n  scope.Loader = Loader;\n});\n\nHTMLImports.addModule(function(scope) {\n  var Observer = function(addCallback) {\n    this.addCallback = addCallback;\n    this.mo = new MutationObserver(this.handler.bind(this));\n  };\n  Observer.prototype = {\n    handler: function(mutations) {\n      for (var i = 0, l = mutations.length, m; i < l && (m = mutations[i]); i++) {\n        if (m.type === \"childList\" && m.addedNodes.length) {\n          this.addedNodes(m.addedNodes);\n        }\n      }\n    },\n    addedNodes: function(nodes) {\n      if (this.addCallback) {\n        this.addCallback(nodes);\n      }\n      for (var i = 0, l = nodes.length, n, loading; i < l && (n = nodes[i]); i++) {\n        if (n.children && n.children.length) {\n          this.addedNodes(n.children);\n        }\n      }\n    },\n    observe: function(root) {\n      this.mo.observe(root, {\n        childList: true,\n        subtree: true\n      });\n    }\n  };\n  scope.Observer = Observer;\n});\n\nHTMLImports.addModule(function(scope) {\n  var path = scope.path;\n  var rootDocument = scope.rootDocument;\n  var flags = scope.flags;\n  var isIE = scope.isIE;\n  var IMPORT_LINK_TYPE = scope.IMPORT_LINK_TYPE;\n  var IMPORT_SELECTOR = \"link[rel=\" + IMPORT_LINK_TYPE + \"]\";\n  var importParser = {\n    documentSelectors: IMPORT_SELECTOR,\n    importsSelectors: [ IMPORT_SELECTOR, \"link[rel=stylesheet]\", \"style\", \"script:not([type])\", 'script[type=\"application/javascript\"]', 'script[type=\"text/javascript\"]' ].join(\",\"),\n    map: {\n      link: \"parseLink\",\n      script: \"parseScript\",\n      style: \"parseStyle\"\n    },\n    dynamicElements: [],\n    parseNext: function() {\n      var next = this.nextToParse();\n      if (next) {\n        this.parse(next);\n      }\n    },\n    parse: function(elt) {\n      if (this.isParsed(elt)) {\n        flags.parse && console.log(\"[%s] is already parsed\", elt.localName);\n        return;\n      }\n      var fn = this[this.map[elt.localName]];\n      if (fn) {\n        this.markParsing(elt);\n        fn.call(this, elt);\n      }\n    },\n    parseDynamic: function(elt, quiet) {\n      this.dynamicElements.push(elt);\n      if (!quiet) {\n        this.parseNext();\n      }\n    },\n    markParsing: function(elt) {\n      flags.parse && console.log(\"parsing\", elt);\n      this.parsingElement = elt;\n    },\n    markParsingComplete: function(elt) {\n      elt.__importParsed = true;\n      this.markDynamicParsingComplete(elt);\n      if (elt.__importElement) {\n        elt.__importElement.__importParsed = true;\n        this.markDynamicParsingComplete(elt.__importElement);\n      }\n      this.parsingElement = null;\n      flags.parse && console.log(\"completed\", elt);\n    },\n    markDynamicParsingComplete: function(elt) {\n      var i = this.dynamicElements.indexOf(elt);\n      if (i >= 0) {\n        this.dynamicElements.splice(i, 1);\n      }\n    },\n    parseImport: function(elt) {\n      if (HTMLImports.__importsParsingHook) {\n        HTMLImports.__importsParsingHook(elt);\n      }\n      if (elt.import) {\n        elt.import.__importParsed = true;\n      }\n      this.markParsingComplete(elt);\n      if (elt.__resource && !elt.__error) {\n        elt.dispatchEvent(new CustomEvent(\"load\", {\n          bubbles: false\n        }));\n      } else {\n        elt.dispatchEvent(new CustomEvent(\"error\", {\n          bubbles: false\n        }));\n      }\n      if (elt.__pending) {\n        var fn;\n        while (elt.__pending.length) {\n          fn = elt.__pending.shift();\n          if (fn) {\n            fn({\n              target: elt\n            });\n          }\n        }\n      }\n      this.parseNext();\n    },\n    parseLink: function(linkElt) {\n      if (nodeIsImport(linkElt)) {\n        this.parseImport(linkElt);\n      } else {\n        linkElt.href = linkElt.href;\n        this.parseGeneric(linkElt);\n      }\n    },\n    parseStyle: function(elt) {\n      var src = elt;\n      elt = cloneStyle(elt);\n      src.__appliedElement = elt;\n      elt.__importElement = src;\n      this.parseGeneric(elt);\n    },\n    parseGeneric: function(elt) {\n      this.trackElement(elt);\n      this.addElementToDocument(elt);\n    },\n    rootImportForElement: function(elt) {\n      var n = elt;\n      while (n.ownerDocument.__importLink) {\n        n = n.ownerDocument.__importLink;\n      }\n      return n;\n    },\n    addElementToDocument: function(elt) {\n      var port = this.rootImportForElement(elt.__importElement || elt);\n      port.parentNode.insertBefore(elt, port);\n    },\n    trackElement: function(elt, callback) {\n      var self = this;\n      var done = function(e) {\n        if (callback) {\n          callback(e);\n        }\n        self.markParsingComplete(elt);\n        self.parseNext();\n      };\n      elt.addEventListener(\"load\", done);\n      elt.addEventListener(\"error\", done);\n      if (isIE && elt.localName === \"style\") {\n        var fakeLoad = false;\n        if (elt.textContent.indexOf(\"@import\") == -1) {\n          fakeLoad = true;\n        } else if (elt.sheet) {\n          fakeLoad = true;\n          var csr = elt.sheet.cssRules;\n          var len = csr ? csr.length : 0;\n          for (var i = 0, r; i < len && (r = csr[i]); i++) {\n            if (r.type === CSSRule.IMPORT_RULE) {\n              fakeLoad = fakeLoad && Boolean(r.styleSheet);\n            }\n          }\n        }\n        if (fakeLoad) {\n          setTimeout(function() {\n            elt.dispatchEvent(new CustomEvent(\"load\", {\n              bubbles: false\n            }));\n          });\n        }\n      }\n    },\n    parseScript: function(scriptElt) {\n      var script = document.createElement(\"script\");\n      script.__importElement = scriptElt;\n      script.src = scriptElt.src ? scriptElt.src : generateScriptDataUrl(scriptElt);\n      scope.currentScript = scriptElt;\n      this.trackElement(script, function(e) {\n        script.parentNode.removeChild(script);\n        scope.currentScript = null;\n      });\n      this.addElementToDocument(script);\n    },\n    nextToParse: function() {\n      this._mayParse = [];\n      return !this.parsingElement && (this.nextToParseInDoc(rootDocument) || this.nextToParseDynamic());\n    },\n    nextToParseInDoc: function(doc, link) {\n      if (doc && this._mayParse.indexOf(doc) < 0) {\n        this._mayParse.push(doc);\n        var nodes = doc.querySelectorAll(this.parseSelectorsForNode(doc));\n        for (var i = 0, l = nodes.length, p = 0, n; i < l && (n = nodes[i]); i++) {\n          if (!this.isParsed(n)) {\n            if (this.hasResource(n)) {\n              return nodeIsImport(n) ? this.nextToParseInDoc(n.import, n) : n;\n            } else {\n              return;\n            }\n          }\n        }\n      }\n      return link;\n    },\n    nextToParseDynamic: function() {\n      return this.dynamicElements[0];\n    },\n    parseSelectorsForNode: function(node) {\n      var doc = node.ownerDocument || node;\n      return doc === rootDocument ? this.documentSelectors : this.importsSelectors;\n    },\n    isParsed: function(node) {\n      return node.__importParsed;\n    },\n    needsDynamicParsing: function(elt) {\n      return this.dynamicElements.indexOf(elt) >= 0;\n    },\n    hasResource: function(node) {\n      if (nodeIsImport(node) && node.import === undefined) {\n        return false;\n      }\n      return true;\n    }\n  };\n  function nodeIsImport(elt) {\n    return elt.localName === \"link\" && elt.rel === IMPORT_LINK_TYPE;\n  }\n  function generateScriptDataUrl(script) {\n    var scriptContent = generateScriptContent(script);\n    return \"data:text/javascript;charset=utf-8,\" + encodeURIComponent(scriptContent);\n  }\n  function generateScriptContent(script) {\n    return script.textContent + generateSourceMapHint(script);\n  }\n  function generateSourceMapHint(script) {\n    var owner = script.ownerDocument;\n    owner.__importedScripts = owner.__importedScripts || 0;\n    var moniker = script.ownerDocument.baseURI;\n    var num = owner.__importedScripts ? \"-\" + owner.__importedScripts : \"\";\n    owner.__importedScripts++;\n    return \"\\n//# sourceURL=\" + moniker + num + \".js\\n\";\n  }\n  function cloneStyle(style) {\n    var clone = style.ownerDocument.createElement(\"style\");\n    clone.textContent = style.textContent;\n    path.resolveUrlsInStyle(clone);\n    return clone;\n  }\n  scope.parser = importParser;\n  scope.IMPORT_SELECTOR = IMPORT_SELECTOR;\n});\n\nHTMLImports.addModule(function(scope) {\n  var flags = scope.flags;\n  var IMPORT_LINK_TYPE = scope.IMPORT_LINK_TYPE;\n  var IMPORT_SELECTOR = scope.IMPORT_SELECTOR;\n  var rootDocument = scope.rootDocument;\n  var Loader = scope.Loader;\n  var Observer = scope.Observer;\n  var parser = scope.parser;\n  var importer = {\n    documents: {},\n    documentPreloadSelectors: IMPORT_SELECTOR,\n    importsPreloadSelectors: [ IMPORT_SELECTOR ].join(\",\"),\n    loadNode: function(node) {\n      importLoader.addNode(node);\n    },\n    loadSubtree: function(parent) {\n      var nodes = this.marshalNodes(parent);\n      importLoader.addNodes(nodes);\n    },\n    marshalNodes: function(parent) {\n      return parent.querySelectorAll(this.loadSelectorsForNode(parent));\n    },\n    loadSelectorsForNode: function(node) {\n      var doc = node.ownerDocument || node;\n      return doc === rootDocument ? this.documentPreloadSelectors : this.importsPreloadSelectors;\n    },\n    loaded: function(url, elt, resource, err, redirectedUrl) {\n      flags.load && console.log(\"loaded\", url, elt);\n      elt.__resource = resource;\n      elt.__error = err;\n      if (isImportLink(elt)) {\n        var doc = this.documents[url];\n        if (doc === undefined) {\n          doc = err ? null : makeDocument(resource, redirectedUrl || url);\n          if (doc) {\n            doc.__importLink = elt;\n            this.bootDocument(doc);\n          }\n          this.documents[url] = doc;\n        }\n        elt.import = doc;\n      }\n      parser.parseNext();\n    },\n    bootDocument: function(doc) {\n      this.loadSubtree(doc);\n      this.observer.observe(doc);\n      parser.parseNext();\n    },\n    loadedAll: function() {\n      parser.parseNext();\n    }\n  };\n  var importLoader = new Loader(importer.loaded.bind(importer), importer.loadedAll.bind(importer));\n  importer.observer = new Observer();\n  function isImportLink(elt) {\n    return isLinkRel(elt, IMPORT_LINK_TYPE);\n  }\n  function isLinkRel(elt, rel) {\n    return elt.localName === \"link\" && elt.getAttribute(\"rel\") === rel;\n  }\n  function hasBaseURIAccessor(doc) {\n    return !!Object.getOwnPropertyDescriptor(doc, \"baseURI\");\n  }\n  function makeDocument(resource, url) {\n    var doc = document.implementation.createHTMLDocument(IMPORT_LINK_TYPE);\n    doc._URL = url;\n    var base = doc.createElement(\"base\");\n    base.setAttribute(\"href\", url);\n    if (!doc.baseURI && !hasBaseURIAccessor(doc)) {\n      Object.defineProperty(doc, \"baseURI\", {\n        value: url\n      });\n    }\n    var meta = doc.createElement(\"meta\");\n    meta.setAttribute(\"charset\", \"utf-8\");\n    doc.head.appendChild(meta);\n    doc.head.appendChild(base);\n    doc.body.innerHTML = resource;\n    if (window.HTMLTemplateElement && HTMLTemplateElement.bootstrap) {\n      HTMLTemplateElement.bootstrap(doc);\n    }\n    return doc;\n  }\n  if (!document.baseURI) {\n    var baseURIDescriptor = {\n      get: function() {\n        var base = document.querySelector(\"base\");\n        return base ? base.href : window.location.href;\n      },\n      configurable: true\n    };\n    Object.defineProperty(document, \"baseURI\", baseURIDescriptor);\n    Object.defineProperty(rootDocument, \"baseURI\", baseURIDescriptor);\n  }\n  scope.importer = importer;\n  scope.importLoader = importLoader;\n});\n\nHTMLImports.addModule(function(scope) {\n  var parser = scope.parser;\n  var importer = scope.importer;\n  var dynamic = {\n    added: function(nodes) {\n      var owner, parsed, loading;\n      for (var i = 0, l = nodes.length, n; i < l && (n = nodes[i]); i++) {\n        if (!owner) {\n          owner = n.ownerDocument;\n          parsed = parser.isParsed(owner);\n        }\n        loading = this.shouldLoadNode(n);\n        if (loading) {\n          importer.loadNode(n);\n        }\n        if (this.shouldParseNode(n) && parsed) {\n          parser.parseDynamic(n, loading);\n        }\n      }\n    },\n    shouldLoadNode: function(node) {\n      return node.nodeType === 1 && matches.call(node, importer.loadSelectorsForNode(node));\n    },\n    shouldParseNode: function(node) {\n      return node.nodeType === 1 && matches.call(node, parser.parseSelectorsForNode(node));\n    }\n  };\n  importer.observer.addCallback = dynamic.added.bind(dynamic);\n  var matches = HTMLElement.prototype.matches || HTMLElement.prototype.matchesSelector || HTMLElement.prototype.webkitMatchesSelector || HTMLElement.prototype.mozMatchesSelector || HTMLElement.prototype.msMatchesSelector;\n});\n\n(function(scope) {\n  var initializeModules = scope.initializeModules;\n  var isIE = scope.isIE;\n  if (scope.useNative) {\n    return;\n  }\n  if (isIE && typeof window.CustomEvent !== \"function\") {\n    window.CustomEvent = function(inType, params) {\n      params = params || {};\n      var e = document.createEvent(\"CustomEvent\");\n      e.initCustomEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable), params.detail);\n      return e;\n    };\n    window.CustomEvent.prototype = window.Event.prototype;\n  }\n  initializeModules();\n  var rootDocument = scope.rootDocument;\n  function bootstrap() {\n    HTMLImports.importer.bootDocument(rootDocument);\n  }\n  if (document.readyState === \"complete\" || document.readyState === \"interactive\" && !window.attachEvent) {\n    bootstrap();\n  } else {\n    document.addEventListener(\"DOMContentLoaded\", bootstrap);\n  }\n})(HTMLImports);\n\nwindow.CustomElements = window.CustomElements || {\n  flags: {}\n};\n\n(function(scope) {\n  var flags = scope.flags;\n  var modules = [];\n  var addModule = function(module) {\n    modules.push(module);\n  };\n  var initializeModules = function() {\n    modules.forEach(function(module) {\n      module(scope);\n    });\n  };\n  scope.addModule = addModule;\n  scope.initializeModules = initializeModules;\n  scope.hasNative = Boolean(document.registerElement);\n  scope.useNative = !flags.register && scope.hasNative && !window.ShadowDOMPolyfill && (!window.HTMLImports || HTMLImports.useNative);\n})(CustomElements);\n\nCustomElements.addModule(function(scope) {\n  var IMPORT_LINK_TYPE = window.HTMLImports ? HTMLImports.IMPORT_LINK_TYPE : \"none\";\n  function forSubtree(node, cb) {\n    findAllElements(node, function(e) {\n      if (cb(e)) {\n        return true;\n      }\n      forRoots(e, cb);\n    });\n    forRoots(node, cb);\n  }\n  function findAllElements(node, find, data) {\n    var e = node.firstElementChild;\n    if (!e) {\n      e = node.firstChild;\n      while (e && e.nodeType !== Node.ELEMENT_NODE) {\n        e = e.nextSibling;\n      }\n    }\n    while (e) {\n      if (find(e, data) !== true) {\n        findAllElements(e, find, data);\n      }\n      e = e.nextElementSibling;\n    }\n    return null;\n  }\n  function forRoots(node, cb) {\n    var root = node.shadowRoot;\n    while (root) {\n      forSubtree(root, cb);\n      root = root.olderShadowRoot;\n    }\n  }\n  function forDocumentTree(doc, cb) {\n    _forDocumentTree(doc, cb, []);\n  }\n  function _forDocumentTree(doc, cb, processingDocuments) {\n    doc = wrap(doc);\n    if (processingDocuments.indexOf(doc) >= 0) {\n      return;\n    }\n    processingDocuments.push(doc);\n    var imports = doc.querySelectorAll(\"link[rel=\" + IMPORT_LINK_TYPE + \"]\");\n    for (var i = 0, l = imports.length, n; i < l && (n = imports[i]); i++) {\n      if (n.import) {\n        _forDocumentTree(n.import, cb, processingDocuments);\n      }\n    }\n    cb(doc);\n  }\n  scope.forDocumentTree = forDocumentTree;\n  scope.forSubtree = forSubtree;\n});\n\nCustomElements.addModule(function(scope) {\n  var flags = scope.flags;\n  var forSubtree = scope.forSubtree;\n  var forDocumentTree = scope.forDocumentTree;\n  function addedNode(node) {\n    return added(node) || addedSubtree(node);\n  }\n  function added(node) {\n    if (scope.upgrade(node)) {\n      return true;\n    }\n    attached(node);\n  }\n  function addedSubtree(node) {\n    forSubtree(node, function(e) {\n      if (added(e)) {\n        return true;\n      }\n    });\n  }\n  function attachedNode(node) {\n    attached(node);\n    if (inDocument(node)) {\n      forSubtree(node, function(e) {\n        attached(e);\n      });\n    }\n  }\n  var hasPolyfillMutations = !window.MutationObserver || window.MutationObserver === window.JsMutationObserver;\n  scope.hasPolyfillMutations = hasPolyfillMutations;\n  var isPendingMutations = false;\n  var pendingMutations = [];\n  function deferMutation(fn) {\n    pendingMutations.push(fn);\n    if (!isPendingMutations) {\n      isPendingMutations = true;\n      setTimeout(takeMutations);\n    }\n  }\n  function takeMutations() {\n    isPendingMutations = false;\n    var $p = pendingMutations;\n    for (var i = 0, l = $p.length, p; i < l && (p = $p[i]); i++) {\n      p();\n    }\n    pendingMutations = [];\n  }\n  function attached(element) {\n    if (hasPolyfillMutations) {\n      deferMutation(function() {\n        _attached(element);\n      });\n    } else {\n      _attached(element);\n    }\n  }\n  function _attached(element) {\n    if (element.__upgraded__ && (element.attachedCallback || element.detachedCallback)) {\n      if (!element.__attached && inDocument(element)) {\n        element.__attached = true;\n        if (element.attachedCallback) {\n          element.attachedCallback();\n        }\n      }\n    }\n  }\n  function detachedNode(node) {\n    detached(node);\n    forSubtree(node, function(e) {\n      detached(e);\n    });\n  }\n  function detached(element) {\n    if (hasPolyfillMutations) {\n      deferMutation(function() {\n        _detached(element);\n      });\n    } else {\n      _detached(element);\n    }\n  }\n  function _detached(element) {\n    if (element.__upgraded__ && (element.attachedCallback || element.detachedCallback)) {\n      if (element.__attached && !inDocument(element)) {\n        element.__attached = false;\n        if (element.detachedCallback) {\n          element.detachedCallback();\n        }\n      }\n    }\n  }\n  function inDocument(element) {\n    var p = element;\n    var doc = wrap(document);\n    while (p) {\n      if (p == doc) {\n        return true;\n      }\n      p = p.parentNode || p.nodeType === Node.DOCUMENT_FRAGMENT_NODE && p.host;\n    }\n  }\n  function watchShadow(node) {\n    if (node.shadowRoot && !node.shadowRoot.__watched) {\n      flags.dom && console.log(\"watching shadow-root for: \", node.localName);\n      var root = node.shadowRoot;\n      while (root) {\n        observe(root);\n        root = root.olderShadowRoot;\n      }\n    }\n  }\n  function handler(mutations) {\n    if (flags.dom) {\n      var mx = mutations[0];\n      if (mx && mx.type === \"childList\" && mx.addedNodes) {\n        if (mx.addedNodes) {\n          var d = mx.addedNodes[0];\n          while (d && d !== document && !d.host) {\n            d = d.parentNode;\n          }\n          var u = d && (d.URL || d._URL || d.host && d.host.localName) || \"\";\n          u = u.split(\"/?\").shift().split(\"/\").pop();\n        }\n      }\n      console.group(\"mutations (%d) [%s]\", mutations.length, u || \"\");\n    }\n    mutations.forEach(function(mx) {\n      if (mx.type === \"childList\") {\n        forEach(mx.addedNodes, function(n) {\n          if (!n.localName) {\n            return;\n          }\n          addedNode(n);\n        });\n        forEach(mx.removedNodes, function(n) {\n          if (!n.localName) {\n            return;\n          }\n          detachedNode(n);\n        });\n      }\n    });\n    flags.dom && console.groupEnd();\n  }\n  function takeRecords(node) {\n    node = wrap(node);\n    if (!node) {\n      node = wrap(document);\n    }\n    while (node.parentNode) {\n      node = node.parentNode;\n    }\n    var observer = node.__observer;\n    if (observer) {\n      handler(observer.takeRecords());\n      takeMutations();\n    }\n  }\n  var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);\n  function observe(inRoot) {\n    if (inRoot.__observer) {\n      return;\n    }\n    var observer = new MutationObserver(handler);\n    observer.observe(inRoot, {\n      childList: true,\n      subtree: true\n    });\n    inRoot.__observer = observer;\n  }\n  function upgradeDocument(doc) {\n    doc = wrap(doc);\n    flags.dom && console.group(\"upgradeDocument: \", doc.baseURI.split(\"/\").pop());\n    addedNode(doc);\n    observe(doc);\n    flags.dom && console.groupEnd();\n  }\n  function upgradeDocumentTree(doc) {\n    forDocumentTree(doc, upgradeDocument);\n  }\n  var originalCreateShadowRoot = Element.prototype.createShadowRoot;\n  if (originalCreateShadowRoot) {\n    Element.prototype.createShadowRoot = function() {\n      var root = originalCreateShadowRoot.call(this);\n      CustomElements.watchShadow(this);\n      return root;\n    };\n  }\n  scope.watchShadow = watchShadow;\n  scope.upgradeDocumentTree = upgradeDocumentTree;\n  scope.upgradeSubtree = addedSubtree;\n  scope.upgradeAll = addedNode;\n  scope.attachedNode = attachedNode;\n  scope.takeRecords = takeRecords;\n});\n\nCustomElements.addModule(function(scope) {\n  var flags = scope.flags;\n  function upgrade(node) {\n    if (!node.__upgraded__ && node.nodeType === Node.ELEMENT_NODE) {\n      var is = node.getAttribute(\"is\");\n      var definition = scope.getRegisteredDefinition(is || node.localName);\n      if (definition) {\n        if (is && definition.tag == node.localName) {\n          return upgradeWithDefinition(node, definition);\n        } else if (!is && !definition.extends) {\n          return upgradeWithDefinition(node, definition);\n        }\n      }\n    }\n  }\n  function upgradeWithDefinition(element, definition) {\n    flags.upgrade && console.group(\"upgrade:\", element.localName);\n    if (definition.is) {\n      element.setAttribute(\"is\", definition.is);\n    }\n    implementPrototype(element, definition);\n    element.__upgraded__ = true;\n    created(element);\n    scope.attachedNode(element);\n    scope.upgradeSubtree(element);\n    flags.upgrade && console.groupEnd();\n    return element;\n  }\n  function implementPrototype(element, definition) {\n    if (Object.__proto__) {\n      element.__proto__ = definition.prototype;\n    } else {\n      customMixin(element, definition.prototype, definition.native);\n      element.__proto__ = definition.prototype;\n    }\n  }\n  function customMixin(inTarget, inSrc, inNative) {\n    var used = {};\n    var p = inSrc;\n    while (p !== inNative && p !== HTMLElement.prototype) {\n      var keys = Object.getOwnPropertyNames(p);\n      for (var i = 0, k; k = keys[i]; i++) {\n        if (!used[k]) {\n          Object.defineProperty(inTarget, k, Object.getOwnPropertyDescriptor(p, k));\n          used[k] = 1;\n        }\n      }\n      p = Object.getPrototypeOf(p);\n    }\n  }\n  function created(element) {\n    if (element.createdCallback) {\n      element.createdCallback();\n    }\n  }\n  scope.upgrade = upgrade;\n  scope.upgradeWithDefinition = upgradeWithDefinition;\n  scope.implementPrototype = implementPrototype;\n});\n\nCustomElements.addModule(function(scope) {\n  var isIE11OrOlder = scope.isIE11OrOlder;\n  var upgradeDocumentTree = scope.upgradeDocumentTree;\n  var upgradeAll = scope.upgradeAll;\n  var upgradeWithDefinition = scope.upgradeWithDefinition;\n  var implementPrototype = scope.implementPrototype;\n  var useNative = scope.useNative;\n  function register(name, options) {\n    var definition = options || {};\n    if (!name) {\n      throw new Error(\"document.registerElement: first argument `name` must not be empty\");\n    }\n    if (name.indexOf(\"-\") < 0) {\n      throw new Error(\"document.registerElement: first argument ('name') must contain a dash ('-'). Argument provided was '\" + String(name) + \"'.\");\n    }\n    if (isReservedTag(name)) {\n      throw new Error(\"Failed to execute 'registerElement' on 'Document': Registration failed for type '\" + String(name) + \"'. The type name is invalid.\");\n    }\n    if (getRegisteredDefinition(name)) {\n      throw new Error(\"DuplicateDefinitionError: a type with name '\" + String(name) + \"' is already registered\");\n    }\n    if (!definition.prototype) {\n      definition.prototype = Object.create(HTMLElement.prototype);\n    }\n    definition.__name = name.toLowerCase();\n    definition.lifecycle = definition.lifecycle || {};\n    definition.ancestry = ancestry(definition.extends);\n    resolveTagName(definition);\n    resolvePrototypeChain(definition);\n    overrideAttributeApi(definition.prototype);\n    registerDefinition(definition.__name, definition);\n    definition.ctor = generateConstructor(definition);\n    definition.ctor.prototype = definition.prototype;\n    definition.prototype.constructor = definition.ctor;\n    if (scope.ready) {\n      upgradeDocumentTree(document);\n    }\n    return definition.ctor;\n  }\n  function overrideAttributeApi(prototype) {\n    if (prototype.setAttribute._polyfilled) {\n      return;\n    }\n    var setAttribute = prototype.setAttribute;\n    prototype.setAttribute = function(name, value) {\n      changeAttribute.call(this, name, value, setAttribute);\n    };\n    var removeAttribute = prototype.removeAttribute;\n    prototype.removeAttribute = function(name) {\n      changeAttribute.call(this, name, null, removeAttribute);\n    };\n    prototype.setAttribute._polyfilled = true;\n  }\n  function changeAttribute(name, value, operation) {\n    name = name.toLowerCase();\n    var oldValue = this.getAttribute(name);\n    operation.apply(this, arguments);\n    var newValue = this.getAttribute(name);\n    if (this.attributeChangedCallback && newValue !== oldValue) {\n      this.attributeChangedCallback(name, oldValue, newValue);\n    }\n  }\n  function isReservedTag(name) {\n    for (var i = 0; i < reservedTagList.length; i++) {\n      if (name === reservedTagList[i]) {\n        return true;\n      }\n    }\n  }\n  var reservedTagList = [ \"annotation-xml\", \"color-profile\", \"font-face\", \"font-face-src\", \"font-face-uri\", \"font-face-format\", \"font-face-name\", \"missing-glyph\" ];\n  function ancestry(extnds) {\n    var extendee = getRegisteredDefinition(extnds);\n    if (extendee) {\n      return ancestry(extendee.extends).concat([ extendee ]);\n    }\n    return [];\n  }\n  function resolveTagName(definition) {\n    var baseTag = definition.extends;\n    for (var i = 0, a; a = definition.ancestry[i]; i++) {\n      baseTag = a.is && a.tag;\n    }\n    definition.tag = baseTag || definition.__name;\n    if (baseTag) {\n      definition.is = definition.__name;\n    }\n  }\n  function resolvePrototypeChain(definition) {\n    if (!Object.__proto__) {\n      var nativePrototype = HTMLElement.prototype;\n      if (definition.is) {\n        var inst = document.createElement(definition.tag);\n        var expectedPrototype = Object.getPrototypeOf(inst);\n        if (expectedPrototype === definition.prototype) {\n          nativePrototype = expectedPrototype;\n        }\n      }\n      var proto = definition.prototype, ancestor;\n      while (proto && proto !== nativePrototype) {\n        ancestor = Object.getPrototypeOf(proto);\n        proto.__proto__ = ancestor;\n        proto = ancestor;\n      }\n      definition.native = nativePrototype;\n    }\n  }\n  function instantiate(definition) {\n    return upgradeWithDefinition(domCreateElement(definition.tag), definition);\n  }\n  var registry = {};\n  function getRegisteredDefinition(name) {\n    if (name) {\n      return registry[name.toLowerCase()];\n    }\n  }\n  function registerDefinition(name, definition) {\n    registry[name] = definition;\n  }\n  function generateConstructor(definition) {\n    return function() {\n      return instantiate(definition);\n    };\n  }\n  var HTML_NAMESPACE = \"http://www.w3.org/1999/xhtml\";\n  function createElementNS(namespace, tag, typeExtension) {\n    if (namespace === HTML_NAMESPACE) {\n      return createElement(tag, typeExtension);\n    } else {\n      return domCreateElementNS(namespace, tag);\n    }\n  }\n  function createElement(tag, typeExtension) {\n    if (tag) {\n      tag = tag.toLowerCase();\n    }\n    if (typeExtension) {\n      typeExtension = typeExtension.toLowerCase();\n    }\n    var definition = getRegisteredDefinition(typeExtension || tag);\n    if (definition) {\n      if (tag == definition.tag && typeExtension == definition.is) {\n        return new definition.ctor();\n      }\n      if (!typeExtension && !definition.is) {\n        return new definition.ctor();\n      }\n    }\n    var element;\n    if (typeExtension) {\n      element = createElement(tag);\n      element.setAttribute(\"is\", typeExtension);\n      return element;\n    }\n    element = domCreateElement(tag);\n    if (tag.indexOf(\"-\") >= 0) {\n      implementPrototype(element, HTMLElement);\n    }\n    return element;\n  }\n  var domCreateElement = document.createElement.bind(document);\n  var domCreateElementNS = document.createElementNS.bind(document);\n  var isInstance;\n  if (!Object.__proto__ && !useNative) {\n    isInstance = function(obj, ctor) {\n      var p = obj;\n      while (p) {\n        if (p === ctor.prototype) {\n          return true;\n        }\n        p = p.__proto__;\n      }\n      return false;\n    };\n  } else {\n    isInstance = function(obj, base) {\n      return obj instanceof base;\n    };\n  }\n  function wrapDomMethodToForceUpgrade(obj, methodName) {\n    var orig = obj[methodName];\n    obj[methodName] = function() {\n      var n = orig.apply(this, arguments);\n      upgradeAll(n);\n      return n;\n    };\n  }\n  wrapDomMethodToForceUpgrade(Node.prototype, \"cloneNode\");\n  wrapDomMethodToForceUpgrade(document, \"importNode\");\n  if (isIE11OrOlder) {\n    (function() {\n      var importNode = document.importNode;\n      document.importNode = function() {\n        var n = importNode.apply(document, arguments);\n        if (n.nodeType == n.DOCUMENT_FRAGMENT_NODE) {\n          var f = document.createDocumentFragment();\n          f.appendChild(n);\n          return f;\n        } else {\n          return n;\n        }\n      };\n    })();\n  }\n  document.registerElement = register;\n  document.createElement = createElement;\n  document.createElementNS = createElementNS;\n  scope.registry = registry;\n  scope.instanceof = isInstance;\n  scope.reservedTagList = reservedTagList;\n  scope.getRegisteredDefinition = getRegisteredDefinition;\n  document.register = document.registerElement;\n});\n\n(function(scope) {\n  var useNative = scope.useNative;\n  var initializeModules = scope.initializeModules;\n  var isIE11OrOlder = /Trident/.test(navigator.userAgent);\n  if (useNative) {\n    var nop = function() {};\n    scope.watchShadow = nop;\n    scope.upgrade = nop;\n    scope.upgradeAll = nop;\n    scope.upgradeDocumentTree = nop;\n    scope.upgradeSubtree = nop;\n    scope.takeRecords = nop;\n    scope.instanceof = function(obj, base) {\n      return obj instanceof base;\n    };\n  } else {\n    initializeModules();\n  }\n  var upgradeDocumentTree = scope.upgradeDocumentTree;\n  if (!window.wrap) {\n    if (window.ShadowDOMPolyfill) {\n      window.wrap = ShadowDOMPolyfill.wrapIfNeeded;\n      window.unwrap = ShadowDOMPolyfill.unwrapIfNeeded;\n    } else {\n      window.wrap = window.unwrap = function(node) {\n        return node;\n      };\n    }\n  }\n  function bootstrap() {\n    upgradeDocumentTree(wrap(document));\n    if (window.HTMLImports) {\n      HTMLImports.__importsParsingHook = function(elt) {\n        upgradeDocumentTree(wrap(elt.import));\n      };\n    }\n    CustomElements.ready = true;\n    setTimeout(function() {\n      CustomElements.readyTime = Date.now();\n      if (window.HTMLImports) {\n        CustomElements.elapsed = CustomElements.readyTime - HTMLImports.readyTime;\n      }\n      document.dispatchEvent(new CustomEvent(\"WebComponentsReady\", {\n        bubbles: true\n      }));\n    });\n  }\n  if (isIE11OrOlder && typeof window.CustomEvent !== \"function\") {\n    window.CustomEvent = function(inType, params) {\n      params = params || {};\n      var e = document.createEvent(\"CustomEvent\");\n      e.initCustomEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable), params.detail);\n      return e;\n    };\n    window.CustomEvent.prototype = window.Event.prototype;\n  }\n  if (document.readyState === \"complete\" || scope.flags.eager) {\n    bootstrap();\n  } else if (document.readyState === \"interactive\" && !window.attachEvent && (!window.HTMLImports || window.HTMLImports.ready)) {\n    bootstrap();\n  } else {\n    var loadEvent = window.HTMLImports && !HTMLImports.ready ? \"HTMLImportsLoaded\" : \"DOMContentLoaded\";\n    window.addEventListener(loadEvent, bootstrap);\n  }\n  scope.isIE11OrOlder = isIE11OrOlder;\n})(window.CustomElements);\n\n(function(scope) {\n  if (!Function.prototype.bind) {\n    Function.prototype.bind = function(scope) {\n      var self = this;\n      var args = Array.prototype.slice.call(arguments, 1);\n      return function() {\n        var args2 = args.slice();\n        args2.push.apply(args2, arguments);\n        return self.apply(scope, args2);\n      };\n    };\n  }\n})(window.WebComponents);\n\n(function(scope) {\n  \"use strict\";\n  if (!window.performance) {\n    var start = Date.now();\n    window.performance = {\n      now: function() {\n        return Date.now() - start;\n      }\n    };\n  }\n  if (!window.requestAnimationFrame) {\n    window.requestAnimationFrame = function() {\n      var nativeRaf = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame;\n      return nativeRaf ? function(callback) {\n        return nativeRaf(function() {\n          callback(performance.now());\n        });\n      } : function(callback) {\n        return window.setTimeout(callback, 1e3 / 60);\n      };\n    }();\n  }\n  if (!window.cancelAnimationFrame) {\n    window.cancelAnimationFrame = function() {\n      return window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || function(id) {\n        clearTimeout(id);\n      };\n    }();\n  }\n  var elementDeclarations = [];\n  var polymerStub = function(name, dictionary) {\n    if (typeof name !== \"string\" && arguments.length === 1) {\n      Array.prototype.push.call(arguments, document._currentScript);\n    }\n    elementDeclarations.push(arguments);\n  };\n  window.Polymer = polymerStub;\n  scope.consumeDeclarations = function(callback) {\n    scope.consumeDeclarations = function() {\n      throw \"Possible attempt to load Polymer twice\";\n    };\n    if (callback) {\n      callback(elementDeclarations);\n    }\n    elementDeclarations = null;\n  };\n  function installPolymerWarning() {\n    if (window.Polymer === polymerStub) {\n      window.Polymer = function() {\n        throw new Error(\"You tried to use polymer without loading it first. To \" + 'load polymer, <link rel=\"import\" href=\"' + 'components/polymer/polymer.html\">');\n      };\n    }\n  }\n  if (HTMLImports.useNative) {\n    installPolymerWarning();\n  } else {\n    addEventListener(\"DOMContentLoaded\", installPolymerWarning);\n  }\n})(window.WebComponents);\n\n(function(scope) {\n  var style = document.createElement(\"style\");\n  style.textContent = \"\" + \"body {\" + \"transition: opacity ease-in 0.2s;\" + \" } \\n\" + \"body[unresolved] {\" + \"opacity: 0; display: block; overflow: hidden; position: relative;\" + \" } \\n\";\n  var head = document.querySelector(\"head\");\n  head.insertBefore(style, head.firstChild);\n})(window.WebComponents);\n\n(function(scope) {\n  window.Platform = scope;\n})(window.WebComponents);",
    "// hbsfy compiled Handlebars template\nvar HandlebarsCompiler = require('hbsfy/runtime');\nmodule.exports = HandlebarsCompiler.template({\"compiler\":[6,\">= 2.0.0-beta.1\"],\"main\":function(depth0,helpers,partials,data) {\n    var helper;\n\n  return \"<h1>Hello \"\n    + this.escapeExpression(((helper = (helper = helpers.who || (depth0 != null ? depth0.who : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === \"function\" ? helper.call(depth0,{\"name\":\"who\",\"hash\":{},\"data\":data}) : helper)))\n    + \"</h1>\\n\";\n},\"useData\":true});\n",
    "import 'webcomponents.js/webcomponents.js' ;\nimport '../../sauce.js';\nimport QUnit from 'qunitjs';\nimport fwc from 'fwc';\n\nQUnit.module('Register');\n\nQUnit.asyncTest('register and access a component', 4, function(assert){\n    var container = document.getElementById('permanent-fixture');\n    assert.ok(container instanceof HTMLElement, 'The container exists');\n\n    fwc('base')\n        .on('error', function(e){\n            console.error(e);\n        })\n        .on('create', function(elt){\n\n            var fBase = container.querySelector('f-base');\n            assert.equal(fBase.nodeName, 'F-BASE', 'The f-base component is found');\n            assert.equal(fBase.nodeName, elt.nodeName, 'The f-base component is given in parameter');\n            assert.deepEqual(fBase, elt, 'The callback elt is the given node');\n\n            QUnit.start();\n        })\n        .register();\n});\n\n\nQUnit.asyncTest('register with another namespace', 4, function(assert){\n    var container = document.getElementById('permanent-fixture');\n    assert.ok(container instanceof HTMLElement, 'The container exists');\n\n    fwc('bar', {namespace : 'foo'})\n        .on('error', function(e){\n            console.error(e);\n        })\n        .on('create', function(elt){\n\n            var fooBar = container.querySelector('foo-bar');\n            assert.equal(fooBar.nodeName, 'FOO-BAR', 'The foo-bar component is found');\n            assert.equal(fooBar.nodeName, elt.nodeName, 'The foo-bar component is given in parameter');\n            assert.deepEqual(fooBar, elt, 'The callback elt is the given node');\n\n            QUnit.start();\n        })\n        .register();\n});\n\nQUnit.asyncTest('register and multiple component', 7, function(assert){\n    var container = document.getElementById('permanent-fixture');\n    assert.ok(container instanceof HTMLElement, 'The container exists');\n\n    var sum = 0;\n\n    fwc('multi')\n        .on('error', function(e){\n            console.error(e);\n        })\n        .on('create', function(elt){\n\n            assert.equal(elt.nodeName, 'F-MULTI', 'The element is a multi');\n            var value = parseInt(elt.getAttribute('value'), 10);\n            assert.ok(value > 0, 'The  value has an int');\n            sum += value;\n\n            if(sum === 7){\n\n                QUnit.start();\n            }\n        })\n        .register();\n});\n\nQUnit.module('Attributes');\n\nQUnit.asyncTest('define basic attributes', 8, function(assert){\n    var container = document.getElementById('permanent-fixture');\n    assert.ok(container instanceof HTMLElement, 'The container exists');\n\n    fwc('attr')\n        .on('error', function(e){\n            console.error(e);\n        })\n        .on('create', function(elt){\n\n            var fAttr = container.querySelector('f-attr');\n            assert.deepEqual(fAttr, elt, 'The callback elt is the given node');\n            assert.equal(fAttr.foo, '');\n            assert.equal(fAttr.bar, 'pur');\n            assert.equal(fAttr.foo, fAttr.getAttribute('foo'));\n            assert.equal(fAttr.bar, fAttr.getAttribute('bar'));\n\n            fAttr.foo = 'moo';\n            assert.equal(fAttr.foo, 'moo');\n            assert.equal(fAttr.foo, fAttr.getAttribute('foo'));\n\n            QUnit.start();\n        })\n        .attrs('foo', 'bar')\n        .register();\n});\n\nQUnit.asyncTest('define attributes with type casting', 16, function(assert){\n    var container = document.getElementById('permanent-fixture');\n    assert.ok(container instanceof HTMLElement, 'The container exists');\n\n    fwc('cast')\n        .on('error', function(e){\n            console.error(e);\n        })\n        .on('create', function(elt){\n\n            var fCast = container.querySelector('f-cast');\n            assert.deepEqual(fCast, elt, 'The callback elt is the given node');\n\n            assert.equal(fCast.getAttribute('int'), '134.12', \"The attribute exists\");\n            assert.equal(fCast.int, 134, \"The getter gives you the parsed value\");\n            fCast.int = \"5.77\";\n            assert.equal(fCast.getAttribute('int'), '5', \"The value is updated once parsed\");\n            assert.equal(fCast.int, 5, \"The getter gives you the parsed value\");\n\n            assert.equal(fCast.getAttribute('float'), 1.23, \"The attribute exists\");\n            assert.equal(fCast.float, 1.23, \"The getter gives you the parsed value\");\n            fCast.float = \"00.77\";\n            assert.equal(fCast.getAttribute('float'), '0.77', \"The value is updated once parsed\");\n            assert.equal(fCast.float, 0.77, \"The getter gives you the parsed value\");\n\n            assert.ok(fCast.hasAttribute('bool'), \"The attribute exists\");\n            assert.equal(fCast.bool, true, \"The attribute has the parsed value\");\n            fCast.bool = false;\n            assert.ok(!fCast.hasAttribute('bool'), \"The attribute doesn't exists anymore\");\n            assert.equal(fCast.bool, false, \"The attribute has the false value\");\n            fCast.bool = true;\n            assert.ok(fCast.hasAttribute('bool'), \"The attribute is again there\");\n            assert.equal(fCast.bool, true, \"The attribute has the true value\");\n\n            QUnit.start();\n        })\n        .attr('int',   { type : 'integer' })\n        .attr('float', { type : 'float' })\n        .attr('bool',  { type : 'boolean' })\n        .register();\n});\n\nQUnit.asyncTest('define attributes with accessors', 11, function(assert){\n    var container = document.getElementById('permanent-fixture');\n    assert.ok(container instanceof HTMLElement, 'The container exists');\n\n    fwc('access')\n        .on('error', function(e){\n            console.error(e);\n        })\n        .on('create', function(elt){\n\n            var fAccess = container.querySelector('f-access');\n            assert.deepEqual(fAccess, elt, 'The callback elt is the given node');\n            assert.equal(fAccess.getAttribute('num'), '1', 'The num attribute has the value');\n            assert.ok(fAccess.hasAttribute('bool'), 'The bool attribute exists');\n            assert.equal(fAccess.getAttribute('inc'), '0', 'The inc attribute has the value');\n            assert.equal(fAccess.getAttribute('double'), '0', 'The double attribute has the value');\n\n            assert.equal(fAccess.num, 1, 'The num getter is called');\n            assert.equal(fAccess.bool, false, 'The bool getter is called');\n            assert.equal(fAccess.inc, 1, 'The inc getter is called');\n            assert.equal(fAccess.inc, 2, 'The inc getter is called');\n\n            fAccess.double = 2;\n            assert.equal(fAccess.double, 4, 'The double setter is callede');\n\n            QUnit.start();\n        })\n        .attrs('num', 'bool', 'inc')\n        .access('num', {\n            get(val){\n               return parseInt(val, 10);\n            }\n        })\n        .access('double', {\n            get(val){\n               return parseInt(val, 10);\n            },\n            set(old, val){\n                val = parseInt(val, 10);\n                val = val * 2;\n                return val;\n            }\n        })\n        .access('bool', {\n            get(val){\n               return !!val;\n            }\n        })\n        .access('inc', {\n            get(val){\n                val = parseInt(val, 10);\n                this.setAttribute('inc', ++val);\n               return val;\n            }\n        })\n        .register();\n});\n\nQUnit.module('Methods');\n\nQUnit.asyncTest('Component with a method', 7, function(assert){\n    var container = document.getElementById('permanent-fixture');\n    assert.ok(container instanceof HTMLElement, 'The container exists');\n\n    var mTarget = container.querySelector('.mtarget');\n    assert.ok(mTarget.style.display !== 'none', \"The mtarget content is displayed\");\n\n    fwc('method')\n        .on('error', function(e){\n            console.error(e);\n        })\n        .on('create', function(elt){\n\n            var fMethod = container.querySelector('f-method');\n            assert.deepEqual(fMethod, elt, 'The callback elt is the given node');\n\n            assert.ok(typeof fMethod.hide === 'function', 'The element has the defined method');\n\n            fMethod.hide();\n\n            assert.equal(mTarget.style.display, 'none', \"The mtarget content isn't displayed anymore\");\n\n            QUnit.start();\n        })\n        .method('hide', function(){\n\n            var fMethod = container.querySelector('f-method');\n            assert.deepEqual(fMethod, this, 'This is the given node');\n\n            assert.equal(this.target, '.mtarget', 'The attribute value is correct');\n\n            document.querySelector(this.target).style.display = 'none';\n        })\n        .attrs('target')\n        .register();\n});\n\nQUnit.module('Content');\n\nQUnit.asyncTest('Component with content from a callback', 11, function(assert){\n    var container = document.getElementById('permanent-fixture');\n    assert.ok(container instanceof HTMLElement, 'The container exists');\n\n    var componentContent = function componentContent(data){\n\n        assert.ok(typeof data === 'object', 'The argument is an object that contains component attributes');\n        assert.ok(typeof data.foo === 'string', 'The argument is an object that contains the foo attribute');\n        assert.ok(typeof data.repeat === 'string', 'The argument is an object that contains the repeat attribute');\n\n        var content = '';\n        var times   = parseInt(data.repeat || 0);\n        while(times--){\n            content += `<li>${data.foo}</li>`;\n        }\n        return `<ul>${content}</ul>`;\n    };\n\n    assert.equal(container.querySelectorAll('f-content ul').length, 0, 'The component does not contain a list');\n\n    fwc('content')\n        .on('error', function(e){\n            console.error(e);\n        })\n        .on('create', function(elt){\n\n            var fContent = container.querySelector('f-content');\n            assert.deepEqual(fContent, elt, 'The callback elt is the given node');\n            assert.equal(fContent.repeat, '2', 'The repeat value is 2');\n            assert.equal(fContent.foo, 'moo', 'The foo value is moo');\n            assert.equal(elt.querySelectorAll('ul').length, 1, 'The component contains now a list');\n            assert.equal(elt.querySelectorAll('li').length, 2, 'The component contains now 2 list items');\n            assert.equal(elt.querySelector('li:first-child').textContent, 'moo', 'The list items have the foo value');\n\n            QUnit.start();\n        })\n        .attrs('foo', 'repeat')\n        .content(componentContent)\n        .register();\n});\n\nQUnit.asyncTest('Component with dynamic content from a template', 8, function(assert){\n    var container = document.getElementById('permanent-fixture');\n    assert.ok(container instanceof HTMLElement, 'The container exists');\n\n    var helloTpl = require('./hello.tpl');\n    assert.ok(typeof helloTpl === 'function', 'The template function exists');\n\n    assert.equal(container.querySelectorAll('f-dyncontent h1').length, 0, 'The component does not contain an h1');\n\n    fwc('dyncontent')\n        .on('error', function(e){\n            console.error(e);\n        })\n        .on('create', function(elt){\n\n            var fDynContent = container.querySelector('f-dyncontent');\n            assert.deepEqual(fDynContent, elt, 'The callback elt is the given node');\n\n            assert.equal(fDynContent.who, 'world', 'The attribute who has the world value');\n            assert.equal(container.querySelectorAll('f-dyncontent h1').length, 1, 'The component contains an h1');\n\n            assert.equal(fDynContent.textContent.trim(), 'Hello world', 'The element has the content from the who attribute');\n\n            fDynContent.who = \"Bertrand\";\n            setTimeout( () => {\n                assert.equal(fDynContent.textContent.trim(), 'Hello Bertrand', 'The element has the updated content');\n                QUnit.start();\n            }, 0);\n        })\n        .attr('who', { update: true })\n        .content(helloTpl)\n        .register();\n});\n\n\nQUnit.asyncTest('Component with dynamic content from an HTML template', 4, function(assert){\n    var container = document.getElementById('permanent-fixture');\n    assert.ok(container instanceof HTMLElement, 'The container exists');\n\n    var htpl = document.getElementById('htpl');\n\n    fwc('hcontent')\n        .on('create', function(elt){\n\n            var fHontent = container.querySelector('f-hcontent');\n            assert.deepEqual(fHontent, elt, 'The callback elt is the given node');\n\n            assert.equal(elt.querySelectorAll('p').length, 1, 'The component contains now a paragraph');\n            assert.equal(elt.innerHTML, htpl.innerHTML, 'The component content is the same as the template');\n\n            QUnit.start();\n        })\n        .content(htpl)\n        .register();\n});\n\n\nQUnit.module('extend');\n\nQUnit.asyncTest('Extend an anchor', 5, function(assert){\n    var container = document.getElementById('permanent-fixture');\n    assert.ok(container instanceof HTMLElement, 'The container exists');\n\n    var link = document.querySelector('a.link');\n\n    fwc('link')\n        .on('error', function(e){\n            console.error(e);\n        })\n        .on('create', function(elt){\n\n            var flink = document.querySelector('.flink');\n\n            assert.ok(flink instanceof HTMLElement, 'The component is an HTMLElement');\n            assert.ok(flink instanceof HTMLAnchorElement, 'The component is an HTMLAnchorElement');\n\n            assert.ok(link.href !== '#', \"Anchor's href use getter/setter to change the value\");\n            assert.equal(flink.href, link.href, \"The extended component uses base component getter/setter\");\n\n            QUnit.start();\n        })\n        .extend('a')\n        .register();\n});\n\n\nQUnit.asyncTest('Extend another component', 3, function(assert){\n    var container = document.getElementById('permanent-fixture');\n    assert.ok(container instanceof HTMLElement, 'The container exists');\n\n    fwc('upper')\n        .on('error', function(e){\n            console.error(e);\n        })\n        .on('create', function(elt){\n            assert.ok(false, 'the parent element should not be created');\n        })\n        .access('bar', {\n            get(val){\n                val = val || '';\n               return val.toUpperCase();\n            }\n        })\n        .register();\n\n    fwc('superup')\n        .on('create', function(elt){\n\n            var fsuperup = document.querySelector('.superup');\n\n            assert.deepEqual(fsuperup, elt, 'The callback elt is the given node');\n            assert.equal(elt.bar, 'BAR', 'Super element prototype has been extended');\n\n            QUnit.start();\n        })\n        .extend('upper')\n        .register();\n});\n\nQUnit.module('Native events');\n\nQUnit.test('on click', 3, function(assert){\n    var done = assert.async();\n    var container = document.getElementById('permanent-fixture');\n    assert.ok(container instanceof HTMLElement, 'The container exists');\n\n    fwc('native')\n        .on('error', function(e){\n            console.error(e);\n        })\n        .on('create', function(elt){\n\n            var fNative = document.querySelector('f-native');\n            assert.deepEqual(fNative, elt, 'The callback elt is the given node');\n\n            fNative.click();\n        })\n        .on('click', function(elt){\n\n            var fNative = document.querySelector('f-native');\n            assert.deepEqual(fNative, elt, 'The callback elt is the given node');\n\n            done();\n        })\n        .register();\n});\n",
    "//expose QUnit results to sauce labs using globals (sad but true)\nimport QUnit  from 'qunitjs';\n\nvar testCases = [];\n\nQUnit.done(function(results) {\n\n    var failing = testCases\n        .filter(function(testCase) {\n            return testCase.result === false;\n        })\n        .map(function(testCase) {\n            return {\n                name:     testCase.module + ' : ' + testCase.name,\n                result:   testCase.result,\n                expected: testCase.expected,\n                actual:   testCase.actual,\n                source:   testCase.source\n            };\n        });\n\n    window.global_test_results = {\n        passed:   results.passed,\n        failed:   results.failed,\n        total:    results.total,\n        duration: results.runtime,\n        tests:    failing\n    };\n});\n\nQUnit.testStart(function() {\n    QUnit.log(function(details) {\n        testCases.push(details);\n    });\n});\n\n"
  ]
}